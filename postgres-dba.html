<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-05-15T06:54:49.0619194"><title>Полезные скрипты Postgres-DBA | Postgres Полезные русурсы</title><script type="application/json" id="virtual-toc-data">[{"id":"-td4k4i_1281","level":0,"title":"Список расширений установленных в текущей базе","anchor":"#-td4k4i_1281"},{"id":"-td4k4i_1283","level":0,"title":"Базы данных и дополнительная информация","anchor":"#-td4k4i_1283"},{"id":"-td4k4i_1395","level":0,"title":"Таблицы - размеры, индексы","anchor":"#-td4k4i_1395"},{"id":"-td4k4i_1462","level":0,"title":"Текущая активность с группировкой по базе","anchor":"#-td4k4i_1462"},{"id":"table-bloat-estimated","level":0,"title":"Table bloat (estimated)","anchor":"#table-bloat-estimated"},{"id":"b-tree-index-bloat","level":0,"title":"B-tree index bloat","anchor":"#b-tree-index-bloat"},{"id":"table-bloat","level":0,"title":"Table bloat","anchor":"#table-bloat"},{"id":"b-tree-indexes-bloat","level":0,"title":"B-tree indexes bloat","anchor":"#b-tree-indexes-bloat"},{"id":"tables-and-columns-without-stats","level":0,"title":"Tables and columns without stats","anchor":"#tables-and-columns-without-stats"},{"id":"-td4k4i_1829","level":0,"title":"Неиспользуемые и редко используемые индексы","anchor":"#-td4k4i_1829"},{"id":"-td4k4i_1866","level":0,"title":"Избыточные индексы","anchor":"#-td4k4i_1866"},{"id":"fk","level":0,"title":"FK и отсутствующие индексы","anchor":"#fk"},{"id":"-td4k4i_1912","level":0,"title":"Поиск невалидных индексы","anchor":"#-td4k4i_1912"},{"id":"lock-trees-light","level":0,"title":"Lock trees light версия","anchor":"#lock-trees-light"},{"id":"lock-trees","level":0,"title":"Lock trees полная версия","anchor":"#lock-trees"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Postgres Полезные русурсы Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/postgres-dba.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/postgres-dba.html#webpage",
    "url": "writerside-documentation/postgres-dba.html",
    "name": "Полезные скрипты Postgres-DBA | Postgres Полезные русурсы",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Postgres Полезные русурсы Help"
}</script><!-- End Schema.org --></head><body data-id="postgres-dba" data-main-title="Полезные скрипты Postgres-DBA" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Default-topic.md|Postgres - полезные ресурсы, руководства подсказки, советы"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Postgres Полезные русурсы  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="postgres-dba" id="postgres-dba.md">Полезные скрипты Postgres-DBA</h1><p id="-td4k4i_1280">Набор полезных скриптов для DBA. Многие из скриптов взяты с просторов интернета.</p><section class="chapter"><h2 id="-td4k4i_1281" data-toc="-td4k4i_1281">Список расширений установленных в текущей базе</h2><div class="code-block" data-lang="sql" data-disable-link-processing="true">select ae.name,
       installed_version,
       default_version,
       case when installed_version &lt;&gt; default_version then 'OLD' end as is_old
from pg_extension e
         join pg_available_extensions ae on extname = ae.name
order by ae.name;</div></section><section class="chapter"><h2 id="-td4k4i_1283" data-toc="-td4k4i_1283">Базы данных и дополнительная информация</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Databases: size, stats" data-disable-link-processing="true">--Databases: size, stats
with data as (select d.oid,
                     (select spcname from pg_tablespace where oid = dattablespace) as tblspace,
                     d.datname                                                     as database_name,
                     pg_catalog.pg_get_userbyid(d.datdba)                          as owner,
                     has_database_privilege(d.datname, 'connect')                  as has_access,
                     pg_database_size(d.datname)                                   as size,
                     stats_reset,
                     blks_hit,
                     blks_read,
                     xact_commit,
                     xact_rollback,
                     conflicts,
                     deadlocks,
                     temp_files,
                     temp_bytes
              from pg_catalog.pg_database d
                       join pg_stat_database s on s.datid = d.oid),
     data2 as (select null::oid          as oid,
                      null               as tblspace,
                      '*** TOTAL ***'    as database_name,
                      null               as owner,
                      true               as has_access,
                      sum(size)          as size,
                      null::timestamptz  as stats_reset,
                      sum(blks_hit)      as blks_hit,
                      sum(blks_read)     as blks_read,
                      sum(xact_commit)   as xact_commit,
                      sum(xact_rollback) as xact_rollback,
                      sum(conflicts)     as conflicts,
                      sum(deadlocks)     as deadlocks,
                      sum(temp_files)    as temp_files,
                      sum(temp_bytes)    as temp_bytes
               from data
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      true,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select oid,
                      tblspace,
                      database_name,
                      owner,
                      has_access,
                      size,
                      stats_reset,
                      blks_hit,
                      blks_read,
                      xact_commit,
                      xact_rollback,
                      conflicts,
                      deadlocks,
                      temp_files,
                      temp_bytes
               from data)
select database_name || coalesce(' [' || nullif(tblspace, 'pg_default') || ']', '') as &quot;Database&quot;,
       case
           when has_access then
               pg_size_pretty(size) || ' (' || round(
                       100 * size::numeric / nullif(sum(size) over (partition by (oid is null)), 0),
                       2
                                               )::text || '%)'
           else 'no access'
           end                                                                      as &quot;Size&quot;,
       (now() - stats_reset)::interval(0)::text                                     as &quot;Stats Age&quot;,
       case
           when blks_hit + blks_read &gt; 0 then
               (round(blks_hit * 100::numeric / (blks_hit + blks_read), 2))::text || '%'
           else null
           end                                                                      as &quot;Cache eff.&quot;,
       case
           when xact_commit + xact_rollback &gt; 0 then
               (round(xact_commit * 100::numeric / (xact_commit + xact_rollback), 2))::text || '%'
           else null
           end                                                                      as &quot;Committed&quot;,
       conflicts                                                                    as &quot;Conflicts&quot;,
       deadlocks                                                                    as &quot;Deadlocks&quot;,
       temp_files::text || coalesce(' (' || pg_size_pretty(temp_bytes) || ')', '')  as &quot;Temp. Files&quot;
from data2
order by oid is null desc, size desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1285" data-toc="-td4k4i_1285">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1286"><thead><tr class="ijRowHead" id="-td4k4i_1287"><th id="-td4k4i_1288"><p>Database</p></th><th id="-td4k4i_1289"><p>Size</p></th><th id="-td4k4i_1290"><p>Stats Age</p></th><th id="-td4k4i_1291"><p>Cache eff.</p></th><th id="-td4k4i_1292"><p>Committed</p></th><th id="-td4k4i_1293"><p>Conflicts</p></th><th id="-td4k4i_1294"><p>Deadlocks</p></th><th id="-td4k4i_1295"><p>Temp. Files</p></th></tr></thead><tbody><tr id="-td4k4i_1296"><td id="-td4k4i_1297"><p>*** TOTAL ***</p></td><td id="-td4k4i_1298"><p>6008 MB (100.00%)</p></td><td id="-td4k4i_1299"><p>null</p></td><td id="-td4k4i_1300"><p>92.36%</p></td><td id="-td4k4i_1301"><p>99.96%</p></td><td id="-td4k4i_1302"><p>0</p></td><td id="-td4k4i_1303"><p>0</p></td><td id="-td4k4i_1304"><p>249 (7899 MB)</p></td></tr><tr id="-td4k4i_1305"><td id="-td4k4i_1306"><p>null</p></td><td id="-td4k4i_1307"><p>null</p></td><td id="-td4k4i_1308"><p>null</p></td><td id="-td4k4i_1309"><p>null</p></td><td id="-td4k4i_1310"><p>null</p></td><td id="-td4k4i_1311"><p>null</p></td><td id="-td4k4i_1312"><p>null</p></td><td id="-td4k4i_1313"><p>null</p></td></tr><tr id="-td4k4i_1314"><td id="-td4k4i_1315"><p>devtestindex</p></td><td id="-td4k4i_1316"><p>5939 MB (98.85%)</p></td><td id="-td4k4i_1317"><p>null</p></td><td id="-td4k4i_1318"><p>92.26%</p></td><td id="-td4k4i_1319"><p>99.85%</p></td><td id="-td4k4i_1320"><p>0</p></td><td id="-td4k4i_1321"><p>0</p></td><td id="-td4k4i_1322"><p>249 (7899 MB)</p></td></tr><tr id="-td4k4i_1323"><td id="-td4k4i_1324"><p>dvdrental</p></td><td id="-td4k4i_1325"><p>15 MB (0.25%)</p></td><td id="-td4k4i_1326"><p>null</p></td><td id="-td4k4i_1327"><p>99.85%</p></td><td id="-td4k4i_1328"><p>99.96%</p></td><td id="-td4k4i_1329"><p>0</p></td><td id="-td4k4i_1330"><p>0</p></td><td id="-td4k4i_1331"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1332"><td id="-td4k4i_1333"><p>testsasist</p></td><td id="-td4k4i_1334"><p>8668 kB (0.14%)</p></td><td id="-td4k4i_1335"><p>null</p></td><td id="-td4k4i_1336"><p>99.93%</p></td><td id="-td4k4i_1337"><p>99.99%</p></td><td id="-td4k4i_1338"><p>0</p></td><td id="-td4k4i_1339"><p>0</p></td><td id="-td4k4i_1340"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1341"><td id="-td4k4i_1342"><p>devtestdatatypes</p></td><td id="-td4k4i_1343"><p>7900 kB (0.13%)</p></td><td id="-td4k4i_1344"><p>null</p></td><td id="-td4k4i_1345"><p>99.81%</p></td><td id="-td4k4i_1346"><p>99.98%</p></td><td id="-td4k4i_1347"><p>0</p></td><td id="-td4k4i_1348"><p>0</p></td><td id="-td4k4i_1349"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1350"><td id="-td4k4i_1351"><p>devtesttablespace</p></td><td id="-td4k4i_1352"><p>7884 kB (0.13%)</p></td><td id="-td4k4i_1353"><p>null</p></td><td id="-td4k4i_1354"><p>99.84%</p></td><td id="-td4k4i_1355"><p>99.91%</p></td><td id="-td4k4i_1356"><p>0</p></td><td id="-td4k4i_1357"><p>0</p></td><td id="-td4k4i_1358"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1359"><td id="-td4k4i_1360"><p>template1</p></td><td id="-td4k4i_1361"><p>7868 kB (0.13%)</p></td><td id="-td4k4i_1362"><p>null</p></td><td id="-td4k4i_1363"><p>99.91%</p></td><td id="-td4k4i_1364"><p>100.00%</p></td><td id="-td4k4i_1365"><p>0</p></td><td id="-td4k4i_1366"><p>0</p></td><td id="-td4k4i_1367"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1368"><td id="-td4k4i_1369"><p>devlearnpg</p></td><td id="-td4k4i_1370"><p>7868 kB (0.13%)</p></td><td id="-td4k4i_1371"><p>null</p></td><td id="-td4k4i_1372"><p>100.00%</p></td><td id="-td4k4i_1373"><p>100.00%</p></td><td id="-td4k4i_1374"><p>0</p></td><td id="-td4k4i_1375"><p>0</p></td><td id="-td4k4i_1376"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1377"><td id="-td4k4i_1378"><p>postgres</p></td><td id="-td4k4i_1379"><p>7844 kB (0.13%)</p></td><td id="-td4k4i_1380"><p>null</p></td><td id="-td4k4i_1381"><p>99.80%</p></td><td id="-td4k4i_1382"><p>99.99%</p></td><td id="-td4k4i_1383"><p>0</p></td><td id="-td4k4i_1384"><p>0</p></td><td id="-td4k4i_1385"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1386"><td id="-td4k4i_1387"><p>template0</p></td><td id="-td4k4i_1388"><p>7673 kB (0.12%)</p></td><td id="-td4k4i_1389"><p>null</p></td><td id="-td4k4i_1390"><p>null</p></td><td id="-td4k4i_1391"><p>null</p></td><td id="-td4k4i_1392"><p>0</p></td><td id="-td4k4i_1393"><p>0</p></td><td id="-td4k4i_1394"><p>0 (0 bytes)</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_1395" data-toc="-td4k4i_1395">Таблицы - размеры, индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables: table/index/TOAST size, number of rows" data-disable-link-processing="true">--Tables: table/index/TOAST size, number of rows

with data as (select c.oid,
                     (select spcname from pg_tablespace where oid = reltablespace) as tblspace,
                     nspname                                                       as schema_name,
                     relname                                                       as table_name,
                     c.reltuples                                                   as row_estimate,
                     pg_total_relation_size(c.oid)                                 as total_bytes,
                     pg_indexes_size(c.oid)                                        as index_bytes,
                     pg_total_relation_size(reltoastrelid)                         as toast_bytes,
                     pg_total_relation_size(c.oid) - pg_indexes_size(c.oid) -
                     coalesce(pg_total_relation_size(reltoastrelid), 0)            as table_bytes
              from pg_class c
                       left join pg_namespace n on n.oid = c.relnamespace
              where relkind = 'r'
                and nspname &lt;&gt; 'pg_catalog'),
     data2 as (select null::oid         as oid,
                      null              as tblspace,
                      null              as schema_name,
                      '*** TOTAL ***'   as table_name,
                      sum(row_estimate) as row_estimate,
                      sum(total_bytes)  as total_bytes,
                      sum(index_bytes)  as index_bytes,
                      sum(toast_bytes)  as toast_bytes,
                      sum(table_bytes)  as table_bytes
               from data
               union all
               select null::oid                                                      as oid,
                      null,
                      null                                                           as schema_name,
                      '    tablespace: [' || coalesce(tblspace, 'pg_default') || ']' as table_name,
                      sum(row_estimate)                                              as row_estimate,
                      sum(total_bytes)                                               as total_bytes,
                      sum(index_bytes)                                               as index_bytes,
                      sum(toast_bytes)                                               as toast_bytes,
                      sum(table_bytes)                                               as table_bytes
               from data
               where (select count(distinct coalesce(tblspace, 'pg_default')) from data) &gt;
                     1 -- don't show this part if there are no custom tablespaces
               group by tblspace
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select *
               from data)
select coalesce(nullif(schema_name, 'public') || '.', '') || table_name ||
       coalesce(' [' || tblspace || ']', '')                  as &quot;Table&quot;,
       '~' || case
                  when row_estimate &gt; 10 ^ 12 then round(row_estimate::numeric / 10 ^ 12::numeric, 0)::text || 'T'
                  when row_estimate &gt; 10 ^ 9 then round(row_estimate::numeric / 10 ^ 9::numeric, 0)::text || 'B'
                  when row_estimate &gt; 10 ^ 6 then round(row_estimate::numeric / 10 ^ 6::numeric, 0)::text || 'M'
                  when row_estimate &gt; 10 ^ 3 then round(row_estimate::numeric / 10 ^ 3::numeric, 0)::text || 'k'
                  else row_estimate::text
           end                                                as &quot;Rows&quot;,
       pg_size_pretty(total_bytes) || ' (' || round(
               100 * total_bytes::numeric /
               nullif(sum(total_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Total Size&quot;,
       pg_size_pretty(table_bytes) || ' (' || round(
               100 * table_bytes::numeric /
               nullif(sum(table_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Table Size&quot;,
       pg_size_pretty(index_bytes) || ' (' || round(
               100 * index_bytes::numeric /
               nullif(sum(index_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Index(es) Size&quot;,
       pg_size_pretty(toast_bytes) || ' (' || round(
               100 * toast_bytes::numeric /
               nullif(sum(toast_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;TOAST Size&quot;
from data2
where schema_name is distinct from 'information_schema'
order by oid is null desc, total_bytes desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1397" data-toc="-td4k4i_1397">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1398"><thead><tr class="ijRowHead" id="-td4k4i_1399"><th id="-td4k4i_1400"><p>Table</p></th><th id="-td4k4i_1401"><p>Rows</p></th><th id="-td4k4i_1402"><p>Total Size</p></th><th id="-td4k4i_1403"><p>Table Size</p></th><th id="-td4k4i_1404"><p>Index(es) Size</p></th><th id="-td4k4i_1405"><p>TOAST Size</p></th></tr></thead><tbody><tr id="-td4k4i_1406"><td id="-td4k4i_1407"><p>*** TOTAL ***</p></td><td id="-td4k4i_1408"><p>~50M</p></td><td id="-td4k4i_1409"><p>5931 MB (100.00%)</p></td><td id="-td4k4i_1410"><p>3973 MB (100.00%)</p></td><td id="-td4k4i_1411"><p>1003 MB (100.00%)</p></td><td id="-td4k4i_1412"><p>955 MB (100.00%)</p></td></tr><tr id="-td4k4i_1413"><td id="-td4k4i_1414"><p>null</p></td><td id="-td4k4i_1415"><p>null</p></td><td id="-td4k4i_1416"><p>null</p></td><td id="-td4k4i_1417"><p>null</p></td><td id="-td4k4i_1418"><p>null</p></td><td id="-td4k4i_1419"><p>null</p></td></tr><tr id="-td4k4i_1420"><td id="-td4k4i_1421"><p>testidx</p></td><td id="-td4k4i_1422"><p>~12M</p></td><td id="-td4k4i_1423"><p>1853 MB (31.25%)</p></td><td id="-td4k4i_1424"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_1425"><p>504 MB (50.29%)</p></td><td id="-td4k4i_1426"><p>318 MB (33.32%)</p></td></tr><tr id="-td4k4i_1427"><td id="-td4k4i_1428"><p>teststat</p></td><td id="-td4k4i_1429"><p>~12M</p></td><td id="-td4k4i_1430"><p>1598 MB (26.95%)</p></td><td id="-td4k4i_1431"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_1432"><p>249 MB (24.85%)</p></td><td id="-td4k4i_1433"><p>318 MB (33.34%)</p></td></tr><tr id="-td4k4i_1434"><td id="-td4k4i_1435"><p>testnoidx</p></td><td id="-td4k4i_1436"><p>~12M</p></td><td id="-td4k4i_1437"><p>1598 MB (26.95%)</p></td><td id="-td4k4i_1438"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_1439"><p>249 MB (24.85%)</p></td><td id="-td4k4i_1440"><p>318 MB (33.34%)</p></td></tr><tr id="-td4k4i_1441"><td id="-td4k4i_1442"><p>t_agg</p></td><td id="-td4k4i_1443"><p>~10M</p></td><td id="-td4k4i_1444"><p>498 MB (8.39%)</p></td><td id="-td4k4i_1445"><p>498 MB (12.53%)</p></td><td id="-td4k4i_1446"><p>0 bytes (0.00%)</p></td><td id="-td4k4i_1447"><p>8192 bytes (0.00%)</p></td></tr><tr id="-td4k4i_1448"><td id="-td4k4i_1449"><p>testtbldata</p></td><td id="-td4k4i_1450"><p>~5M</p></td><td id="-td4k4i_1451"><p>384 MB (6.47%)</p></td><td id="-td4k4i_1452"><p>383 MB (9.65%)</p></td><td id="-td4k4i_1453"><p>0 bytes (0.00%)</p></td><td id="-td4k4i_1454"><p>8192 bytes (0.00%)</p></td></tr><tr id="-td4k4i_1455"><td id="-td4k4i_1456"><p>states</p></td><td id="-td4k4i_1457"><p>~3</p></td><td id="-td4k4i_1458"><p>56 kB (0.00%)</p></td><td id="-td4k4i_1459"><p>40 kB (0.00%)</p></td><td id="-td4k4i_1460"><p>16 kB (0.00%)</p></td><td id="-td4k4i_1461"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_1462" data-toc="-td4k4i_1462">Текущая активность с группировкой по базе</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Current activity: count of current connections grouped by database, user name, state" data-disable-link-processing="true">--Current activity: count of current connections grouped by database, user name, state
select
    coalesce(usename, '** ALL users **') as &quot;User&quot;,
    coalesce(datname, '** ALL databases **') as &quot;DB&quot;,
    coalesce(state, '** ALL states **') as &quot;Current State&quot;,
    count(*) as &quot;Count&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 minute') as &quot;State changed &gt;1m ago&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 hour') as &quot;State changed &gt;1h ago&quot;
from pg_stat_activity
group by grouping sets ((datname, usename, state), (usename, state), ())
order by
    usename is null desc,
    datname is null desc,
    2 asc,
    3 asc,
    count(*) desc
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1464" data-toc="-td4k4i_1464">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1465"><thead><tr class="ijRowHead" id="-td4k4i_1466"><th id="-td4k4i_1467"><p>User</p></th><th id="-td4k4i_1468"><p>DB</p></th><th id="-td4k4i_1469"><p>Current State</p></th><th id="-td4k4i_1470"><p>Count</p></th><th id="-td4k4i_1471"><p>State changed &gt;1m ago</p></th><th id="-td4k4i_1472"><p>State changed &gt;1h ago</p></th></tr></thead><tbody><tr id="-td4k4i_1473"><td id="-td4k4i_1474"><p>** ALL users **</p></td><td id="-td4k4i_1475"><p>** ALL databases **</p></td><td id="-td4k4i_1476"><p>** ALL states **</p></td><td id="-td4k4i_1477"><p>8</p></td><td id="-td4k4i_1478"><p>2</p></td><td id="-td4k4i_1479"><p>2</p></td></tr><tr id="-td4k4i_1480"><td id="-td4k4i_1481"><p>** ALL users **</p></td><td id="-td4k4i_1482"><p>** ALL databases **</p></td><td id="-td4k4i_1483"><p>** ALL states **</p></td><td id="-td4k4i_1484"><p>4</p></td><td id="-td4k4i_1485"><p>0</p></td><td id="-td4k4i_1486"><p>0</p></td></tr><tr id="-td4k4i_1487"><td id="-td4k4i_1488"><p>** ALL users **</p></td><td id="-td4k4i_1489"><p>** ALL databases **</p></td><td id="-td4k4i_1490"><p>** ALL states **</p></td><td id="-td4k4i_1491"><p>4</p></td><td id="-td4k4i_1492"><p>0</p></td><td id="-td4k4i_1493"><p>0</p></td></tr><tr id="-td4k4i_1494"><td id="-td4k4i_1495"><p>postgres</p></td><td id="-td4k4i_1496"><p>** ALL databases **</p></td><td id="-td4k4i_1497"><p>** ALL states **</p></td><td id="-td4k4i_1498"><p>1</p></td><td id="-td4k4i_1499"><p>0</p></td><td id="-td4k4i_1500"><p>0</p></td></tr><tr id="-td4k4i_1501"><td id="-td4k4i_1502"><p>postgres</p></td><td id="-td4k4i_1503"><p>** ALL databases **</p></td><td id="-td4k4i_1504"><p>** ALL states **</p></td><td id="-td4k4i_1505"><p>1</p></td><td id="-td4k4i_1506"><p>0</p></td><td id="-td4k4i_1507"><p>0</p></td></tr><tr id="-td4k4i_1508"><td id="-td4k4i_1509"><p>postgres</p></td><td id="-td4k4i_1510"><p>** ALL databases **</p></td><td id="-td4k4i_1511"><p>active</p></td><td id="-td4k4i_1512"><p>1</p></td><td id="-td4k4i_1513"><p>0</p></td><td id="-td4k4i_1514"><p>0</p></td></tr><tr id="-td4k4i_1515"><td id="-td4k4i_1516"><p>postgres</p></td><td id="-td4k4i_1517"><p>** ALL databases **</p></td><td id="-td4k4i_1518"><p>idle</p></td><td id="-td4k4i_1519"><p>2</p></td><td id="-td4k4i_1520"><p>2</p></td><td id="-td4k4i_1521"><p>2</p></td></tr><tr id="-td4k4i_1522"><td id="-td4k4i_1523"><p>postgres</p></td><td id="-td4k4i_1524"><p>devlearnpg</p></td><td id="-td4k4i_1525"><p>active</p></td><td id="-td4k4i_1526"><p>1</p></td><td id="-td4k4i_1527"><p>0</p></td><td id="-td4k4i_1528"><p>0</p></td></tr><tr id="-td4k4i_1529"><td id="-td4k4i_1530"><p>postgres</p></td><td id="-td4k4i_1531"><p>devtestindex</p></td><td id="-td4k4i_1532"><p>idle</p></td><td id="-td4k4i_1533"><p>1</p></td><td id="-td4k4i_1534"><p>1</p></td><td id="-td4k4i_1535"><p>1</p></td></tr><tr id="-td4k4i_1536"><td id="-td4k4i_1537"><p>postgres</p></td><td id="-td4k4i_1538"><p>devtesttablespace</p></td><td id="-td4k4i_1539"><p>idle</p></td><td id="-td4k4i_1540"><p>1</p></td><td id="-td4k4i_1541"><p>1</p></td><td id="-td4k4i_1542"><p>1</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat-estimated" data-toc="table-bloat-estimated">Table bloat (estimated)</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (estimated)" data-disable-link-processing="true">--Table bloat (estimated)

--This SQL is derived from https://github.com/ioguix/pgsql-bloat-estimation/blob/master/table/table_bloat.sql

/*
* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.
* This query is compatible with PostgreSQL 9.0 and more
*/

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (
    select
        tbl.oid tblid,
        ns.nspname as schema_name,
        tbl.relname as table_name,
        tbl.reltuples,
        tbl.relpages as heappages,
        coalesce(toast.relpages, 0) as toastpages,
        coalesce(toast.reltuples, 0) as toasttuples,
        coalesce(substring(array_to_string(tbl.reloptions, ' ') from '%fillfactor=#&quot;__#&quot;%' for '#')::int2, 100) as fillfactor,
        current_setting('block_size')::numeric as bs,
        case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as ma, -- NS: TODO: check it
        24 as page_hdr,
        23 + case when max(coalesce(null_frac, 0)) &gt; 0 then (7 + count(*)) / 8 else 0::int end
            + case when bool_or(att.attname = 'oid' and att.attnum &lt; 0) then 4 else 0 end as tpl_hdr_size,
        sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) as tpl_data_size,
        bool_or(att.atttypid = 'pg_catalog.name'::regtype)
            or sum(case when att.attnum &gt; 0 then 1 else 0 end) &lt;&gt; count(s.attname) as is_na
    from pg_attribute as att
             join pg_class as tbl on att.attrelid = tbl.oid and tbl.relkind = 'r'
             join pg_namespace as ns on ns.oid = tbl.relnamespace
             join pg_stats as s on s.schemaname = ns.nspname and s.tablename = tbl.relname and not s.inherited and s.attname = att.attname
             left join pg_class as toast on tbl.reltoastrelid = toast.oid
    where not att.attisdropped and s.schemaname not in ('pg_catalog', 'information_schema')
    group by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    order by 2, 3
), step2 as (
    select
        *,
        (
            4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                - case when tpl_hdr_size % ma = 0 then ma else tpl_hdr_size % ma end
                - case when ceil(tpl_data_size)::int % ma = 0 then ma else ceil(tpl_data_size)::int % ma end
            ) as tpl_size,
        bs - page_hdr as size_per_block,
        (heappages + toastpages) as tblpages
    from step1
), step3 as (
    select
        *,
        ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) as est_tblpages,
        ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) + ceil(toasttuples / 4) as est_tblpages_ff
    -- , stattuple.pgstattuple(tblid) as pst
    from step2
), step4 as (
    select
        *,
        tblpages * bs as real_size,
        (tblpages - est_tblpages) * bs as extra_size,
        case when tblpages - est_tblpages &gt; 0 then 100 * (tblpages - est_tblpages) / tblpages::float else 0 end as extra_ratio,
        (tblpages - est_tblpages_ff) * bs as bloat_size,
        case when tblpages - est_tblpages_ff &gt; 0 then 100 * (tblpages - est_tblpages_ff) / tblpages::float else 0 end as bloat_ratio
    -- , (pst).free_percent + (pst).dead_tuple_percent as real_frag
    from step3
             left join pg_stat_user_tables su on su.relid = tblid
    -- WHERE NOT is_na
    --   AND tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 &gt;= 1
)
select
    case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name as &quot;Table&quot;,
    pg_size_pretty(real_size::numeric) as &quot;Size&quot;,
    case
        when extra_size::numeric &gt;= 0
            then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text || '%)'
        else null
        end  as &quot;Extra&quot;,
    case
        when bloat_size::numeric &gt;= 0
            then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text || '%)'
        else null
        end as &quot;Bloat estimate&quot;,
    case
        when (real_size - bloat_size)::numeric &gt;=0
            then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
        else null
        end as &quot;Live&quot;,
    greatest(last_autovacuum, last_vacuum)::timestamp(0)::text
        || case greatest(last_autovacuum, last_vacuum)
               when last_autovacuum then ' (auto)'
               else '' end as &quot;Last Vaccuum&quot;,
    (
        select
            coalesce(substring(array_to_string(reloptions, ' ') from 'fillfactor=([0-9]+)')::smallint, 100)
        from pg_class
        where oid = tblid
    ) as &quot;Fillfactor&quot;
from step4
order by bloat_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1544" data-toc="-td4k4i_1544">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1545"><thead><tr class="ijRowHead" id="-td4k4i_1546"><th id="-td4k4i_1547"><p>Is N/A</p></th><th id="-td4k4i_1548"><p>Table</p></th><th id="-td4k4i_1549"><p>Size</p></th><th id="-td4k4i_1550"><p>Extra</p></th><th id="-td4k4i_1551"><p>Bloat estimate</p></th><th id="-td4k4i_1552"><p>Live</p></th><th id="-td4k4i_1553"><p>Last Vaccuum</p></th><th id="-td4k4i_1554"><p>Fillfactor</p></th></tr></thead><tbody><tr id="-td4k4i_1555"><td id="-td4k4i_1556"></td><td id="-td4k4i_1557"><p>testtbldata</p></td><td id="-td4k4i_1558"><p>383 MB</p></td><td id="-td4k4i_1559"><p>~14 MB (3.75%)</p></td><td id="-td4k4i_1560"><p>~14 MB (3.75%)</p></td><td id="-td4k4i_1561"><p>~369 MB</p></td><td id="-td4k4i_1562"><p>2024-03-25 03:54:41</p></td><td id="-td4k4i_1563"><p>100</p></td></tr><tr id="-td4k4i_1564"><td id="-td4k4i_1565"></td><td id="-td4k4i_1566"><p>t_agg</p></td><td id="-td4k4i_1567"><p>498 MB</p></td><td id="-td4k4i_1568"><p>~256 kB (0.05%)</p></td><td id="-td4k4i_1569"><p>~256 kB (0.05%)</p></td><td id="-td4k4i_1570"><p>~497 MB</p></td><td id="-td4k4i_1571"><p>2024-03-23 02:59:13</p></td><td id="-td4k4i_1572"><p>100</p></td></tr><tr id="-td4k4i_1573"><td id="-td4k4i_1574"></td><td id="-td4k4i_1575"><p>states</p></td><td id="-td4k4i_1576"><p>8192 bytes</p></td><td id="-td4k4i_1577"><p>~0 bytes (0.00%)</p></td><td id="-td4k4i_1578"><p>~0 bytes (0.00%)</p></td><td id="-td4k4i_1579"><p>~8192 bytes</p></td><td id="-td4k4i_1580"><p>2024-03-23 02:59:13</p></td><td id="-td4k4i_1581"><p>100</p></td></tr><tr id="-td4k4i_1582"><td id="-td4k4i_1583"></td><td id="-td4k4i_1584"><p>teststat</p></td><td id="-td4k4i_1585"><p>1344 MB</p></td><td id="-td4k4i_1586"><p>null</p></td><td id="-td4k4i_1587"><p>null</p></td><td id="-td4k4i_1588"><p>~1401 MB</p></td><td id="-td4k4i_1589"><p>2024-03-23 02:59:07</p></td><td id="-td4k4i_1590"><p>100</p></td></tr><tr id="-td4k4i_1591"><td id="-td4k4i_1592"></td><td id="-td4k4i_1593"><p>testidx</p></td><td id="-td4k4i_1594"><p>1344 MB</p></td><td id="-td4k4i_1595"><p>null</p></td><td id="-td4k4i_1596"><p>null</p></td><td id="-td4k4i_1597"><p>~1402 MB</p></td><td id="-td4k4i_1598"><p>2024-03-23 02:58:46</p></td><td id="-td4k4i_1599"><p>100</p></td></tr><tr id="-td4k4i_1600"><td id="-td4k4i_1601"></td><td id="-td4k4i_1602"><p>testnoidx</p></td><td id="-td4k4i_1603"><p>1344 MB</p></td><td id="-td4k4i_1604"><p>null</p></td><td id="-td4k4i_1605"><p>null</p></td><td id="-td4k4i_1606"><p>~1403 MB</p></td><td id="-td4k4i_1607"><p>2024-03-23 02:58:56</p></td><td id="-td4k4i_1608"><p>100</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-index-bloat" data-toc="b-tree-index-bloat">B-tree index bloat</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree index bloat (estimated)" data-disable-link-processing="true">--B-tree index bloat (estimated)

-- enhanced version of https://github.com/ioguix/pgsql-bloat-estimation/blob/master/btree/btree_bloat.sql

-- WARNING: executed with a non-superuser role, the query inspect only index on tables you are granted to read.
-- WARNING: rows with is_na = 't' are known to have bad statistics (&quot;name&quot; type is not supported).
-- This query is compatible with PostgreSQL 8.2+

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (select i.nspname                                                                        as schema_name,
                      i.tblname                                                                        as table_name,
                      i.idxname                                                                        as index_name,
                      i.reltuples,
                      i.relpages,
                      i.relam,
                      a.attrelid                                                                       AS table_oid,
                      current_setting('block_size')::numeric                                           AS bs,
                      fillfactor,
                      -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                      case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as maxalign,
                   /* per page header, fixed size: 20 for 7.X, 24 for others */
                      24                                                                               AS pagehdr,
                   /* per page btree opaque data */
                      16                                                                               AS pageopqdata,
                   /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                      case
                          when max(coalesce(s.null_frac, 0)) = 0 then 2 -- IndexTupleData size
                          else 2 + ((32 + 8 - 1) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                          end                                                                          as index_tuple_hdr_bm,
                   /* data len: we remove null values save space using it fractionnal part from stats */
                      sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024))                as nulldatawidth,
                      max(case when a.atttypid = 'pg_catalog.name'::regtype then 1 else 0 end) &gt; 0     as is_na
               from pg_attribute as a
                        join (select nspname,
                                     tbl.relname                                              AS tblname,
                                     idx.relname                                              AS idxname,
                                     idx.reltuples,
                                     idx.relpages,
                                     idx.relam,
                                     indrelid,
                                     indexrelid,
                                     indkey::smallint[]                                       AS attnum,
                                     coalesce(substring(array_to_string(idx.reloptions, ' ') from
                                                        'fillfactor=([0-9]+)')::smallint, 90) as fillfactor
                              from pg_index
                                       join pg_class idx on idx.oid = pg_index.indexrelid
                                       join pg_class tbl on tbl.oid = pg_index.indrelid
                                       join pg_namespace on pg_namespace.oid = idx.relnamespace
                              where pg_index.indisvalid
                                AND tbl.relkind = 'r'
                                AND idx.relpages &gt; 0) as i on a.attrelid = i.indexrelid
                        join pg_stats as s on
                   s.schemaname = i.nspname
                       and (
                       (s.tablename = i.tblname and
                        s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, true)) -- stats from tbl
                           OR (s.tablename = i.idxname AND s.attname = a.attname) -- stats from functionnal cols
                       )
                        join pg_type as t on a.atttypid = t.oid
               where a.attnum &gt; 0
               group by 1, 2, 3, 4, 5, 6, 7, 8, 9),
     step2 as (select *,
                      (
                          index_tuple_hdr_bm + maxalign
                              -- Add padding to the index tuple header to align on MAXALIGN
                              - case
                                    when index_tuple_hdr_bm % maxalign = 0 THEN maxalign
                                    else index_tuple_hdr_bm % maxalign end
                              + nulldatawidth + maxalign
                              -- Add padding to the data to align on MAXALIGN
                              - case
                                    when nulldatawidth = 0 then 0
                                    when nulldatawidth::integer % maxalign = 0 then maxalign
                                    else nulldatawidth::integer % maxalign
                              end
                          )::numeric as nulldatahdrwidth
               -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
               from step1),
     step3 as (select *,
                      -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
                      coalesce(
                              1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::float)),
                              0)                                                                      as est_pages,
                      coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) * fillfactor /
                                                          (100 * (4 + nulldatahdrwidth)::float))), 0) as est_pages_ff
               -- , stattuple.pgstatindex(quote_ident(nspname)||'.'||quote_ident(idxname)) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
               from step2
                        join pg_am am on step2.relam = am.oid
               where am.amname = 'btree'),
     step4 as (SELECT *,
                      bs * (relpages)::bigint                           AS real_size,
-------current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,
                      bs * (relpages - est_pages)::bigint               AS extra_size,
                      100 * (relpages - est_pages)::float / relpages    AS extra_ratio,
                      bs * (relpages - est_pages_ff)                    AS bloat_size,
                      100 * (relpages - est_pages_ff)::float / relpages AS bloat_ratio
               -- , 100-(sub.pst).avg_leaf_density, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, sub.reltuples, sub.relpages -- (DEBUG INFO)
               from step3
         -- WHERE NOT is_na
     )
select case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
       format(
               $out$%s
  (%s)$out$,
               left(index_name, 50) || case when length(index_name) &gt; 50 then '…' else '' end,
               coalesce(nullif(schema_name, 'public') || '.', '') || table_name
       )                                            as &quot;Index (Table)&quot;,
       pg_size_pretty(real_size::numeric)           as &quot;Size&quot;,
       case
           when extra_size::numeric &gt;= 0
               then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Extra&quot;,
       case
           when bloat_size::numeric &gt;= 0
               then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Bloat&quot;,
       case
           when (real_size - bloat_size)::numeric &gt;= 0
               then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
           else null
           end                                      as &quot;Live&quot;,
       fillfactor
from step4
order by real_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1610" data-toc="-td4k4i_1610">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1611"><thead><tr class="ijRowHead" id="-td4k4i_1612"><th id="-td4k4i_1613"><p>Is N/A</p></th><th id="-td4k4i_1614"><p>Index (Table)</p></th><th id="-td4k4i_1615"><p>Size</p></th><th id="-td4k4i_1616"><p>Extra</p></th><th id="-td4k4i_1617"><p>Bloat</p></th><th id="-td4k4i_1618"><p>Live</p></th><th id="-td4k4i_1619"><p>fillfactor</p></th></tr></thead><tbody><tr id="-td4k4i_1620"><td id="-td4k4i_1621"></td><td id="-td4k4i_1622"><p>teststat_pkey</p><br><p> (teststat)</p></td><td id="-td4k4i_1624"><p>249 MB</p></td><td id="-td4k4i_1625"><p>~26 MB (10.39%)</p></td><td id="-td4k4i_1626"><p>~904 kB (0.35%)</p></td><td id="-td4k4i_1627"><p>~248 MB</p></td><td id="-td4k4i_1628"><p>90</p></td></tr><tr id="-td4k4i_1629"><td id="-td4k4i_1630"></td><td id="-td4k4i_1631"><p>testidx_copy1_pkey</p><br><p> (testnoidx)</p></td><td id="-td4k4i_1633"><p>249 MB</p></td><td id="-td4k4i_1634"><p>~26 MB (10.29%)</p></td><td id="-td4k4i_1635"><p>~624 kB (0.24%)</p></td><td id="-td4k4i_1636"><p>~249 MB</p></td><td id="-td4k4i_1637"><p>90</p></td></tr><tr id="-td4k4i_1638"><td id="-td4k4i_1639"></td><td id="-td4k4i_1640"><p>testidx_pk</p><br><p> (testidx)</p></td><td id="-td4k4i_1642"><p>225 MB</p></td><td id="-td4k4i_1643"><p>~1328 kB (0.58%)</p></td><td id="-td4k4i_1644"><p>~1328 kB (0.58%)</p></td><td id="-td4k4i_1645"><p>~223 MB</p></td><td id="-td4k4i_1646"><p>100</p></td></tr><tr id="-td4k4i_1647"><td id="-td4k4i_1648"></td><td id="-td4k4i_1649"><p>testidx_created_at_index</p><br><p> (testidx)</p></td><td id="-td4k4i_1651"><p>165 MB</p></td><td id="-td4k4i_1652"><p>~15 MB (9.10%)</p></td><td id="-td4k4i_1653"><p>null</p></td><td id="-td4k4i_1654"><p>~167 MB</p></td><td id="-td4k4i_1655"><p>90</p></td></tr><tr id="-td4k4i_1656"><td id="-td4k4i_1657"></td><td id="-td4k4i_1658"><p>testidx_fk_id_index</p><br><p> (testidx)</p></td><td id="-td4k4i_1660"><p>114 MB</p></td><td id="-td4k4i_1661"><p>null</p></td><td id="-td4k4i_1662"><p>null</p></td><td id="-td4k4i_1663"><p>~247 MB</p></td><td id="-td4k4i_1664"><p>90</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat" data-toc="table-bloat">Table bloat</h2><p id="-td4k4i_1665">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-td4k4i_1666" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--Table bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without table name/mask query will read all available tables which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

select nspname,
       relname,
       pg_size_pretty(relation_size + toast_relation_size) as                                    total_size,
       pg_size_pretty(toast_relation_size)                 as                                    toast_size,
       round(((relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size, 1))::numeric, 1)                                           table_waste_percent,
       pg_size_pretty((relation_size - (relation_size - free_space) * 100 / fillfactor)::bigint) table_waste,
       round(((toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size + toast_relation_size, 1))::numeric, 1)                     total_waste_percent,
       pg_size_pretty((toast_free_space + relation_size -
                       (relation_size - free_space) * 100 / fillfactor)::bigint)                 total_waste
from (select nspname,
             relname,
             (select free_space from pgstattuple(c.oid))                                                         as free_space,
             pg_relation_size(c.oid)                                                                             as relation_size,
             (case
                  when reltoastrelid = 0 then 0
                  else (select free_space from pgstattuple(c.reltoastrelid)) end)                                as toast_free_space,
             coalesce(pg_relation_size(c.reltoastrelid), 0)                                                      as toast_relation_size,
             coalesce((SELECT (regexp_matches(reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),
                      '100')::real                                                                               AS fillfactor
      from pg_class c
               left join pg_namespace n on (n.oid = c.relnamespace)
      where nspname not in ('pg_catalog', 'information_schema')
        and nspname !~ '^pg_toast'
        and relkind = 'r'
        --put your table name/mask here
        and relname ~ '') t
order by (toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) desc
limit 20;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1669" data-toc="-td4k4i_1669">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1670"><thead><tr class="ijRowHead" id="-td4k4i_1671"><th id="-td4k4i_1672"><p>nspname</p></th><th id="-td4k4i_1673"><p>relname</p></th><th id="-td4k4i_1674"><p>total_size</p></th><th id="-td4k4i_1675"><p>toast_size</p></th><th id="-td4k4i_1676"><p>table_waste_percent</p></th><th id="-td4k4i_1677"><p>table_waste</p></th><th id="-td4k4i_1678"><p>total_waste_percent</p></th><th id="-td4k4i_1679"><p>total_waste</p></th></tr></thead><tbody><tr id="-td4k4i_1680"><td id="-td4k4i_1681"><p>public</p></td><td id="-td4k4i_1682"><p>teststat</p></td><td id="-td4k4i_1683"><p>1344 MB</p></td><td id="-td4k4i_1684"><p>314 MB</p></td><td id="-td4k4i_1685"><p>0.5</p></td><td id="-td4k4i_1686"><p>4829 kB</p></td><td id="-td4k4i_1687"><p>2.3</p></td><td id="-td4k4i_1688"><p>31 MB</p></td></tr><tr id="-td4k4i_1689"><td id="-td4k4i_1690"><p>public</p></td><td id="-td4k4i_1691"><p>testnoidx</p></td><td id="-td4k4i_1692"><p>1344 MB</p></td><td id="-td4k4i_1693"><p>314 MB</p></td><td id="-td4k4i_1694"><p>0.5</p></td><td id="-td4k4i_1695"><p>4829 kB</p></td><td id="-td4k4i_1696"><p>2.3</p></td><td id="-td4k4i_1697"><p>30 MB</p></td></tr><tr id="-td4k4i_1698"><td id="-td4k4i_1699"><p>public</p></td><td id="-td4k4i_1700"><p>testidx</p></td><td id="-td4k4i_1701"><p>1344 MB</p></td><td id="-td4k4i_1702"><p>314 MB</p></td><td id="-td4k4i_1703"><p>0.5</p></td><td id="-td4k4i_1704"><p>4829 kB</p></td><td id="-td4k4i_1705"><p>2.3</p></td><td id="-td4k4i_1706"><p>30 MB</p></td></tr><tr id="-td4k4i_1707"><td id="-td4k4i_1708"><p>public</p></td><td id="-td4k4i_1709"><p>testtbldata</p></td><td id="-td4k4i_1710"><p>383 MB</p></td><td id="-td4k4i_1711"><p>0 bytes</p></td><td id="-td4k4i_1712"><p>0.4</p></td><td id="-td4k4i_1713"><p>1746 kB</p></td><td id="-td4k4i_1714"><p>0.4</p></td><td id="-td4k4i_1715"><p>1746 kB</p></td></tr><tr id="-td4k4i_1716"><td id="-td4k4i_1717"><p>public</p></td><td id="-td4k4i_1718"><p>states</p></td><td id="-td4k4i_1719"><p>8192 bytes</p></td><td id="-td4k4i_1720"><p>0 bytes</p></td><td id="-td4k4i_1721"><p>97.7</p></td><td id="-td4k4i_1722"><p>8000 bytes</p></td><td id="-td4k4i_1723"><p>97.7</p></td><td id="-td4k4i_1724"><p>8000 bytes</p></td></tr><tr id="-td4k4i_1725"><td id="-td4k4i_1726"><p>public</p></td><td id="-td4k4i_1727"><p>t_agg</p></td><td id="-td4k4i_1728"><p>498 MB</p></td><td id="-td4k4i_1729"><p>0 bytes</p></td><td id="-td4k4i_1730"><p>0</p></td><td id="-td4k4i_1731"><p>5996 bytes</p></td><td id="-td4k4i_1732"><p>0</p></td><td id="-td4k4i_1733"><p>5996 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-indexes-bloat" data-toc="b-tree-indexes-bloat">B-tree indexes bloat</h2><p id="-td4k4i_1734">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-td4k4i_1735" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree indexes bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--B-tree indexes bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without index name/mask query will read all available indexes which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with data as (
    select
        schemaname as schema_name,
        p.relname as table_name,
        (select spcname from pg_tablespace where oid = c_table.reltablespace) as table_tblspace,
        (select spcname from pg_tablespace where oid = c.reltablespace) as index_tblspace,
        indexrelname as index_name,
        (
            select (case when avg_leaf_density = 'NaN' then 0
                         else greatest(ceil(index_size * (1 - avg_leaf_density / (coalesce((SELECT (regexp_matches(c.reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),'90')::real)))::bigint, 0) end)
            from pgstatindex(
                    case when p.indexrelid::regclass::text ~ '\.' then p.indexrelid::regclass::text else schemaname || '.' || p.indexrelid::regclass::text end
                 )
        ) as free_space,
        pg_relation_size(p.indexrelid) as index_size,
        pg_relation_size(p.relid) as table_size,
        idx_scan
    from pg_stat_user_indexes p
             join pg_class c on p.indexrelid = c.oid
             join pg_class c_table on p.relid = c_table.oid
    where
        pg_get_indexdef(p.indexrelid) like '%USING btree%'
      --put your index name/mask here
      and indexrelname ~ ''
)
select
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name || coalesce(' [' || table_tblspace || ']', '') as &quot;Table&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || index_name || coalesce(' [' || index_tblspace || ']', '') as &quot;Index&quot;,
    pg_size_pretty(table_size) as &quot;Table size&quot;,
    pg_size_pretty(index_size) as &quot;Index size&quot;,
    idx_scan as &quot;Index Scans&quot;,
    round((free_space*100/index_size)::numeric, 1) as &quot;Wasted, %&quot;,
    pg_size_pretty(free_space) as &quot;Wasted&quot;
from data
order by free_space desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1738" data-toc="-td4k4i_1738">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1739"><thead><tr class="ijRowHead" id="-td4k4i_1740"><th id="-td4k4i_1741"><p>Table</p></th><th id="-td4k4i_1742"><p>Index</p></th><th id="-td4k4i_1743"><p>Table size</p></th><th id="-td4k4i_1744"><p>Index size</p></th><th id="-td4k4i_1745"><p>Index Scans</p></th><th id="-td4k4i_1746"><p>Wasted, %</p></th><th id="-td4k4i_1747"><p>Wasted</p></th></tr></thead><tbody><tr id="-td4k4i_1748"><td id="-td4k4i_1749"><p>testidx</p></td><td id="-td4k4i_1750"><p>testidx_pk</p></td><td id="-td4k4i_1751"><p>1030 MB</p></td><td id="-td4k4i_1752"><p>225 MB</p></td><td id="-td4k4i_1753"><p>17240064</p></td><td id="-td4k4i_1754"><p>0</p></td><td id="-td4k4i_1755"><p>230 kB</p></td></tr><tr id="-td4k4i_1756"><td id="-td4k4i_1757"><p>states</p></td><td id="-td4k4i_1758"><p>states_pkey</p></td><td id="-td4k4i_1759"><p>8192 bytes</p></td><td id="-td4k4i_1760"><p>16 kB</p></td><td id="-td4k4i_1761"><p>3</p></td><td id="-td4k4i_1762"><p>99</p></td><td id="-td4k4i_1763"><p>16 kB</p></td></tr><tr id="-td4k4i_1764"><td id="-td4k4i_1765"><p>testnoidx</p></td><td id="-td4k4i_1766"><p>testidx_copy1_pkey</p></td><td id="-td4k4i_1767"><p>1030 MB</p></td><td id="-td4k4i_1768"><p>249 MB</p></td><td id="-td4k4i_1769"><p>2</p></td><td id="-td4k4i_1770"><p>0</p></td><td id="-td4k4i_1771"><p>0 bytes</p></td></tr><tr id="-td4k4i_1772"><td id="-td4k4i_1773"><p>teststat</p></td><td id="-td4k4i_1774"><p>teststat_pkey</p></td><td id="-td4k4i_1775"><p>1030 MB</p></td><td id="-td4k4i_1776"><p>249 MB</p></td><td id="-td4k4i_1777"><p>8620000</p></td><td id="-td4k4i_1778"><p>0</p></td><td id="-td4k4i_1779"><p>0 bytes</p></td></tr><tr id="-td4k4i_1780"><td id="-td4k4i_1781"><p>testidx</p></td><td id="-td4k4i_1782"><p>testidx_fk_id_index</p></td><td id="-td4k4i_1783"><p>1030 MB</p></td><td id="-td4k4i_1784"><p>114 MB</p></td><td id="-td4k4i_1785"><p>549</p></td><td id="-td4k4i_1786"><p>0</p></td><td id="-td4k4i_1787"><p>0 bytes</p></td></tr><tr id="-td4k4i_1788"><td id="-td4k4i_1789"><p>testidx</p></td><td id="-td4k4i_1790"><p>testidx_created_at_index</p></td><td id="-td4k4i_1791"><p>1030 MB</p></td><td id="-td4k4i_1792"><p>165 MB</p></td><td id="-td4k4i_1793"><p>41</p></td><td id="-td4k4i_1794"><p>0</p></td><td id="-td4k4i_1795"><p>0 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="tables-and-columns-without-stats" data-toc="tables-and-columns-without-stats">Tables and columns without stats</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables and columns without stats" data-disable-link-processing="true">--Tables and columns without stats
--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/bloat/no_stats_table_check.sql

SELECT table_schema, table_name,
       ( pg_class.relpages = 0 ) AS is_empty,
       ( psut.relname IS NULL OR ( psut.last_analyze IS NULL and psut.last_autoanalyze IS NULL ) ) AS never_analyzed,
       array_agg(column_name::TEXT) as no_stats_columns
FROM information_schema.columns
         JOIN pg_class ON columns.table_name = pg_class.relname
    AND pg_class.relkind = 'r'
         JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
    AND nspname = table_schema
         LEFT OUTER JOIN pg_stats
                         ON table_schema = pg_stats.schemaname
                             AND table_name = pg_stats.tablename
                             AND column_name = pg_stats.attname
         LEFT OUTER JOIN pg_stat_user_tables AS psut
                         ON table_schema = psut.schemaname
                             AND table_name = psut.relname
WHERE pg_stats.attname IS NULL
  AND table_schema NOT IN ('pg_catalog', 'information_schema')
GROUP BY table_schema, table_name, relpages, psut.relname, last_analyze, last_autoanalyze;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1797" data-toc="-td4k4i_1797">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1798"><thead><tr class="ijRowHead" id="-td4k4i_1799"><th id="-td4k4i_1800"><p>table_schema</p></th><th id="-td4k4i_1801"><p>table_name</p></th><th id="-td4k4i_1802"><p>is_empty</p></th><th id="-td4k4i_1803"><p>never_analyzed</p></th><th id="-td4k4i_1804"><p>no_stats_columns</p></th></tr></thead><tbody><tr id="-td4k4i_1805"><td id="-td4k4i_1806"><p>public</p></td><td id="-td4k4i_1807"><p>category</p></td><td id="-td4k4i_1808"><p>false</p></td><td id="-td4k4i_1809"><p>true</p></td><td id="-td4k4i_1810"><p>{name,category_id,last_update}</p></td></tr><tr id="-td4k4i_1811"><td id="-td4k4i_1812"><p>public</p></td><td id="-td4k4i_1813"><p>language</p></td><td id="-td4k4i_1814"><p>false</p></td><td id="-td4k4i_1815"><p>true</p></td><td id="-td4k4i_1816"><p>{last_update,name,language_id}</p></td></tr><tr id="-td4k4i_1817"><td id="-td4k4i_1818"><p>public</p></td><td id="-td4k4i_1819"><p>staff</p></td><td id="-td4k4i_1820"><p>false</p></td><td id="-td4k4i_1821"><p>true</p></td><td id="-td4k4i_1822"><p>{password,username,staff_id,first_name,email,last_name,picture,last_update,active,store_id,address_id}</p></td></tr><tr id="-td4k4i_1823"><td id="-td4k4i_1824"><p>public</p></td><td id="-td4k4i_1825"><p>store</p></td><td id="-td4k4i_1826"><p>false</p></td><td id="-td4k4i_1827"><p>true</p></td><td id="-td4k4i_1828"><p>{last_update,manager_staff_id,address_id,store_id}</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_1829" data-toc="-td4k4i_1829">Неиспользуемые и редко используемые индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Unused and rarely used indexes" data-disable-link-processing="true">--Unused and rarely used indexes

--PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/unused_indexes.sql

WITH table_scans as (
    SELECT relid,
           tables.idx_scan + tables.seq_scan as all_scans,
           ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
           pg_relation_size(relid) as table_size
    FROM pg_stat_user_tables as tables
),
     all_writes as (
         SELECT sum(writes) as total_writes
         FROM table_scans
     ),
     indexes as (
         SELECT idx_stat.relid, idx_stat.indexrelid,
                idx_stat.schemaname, idx_stat.relname as tablename,
                idx_stat.indexrelname as indexname,
                idx_stat.idx_scan,
                pg_relation_size(idx_stat.indexrelid) as index_bytes,
                indexdef ~* 'USING btree' AS idx_is_btree
         FROM pg_stat_user_indexes as idx_stat
                  JOIN pg_index
                       USING (indexrelid)
                  JOIN pg_indexes as indexes
                       ON idx_stat.schemaname = indexes.schemaname
                           AND idx_stat.relname = indexes.tablename
                           AND idx_stat.indexrelname = indexes.indexname
         WHERE pg_index.indisunique = FALSE
     ),
     index_ratios AS (
         SELECT schemaname, tablename, indexname,
                idx_scan, all_scans,
                round(( CASE WHEN all_scans = 0 THEN 0.0::NUMERIC
                             ELSE idx_scan::NUMERIC/all_scans * 100 END),2) as index_scan_pct,
                writes,
                round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2)
                                                                            as scans_per_write,
                pg_size_pretty(index_bytes) as index_size,
                pg_size_pretty(table_size) as table_size,
                idx_is_btree, index_bytes
         FROM indexes
                  JOIN table_scans
                       USING (relid)
     ),
     index_groups AS (
         SELECT 'Never Used Indexes' as reason, *, 1 as grp
         FROM index_ratios
         WHERE
             idx_scan = 0
           and idx_is_btree
         UNION ALL
         SELECT 'Low Scans, High Writes' as reason, *, 2 as grp
         FROM index_ratios
         WHERE
             scans_per_write &lt;= 1
           and index_scan_pct &lt; 10
           and idx_scan &gt; 0
           and writes &gt; 100
           and idx_is_btree
         UNION ALL
         SELECT 'Seldom Used Large Indexes' as reason, *, 3 as grp
         FROM index_ratios
         WHERE
             index_scan_pct &lt; 5
           and scans_per_write &gt; 1
           and idx_scan &gt; 0
           and idx_is_btree
           and index_bytes &gt; 100000000
         UNION ALL
         SELECT 'High-Write Large Non-Btree' as reason, index_ratios.*, 4 as grp
         FROM index_ratios, all_writes
         WHERE
             ( writes::NUMERIC / ( total_writes + 1 ) ) &gt; 0.02
           AND NOT idx_is_btree
           AND index_bytes &gt; 100000000
         ORDER BY grp, index_bytes DESC )
SELECT
    reason,
    schemaname as schema_name,
    tablename as table_name,
    indexname as index_name,
    index_scan_pct,
    scans_per_write,
    index_size,
    table_size,
    idx_scan,
    all_scans
FROM index_groups;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1831" data-toc="-td4k4i_1831">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1832"><thead><tr class="ijRowHead" id="-td4k4i_1833"><th id="-td4k4i_1834"><p>reason</p></th><th id="-td4k4i_1835"><p>schema_name</p></th><th id="-td4k4i_1836"><p>table_name</p></th><th id="-td4k4i_1837"><p>index_name</p></th><th id="-td4k4i_1838"><p>index_scan_pct</p></th><th id="-td4k4i_1839"><p>scans_per_write</p></th><th id="-td4k4i_1840"><p>index_size</p></th><th id="-td4k4i_1841"><p>table_size</p></th><th id="-td4k4i_1842"><p>idx_scan</p></th><th id="-td4k4i_1843"><p>all_scans</p></th></tr></thead><tbody><tr id="-td4k4i_1844"><td id="-td4k4i_1845"><p>Low Scans, High Writes</p></td><td id="-td4k4i_1846"><p>public</p></td><td id="-td4k4i_1847"><p>testidx</p></td><td id="-td4k4i_1848"><p>testidx_created_at_index</p></td><td id="-td4k4i_1849"><p>0</p></td><td id="-td4k4i_1850"><p>0</p></td><td id="-td4k4i_1851"><p>165 MB</p></td><td id="-td4k4i_1852"><p>1030 MB</p></td><td id="-td4k4i_1853"><p>41</p></td><td id="-td4k4i_1854"><p>17240843</p></td></tr><tr id="-td4k4i_1855"><td id="-td4k4i_1856"><p>Low Scans, High Writes</p></td><td id="-td4k4i_1857"><p>public</p></td><td id="-td4k4i_1858"><p>testidx</p></td><td id="-td4k4i_1859"><p>testidx_fk_id_index</p></td><td id="-td4k4i_1860"><p>0</p></td><td id="-td4k4i_1861"><p>0</p></td><td id="-td4k4i_1862"><p>114 MB</p></td><td id="-td4k4i_1863"><p>1030 MB</p></td><td id="-td4k4i_1864"><p>549</p></td><td id="-td4k4i_1865"><p>17240843</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_1866" data-toc="-td4k4i_1866">Избыточные индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Redundant indexes" data-disable-link-processing="true">--Redundant indexes

-- Use it to see redundant indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

with fk_indexes as (
    select
        n.nspname as schema_name,
        ci.relname as index_name,
        cr.relname as table_name,
        (confrelid::regclass)::text as fk_table_ref,
        array_to_string(indclass, ', ') as opclasses
    from pg_index i
             join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
             join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
             join pg_namespace n on n.oid = ci.relnamespace
             join pg_constraint cn on cn.conrelid = cr.oid
             left join pg_stat_user_indexes si on si.indexrelid = i.indexrelid
    where
        contype = 'f'
      and i.indisunique is false
      and conkey is not null
      and ci.relpages &gt; 0 -- raise for a DB with a lot of indexes
      and si.idx_scan &lt; 10
),
-- Redundant indexes
     index_data as (
         select
             *,
             (select string_agg(lpad(i, 3, '0'), ' ') from unnest(string_to_array(indkey::text, ' ')) i) as columns,
             array_to_string(indclass, ', ') as opclasses
         from pg_index i
                  join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
         where indisvalid = true and ci.relpages &gt; 0 -- raise for a DD with a lot of indexes
     ), redundant_indexes as (
    select
        i2.indexrelid as index_id,
        tnsp.nspname AS schema_name,
        trel.relname AS table_name,
        pg_relation_size(trel.oid) as table_size_bytes,
        irel.relname AS index_name,
        am1.amname as access_method,
        (i1.indexrelid::regclass)::text as reason,
        i1.indexrelid as reason_index_id,
        pg_get_indexdef(i1.indexrelid) main_index_def,
        pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size,
        pg_get_indexdef(i2.indexrelid) index_def,
        pg_relation_size(i2.indexrelid) index_size_bytes,
        s.idx_scan as index_usage,
        quote_ident(tnsp.nspname) as formated_schema_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) as formated_index_name,
        quote_ident(trel.relname) AS formated_table_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) as formated_relation_name,
        i2.opclasses
    from
        index_data as i1
            join index_data as i2 on (
            i1.indrelid = i2.indrelid -- same table
                and i1.indexrelid &lt;&gt; i2.indexrelid -- NOT same index
            )
            inner join pg_opclass op1 on i1.indclass[0] = op1.oid
            inner join pg_opclass op2 on i2.indclass[0] = op2.oid
            inner join pg_am am1 on op1.opcmethod = am1.oid
            inner join pg_am am2 on op2.opcmethod = am2.oid
            join pg_stat_user_indexes as s on s.indexrelid = i2.indexrelid
            join pg_class as trel on trel.oid = i2.indrelid
            join pg_namespace as tnsp on trel.relnamespace = tnsp.oid
            join pg_class as irel on irel.oid = i2.indexrelid
    where
        not i2.indisprimary -- index 1 is not primary
      and not ( -- skip if index1 is (primary or uniq) and is NOT (primary and uniq)
        i2.indisunique and not i1.indisprimary
        )
      and am1.amname = am2.amname -- same access type
      and i1.columns like (i2.columns || '%') -- index 2 includes all columns from index 1
      and i1.opclasses like (i2.opclasses || '%')
      -- index expressions is same
      and pg_get_expr(i1.indexprs, i1.indrelid) is not distinct from pg_get_expr(i2.indexprs, i2.indrelid)
      -- index predicates is same
      and pg_get_expr(i1.indpred, i1.indrelid) is not distinct from pg_get_expr(i2.indpred, i2.indrelid)
), redundant_indexes_fk as (
    select
        ri.*,
        (
            select count(1)
            from fk_indexes fi
            where
                fi.fk_table_ref = ri.table_name
              and fi.opclasses like (ri.opclasses || '%')
        ) &gt; 0 as supports_fk
    from redundant_indexes ri
),
-- Cut recursive links
     redundant_indexes_tmp_num as (
         select
                     row_number() over () num,
                     rig.*
         from redundant_indexes_fk rig
         order by index_id
     ), redundant_indexes_tmp_cut as (
    select
        ri1.*,
        ri2.num as r_num
    from redundant_indexes_tmp_num ri1
             left join redundant_indexes_tmp_num ri2 on ri2.reason_index_id = ri1.index_id and ri1.reason_index_id = ri2.index_id
    where ri1.num &lt; ri2.num or ri2.num is null
), redundant_indexes_cut_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
), redundant_indexes_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
)
select
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    string_agg(distinct reason, ', ') as redundant_to,
    string_agg(main_index_def, ', ') as main_index_def,
    string_agg(main_index_size, ', ') as main_index_size,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
from redundant_indexes_cut_grouped
group by
    index_id,
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
order by index_size_bytes desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1868" data-toc="-td4k4i_1868">Результат</h3></div><div class="collapse__content"><p id="-td4k4i_1869">TODO: добавить пример!</p></div></div></section></section><section class="chapter"><h2 id="fk" data-toc="fk">FK и отсутствующие индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--FKs with Missing/Bad Indexes" data-disable-link-processing="true">--FKs with Missing/Bad Indexes

--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/fk_no_index.sql

-- check for FKs where there is no matching index
-- on the referencing side
-- or a bad index

with fk_actions ( code, action ) as (
    values ('a', 'error'),
           ('r', 'restrict'),
           ('c', 'cascade'),
           ('n', 'set null'),
           ('d', 'set default')
), fk_list as (
    select
        pg_constraint.oid as fkoid, conrelid, confrelid as parentid,
        conname,
        relname,
        nspname,
        fk_actions_update.action as update_action,
        fk_actions_delete.action as delete_action,
        conkey as key_cols
    from pg_constraint
             join pg_class on conrelid = pg_class.oid
             join pg_namespace on pg_class.relnamespace = pg_namespace.oid
             join fk_actions as fk_actions_update on confupdtype = fk_actions_update.code
             join fk_actions as fk_actions_delete on confdeltype = fk_actions_delete.code
    where contype = 'f'
), fk_attributes as (
    select fkoid, conrelid, attname, attnum
    from fk_list
             join pg_attribute on conrelid = attrelid and attnum = any(key_cols)
    order by fkoid, attnum
), fk_cols_list as (
    select fkoid, array_agg(attname) as cols_list
    from fk_attributes
    group by fkoid
), index_list as (
    select
        indexrelid as indexid,
        pg_class.relname as indexname,
        indrelid,
        indkey,
        indpred is not null as has_predicate,
        pg_get_indexdef(indexrelid) as indexdef
    from pg_index
             join pg_class on indexrelid = pg_class.oid
    where indisvalid
), fk_index_match as (
    select
        fk_list.*,
        indexid,
        indexname,
        indkey::int[] as indexatts,
        has_predicate,
        indexdef,
        array_length(key_cols, 1) as fk_colcount,
        array_length(indkey,1) as index_colcount,
        round(pg_relation_size(conrelid)/(1024^2)::numeric) as table_mb,
        cols_list
    from fk_list
             join fk_cols_list using (fkoid)
             left join index_list on
        conrelid = indrelid
            and (indkey::int2[])[0:(array_length(key_cols,1) -1)] operator(pg_catalog.@&gt;) key_cols

), fk_perfect_match as (
    select fkoid
    from fk_index_match
    where
        (index_colcount - 1) &lt;= fk_colcount
      and not has_predicate
      and indexdef like '%USING btree%'
), fk_index_check as (
    select 'no index' as issue, *, 1 as issue_sort
    from fk_index_match
    where indexid is null
    union all
    select 'questionable index' as issue, *, 2
    from fk_index_match
    where
        indexid is not null
      and fkoid not in (select fkoid from fk_perfect_match)
), parent_table_stats as (
    select
        fkoid,
        tabstats.relname as parent_name,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as parent_writes,
        round(pg_relation_size(parentid)/(1024^2)::numeric) as parent_mb
    from pg_stat_user_tables as tabstats
             join fk_list on relid = parentid
), fk_table_stats as (
    select
        fkoid,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as writes,
        seq_scan as table_scans
    from pg_stat_user_tables as tabstats
             join fk_list on relid = conrelid
)
select
    nspname as schema_name,
    relname as table_name,
    conname as fk_name,
    issue,
    table_mb,
    writes,
    table_scans,
    parent_name,
    parent_mb,
    parent_writes,
    cols_list,
    indexdef
from fk_index_check
         join parent_table_stats using (fkoid)
         join fk_table_stats using (fkoid)
where
    table_mb &gt; 9
  and (
    writes &gt; 1000
        or parent_writes &gt; 1000
        or parent_mb &gt; 10
    )
order by issue_sort, table_mb desc, table_name, fk_name;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1871" data-toc="-td4k4i_1871">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1872"><thead><tr class="ijRowHead" id="-td4k4i_1873"><th id="-td4k4i_1874"><p>schema_name</p></th><th id="-td4k4i_1875"><p>table_name</p></th><th id="-td4k4i_1876"><p>fk_name</p></th><th id="-td4k4i_1877"><p>issue</p></th><th id="-td4k4i_1878"><p>table_mb</p></th><th id="-td4k4i_1879"><p>writes</p></th><th id="-td4k4i_1880"><p>table_scans</p></th><th id="-td4k4i_1881"><p>parent_name</p></th><th id="-td4k4i_1882"><p>parent_mb</p></th><th id="-td4k4i_1883"><p>parent_writes</p></th><th id="-td4k4i_1884"><p>cols_list</p></th><th id="-td4k4i_1885"><p>indexdef</p></th></tr></thead><tbody><tr id="-td4k4i_1886"><td id="-td4k4i_1887"><p>public</p></td><td id="-td4k4i_1888"><p>testnoidx</p></td><td id="-td4k4i_1889"><p>testidx_copy1_fk_id_fkey</p></td><td id="-td4k4i_1890"><p>no index</p></td><td id="-td4k4i_1891"><p>1030</p></td><td id="-td4k4i_1892"><p>11633001</p></td><td id="-td4k4i_1893"><p>920</p></td><td id="-td4k4i_1894"><p>testnoidx</p></td><td id="-td4k4i_1895"><p>1030</p></td><td id="-td4k4i_1896"><p>11633001</p></td><td id="-td4k4i_1897"><p>{fk_id}</p></td><td id="-td4k4i_1898"><p>null</p></td></tr><tr id="-td4k4i_1899"><td id="-td4k4i_1900"><p>public</p></td><td id="-td4k4i_1901"><p>teststat</p></td><td id="-td4k4i_1902"><p>teststat_fk_id_fkey</p></td><td id="-td4k4i_1903"><p>no index</p></td><td id="-td4k4i_1904"><p>1030</p></td><td id="-td4k4i_1905"><p>11633001</p></td><td id="-td4k4i_1906"><p>56</p></td><td id="-td4k4i_1907"><p>teststat</p></td><td id="-td4k4i_1908"><p>1030</p></td><td id="-td4k4i_1909"><p>11633001</p></td><td id="-td4k4i_1910"><p>{fk_id}</p></td><td id="-td4k4i_1911"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_1912" data-toc="-td4k4i_1912">Поиск невалидных индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Invalid indexes" data-disable-link-processing="true">--Invalid indexes

-- Use it to see invalid indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

select
    coalesce(nullif(pn.nspname, 'public') || '.', '') || pct.relname as &quot;relation_name&quot;,
    pci.relname as index_name,
    pn.nspname as schema_name,
    pct.relname as table_name,
    pg_size_pretty(pg_relation_size(pidx.indexrelid)) index_size,
    format(
            'DROP INDEX CONCURRENTLY %s; -- %s, table %s',
            pidx.indexrelid::regclass::text,
            'Invalid index',
            pct.relname) as drop_code,
    replace(
            format('%s; -- table %s', pg_get_indexdef(pidx.indexrelid), pct.relname),
            'CREATE INDEX',
            'CREATE INDEX CONCURRENTLY'
    ) as revert_code
from pg_index pidx
         join pg_class as pci on pci.oid = pidx.indexrelid
         join pg_class as pct on pct.oid = pidx.indrelid
         left join pg_namespace pn on pn.oid = pct.relnamespace
where pidx.indisvalid = false;</div></section><section class="chapter"><h2 id="lock-trees-light" data-toc="lock-trees-light">Lock trees light версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees (leightweight)" data-disable-link-processing="true">--Lock trees (leightweight)

-- Source: https://github.com/dataegret/pg-utils/blob/master/sql/locktree.sql
-- The paths won't be precise but this query is very light and may be used quite frequently

with recursive l as (
    select pid, locktype, granted,
           array_position(array['accessshare','rowshare','rowexclusive','shareupdateexclusive','share','sharerowexclusive','exclusive','accessexclusive'], left(mode,-4)) m,
           row(locktype,database,relation,page,tuple,virtualxid,transactionid,classid,objid,objsubid) obj from pg_locks
), pairs as (
    select w.pid waiter, l.pid locker, l.obj, l.m
    from l w join l on l.obj is not distinct from w.obj and l.locktype=w.locktype and not l.pid=w.pid and l.granted
    where not w.granted
      and not exists ( select from l i where i.pid=l.pid and i.locktype=l.locktype and i.obj is not distinct from l.obj and i.m &gt; l.m )
), leads as (
    select o.locker, 1::int lvl, count(*) q, array[locker] track, false as cycle from pairs o group by o.locker
    union all
    select i.locker, leads.lvl+1, (select count(*) from pairs q where q.locker=i.locker), leads.track||i.locker, i.locker=any(leads.track)
    from pairs i, leads where i.waiter=leads.locker and not cycle
), tree as (
    select locker pid,locker dad,locker root,case when cycle then track end dl, null::record obj,0 lvl,locker::text path,array_agg(locker) over () all_pids from leads o
    where (cycle and not exists (select from leads i where i.locker=any(o.track) and (i.lvl&gt;o.lvl or i.q&lt;o.q)))
       or (not cycle and not exists (select from pairs where waiter=o.locker) and not exists (select from leads i where i.locker=o.locker and i.lvl&lt;o.lvl))
    union all
    select w.waiter pid,tree.pid,tree.root,case when w.waiter=any(tree.dl) then tree.dl end,w.obj,tree.lvl+1,tree.path||'.'||w.waiter,all_pids || array_agg(w.waiter) over ()
    from tree join pairs w on tree.pid=w.locker and not w.waiter = any ( all_pids )
)
select (clock_timestamp() - a.xact_start)::interval(0) as ts_age,
       (clock_timestamp() - a.state_change)::interval(0) as change_age,
       a.datname,a.usename,a.client_addr,
       --w.obj wait_on_object,
       tree.pid,replace(a.state, 'idle in transaction', 'idletx') state,
       lvl,(select count(*) from tree p where p.path ~ ('^'||tree.path) and not p.path=tree.path) blocked,
       case when tree.pid=any(tree.dl) then '!&gt;' else repeat(' .', lvl) end||' '||trim(left(regexp_replace(a.query, e'\\s+', ' ', 'g'),100)) query
from tree
         left join pairs w on w.waiter=tree.pid and w.locker=tree.dad
         join pg_stat_activity a using (pid)
         join pg_stat_activity r on r.pid=tree.root
order by (now() - r.xact_start), path;</div></section><section class="chapter"><h2 id="lock-trees" data-toc="lock-trees">Lock trees полная версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees, detailed (based on pg_blocking_pids())" data-disable-link-processing="true">--Lock trees, detailed (based on pg_blocking_pids())

-- Based on: https://gitlab.com/-/snippets/1890428
-- See also: https://postgres.ai/blog/20211018-postgresql-lock-trees

begin;

set local statement_timeout to '100ms';

with recursive activity as (
    select
        pg_blocking_pids(pid) blocked_by,
        *,
        age(clock_timestamp(), xact_start)::interval(0) as tx_age,
        age(clock_timestamp(), state_change)::interval(0) as state_age
    from pg_stat_activity
    where state is distinct from 'idle'
), blockers as (
    select
        array_agg(distinct c order by c) as pids
    from (
             select unnest(blocked_by)
             from activity
         ) as dt(c)
), tree as (
    select
        activity.*,
        1 as level,
        activity.pid as top_blocker_pid,
        array[activity.pid] as path,
        array[activity.pid]::int[] as all_blockers_above
    from activity, blockers
    where
        array[pid] &lt;@ blockers.pids
      and blocked_by = '{}'::int[]
    union all
    select
        activity.*,
        tree.level + 1 as level,
        tree.top_blocker_pid,
        path || array[activity.pid] as path,
        tree.all_blockers_above || array_agg(activity.pid) over () as all_blockers_above
    from activity, tree
    where
        not array[activity.pid] &lt;@ tree.all_blockers_above
      and activity.blocked_by &lt;&gt; '{}'::int[]
      and activity.blocked_by &lt;@ tree.all_blockers_above
)
select
    pid,
    blocked_by,
    tx_age,
    state_age,
    backend_xid as xid,
    backend_xmin as xmin,
    replace(state, 'idle in transaction', 'idletx') as state,
    datname,
    usename,
    wait_event_type || ':' || wait_event as wait,
    (select count(distinct t1.pid) from tree t1 where array[tree.pid] &lt;@ t1.path and t1.pid &lt;&gt; tree.pid) as blkd,
    format(
            '%s %s%s',
            lpad('[' || pid::text || ']', 7, ' '),
            repeat('.', level - 1) || case when level &gt; 1 then ' ' end,
            left(query, 1000)
    ) as query
from tree
order by top_blocker_pid, level, pid;

commit;</div></section><div class="last-modified">Last modified: 15 мая 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="postgres-customextention.html" class="navigation-links__prev">Ресурсы и ссылки на дополнительные расширения</a><a href="postgres-dba-p2.html" class="navigation-links__next">Полезные скрипты Postgres-DBA часть 2</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>