<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-17T06:07:31.7481329"><title>Полезные скрипты Postgres-DBA | Postgres Полезные русурсы</title><script type="application/json" id="virtual-toc-data">[{"id":"-teoqar_640","level":0,"title":"Список расширений установленных в текущей базе","anchor":"#-teoqar_640"},{"id":"-teoqar_642","level":0,"title":"Базы данных и дополнительная информация","anchor":"#-teoqar_642"},{"id":"-teoqar_754","level":0,"title":"Таблицы - размеры, индексы","anchor":"#-teoqar_754"},{"id":"-teoqar_821","level":0,"title":"Текущая активность с группировкой по базе","anchor":"#-teoqar_821"},{"id":"table-bloat-estimated","level":0,"title":"Table bloat (estimated)","anchor":"#table-bloat-estimated"},{"id":"b-tree-index-bloat","level":0,"title":"B-tree index bloat","anchor":"#b-tree-index-bloat"},{"id":"table-bloat","level":0,"title":"Table bloat","anchor":"#table-bloat"},{"id":"b-tree-indexes-bloat","level":0,"title":"B-tree indexes bloat","anchor":"#b-tree-indexes-bloat"},{"id":"tables-and-columns-without-stats","level":0,"title":"Tables and columns without stats","anchor":"#tables-and-columns-without-stats"},{"id":"-teoqar_1188","level":0,"title":"Неиспользуемые и редко используемые индексы","anchor":"#-teoqar_1188"},{"id":"-teoqar_1225","level":0,"title":"Избыточные индексы","anchor":"#-teoqar_1225"},{"id":"fk","level":0,"title":"FK и отсутствующие индексы","anchor":"#fk"},{"id":"-teoqar_1271","level":0,"title":"Поиск невалидных индексы","anchor":"#-teoqar_1271"},{"id":"lock-trees-light","level":0,"title":"Lock trees light версия","anchor":"#lock-trees-light"},{"id":"lock-trees","level":0,"title":"Lock trees полная версия","anchor":"#lock-trees"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Postgres Полезные русурсы Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/postgres-dba.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/postgres-dba.html#webpage",
    "url": "writerside-documentation/postgres-dba.html",
    "name": "Полезные скрипты Postgres-DBA | Postgres Полезные русурсы",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Postgres Полезные русурсы Help"
}</script><!-- End Schema.org --></head><body data-id="postgres-dba" data-main-title="Полезные скрипты Postgres-DBA" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Default-topic.md|Postgres - полезные ресурсы, руководства подсказки, советы"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Postgres Полезные русурсы  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="postgres-dba" id="postgres-dba.md">Полезные скрипты Postgres-DBA</h1><p id="-teoqar_639">Набор полезных скриптов для DBA. Многие из скриптов взяты с просторов интернета.</p><section class="chapter"><h2 id="-teoqar_640" data-toc="-teoqar_640">Список расширений установленных в текущей базе</h2><div class="code-block" data-lang="sql" data-disable-link-processing="true">select ae.name,
       installed_version,
       default_version,
       case when installed_version &lt;&gt; default_version then 'OLD' end as is_old
from pg_extension e
         join pg_available_extensions ae on extname = ae.name
order by ae.name;</div></section><section class="chapter"><h2 id="-teoqar_642" data-toc="-teoqar_642">Базы данных и дополнительная информация</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Databases: size, stats" data-disable-link-processing="true">--Databases: size, stats
with data as (select d.oid,
                     (select spcname from pg_tablespace where oid = dattablespace) as tblspace,
                     d.datname                                                     as database_name,
                     pg_catalog.pg_get_userbyid(d.datdba)                          as owner,
                     has_database_privilege(d.datname, 'connect')                  as has_access,
                     pg_database_size(d.datname)                                   as size,
                     stats_reset,
                     blks_hit,
                     blks_read,
                     xact_commit,
                     xact_rollback,
                     conflicts,
                     deadlocks,
                     temp_files,
                     temp_bytes
              from pg_catalog.pg_database d
                       join pg_stat_database s on s.datid = d.oid),
     data2 as (select null::oid          as oid,
                      null               as tblspace,
                      '*** TOTAL ***'    as database_name,
                      null               as owner,
                      true               as has_access,
                      sum(size)          as size,
                      null::timestamptz  as stats_reset,
                      sum(blks_hit)      as blks_hit,
                      sum(blks_read)     as blks_read,
                      sum(xact_commit)   as xact_commit,
                      sum(xact_rollback) as xact_rollback,
                      sum(conflicts)     as conflicts,
                      sum(deadlocks)     as deadlocks,
                      sum(temp_files)    as temp_files,
                      sum(temp_bytes)    as temp_bytes
               from data
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      true,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select oid,
                      tblspace,
                      database_name,
                      owner,
                      has_access,
                      size,
                      stats_reset,
                      blks_hit,
                      blks_read,
                      xact_commit,
                      xact_rollback,
                      conflicts,
                      deadlocks,
                      temp_files,
                      temp_bytes
               from data)
select database_name || coalesce(' [' || nullif(tblspace, 'pg_default') || ']', '') as &quot;Database&quot;,
       case
           when has_access then
               pg_size_pretty(size) || ' (' || round(
                       100 * size::numeric / nullif(sum(size) over (partition by (oid is null)), 0),
                       2
                                               )::text || '%)'
           else 'no access'
           end                                                                      as &quot;Size&quot;,
       (now() - stats_reset)::interval(0)::text                                     as &quot;Stats Age&quot;,
       case
           when blks_hit + blks_read &gt; 0 then
               (round(blks_hit * 100::numeric / (blks_hit + blks_read), 2))::text || '%'
           else null
           end                                                                      as &quot;Cache eff.&quot;,
       case
           when xact_commit + xact_rollback &gt; 0 then
               (round(xact_commit * 100::numeric / (xact_commit + xact_rollback), 2))::text || '%'
           else null
           end                                                                      as &quot;Committed&quot;,
       conflicts                                                                    as &quot;Conflicts&quot;,
       deadlocks                                                                    as &quot;Deadlocks&quot;,
       temp_files::text || coalesce(' (' || pg_size_pretty(temp_bytes) || ')', '')  as &quot;Temp. Files&quot;
from data2
order by oid is null desc, size desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_644" data-toc="-teoqar_644">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_645"><thead><tr class="ijRowHead" id="-teoqar_646"><th id="-teoqar_647"><p>Database</p></th><th id="-teoqar_648"><p>Size</p></th><th id="-teoqar_649"><p>Stats Age</p></th><th id="-teoqar_650"><p>Cache eff.</p></th><th id="-teoqar_651"><p>Committed</p></th><th id="-teoqar_652"><p>Conflicts</p></th><th id="-teoqar_653"><p>Deadlocks</p></th><th id="-teoqar_654"><p>Temp. Files</p></th></tr></thead><tbody><tr id="-teoqar_655"><td id="-teoqar_656"><p>*** TOTAL ***</p></td><td id="-teoqar_657"><p>6008 MB (100.00%)</p></td><td id="-teoqar_658"><p>null</p></td><td id="-teoqar_659"><p>92.36%</p></td><td id="-teoqar_660"><p>99.96%</p></td><td id="-teoqar_661"><p>0</p></td><td id="-teoqar_662"><p>0</p></td><td id="-teoqar_663"><p>249 (7899 MB)</p></td></tr><tr id="-teoqar_664"><td id="-teoqar_665"><p>null</p></td><td id="-teoqar_666"><p>null</p></td><td id="-teoqar_667"><p>null</p></td><td id="-teoqar_668"><p>null</p></td><td id="-teoqar_669"><p>null</p></td><td id="-teoqar_670"><p>null</p></td><td id="-teoqar_671"><p>null</p></td><td id="-teoqar_672"><p>null</p></td></tr><tr id="-teoqar_673"><td id="-teoqar_674"><p>devtestindex</p></td><td id="-teoqar_675"><p>5939 MB (98.85%)</p></td><td id="-teoqar_676"><p>null</p></td><td id="-teoqar_677"><p>92.26%</p></td><td id="-teoqar_678"><p>99.85%</p></td><td id="-teoqar_679"><p>0</p></td><td id="-teoqar_680"><p>0</p></td><td id="-teoqar_681"><p>249 (7899 MB)</p></td></tr><tr id="-teoqar_682"><td id="-teoqar_683"><p>dvdrental</p></td><td id="-teoqar_684"><p>15 MB (0.25%)</p></td><td id="-teoqar_685"><p>null</p></td><td id="-teoqar_686"><p>99.85%</p></td><td id="-teoqar_687"><p>99.96%</p></td><td id="-teoqar_688"><p>0</p></td><td id="-teoqar_689"><p>0</p></td><td id="-teoqar_690"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_691"><td id="-teoqar_692"><p>testsasist</p></td><td id="-teoqar_693"><p>8668 kB (0.14%)</p></td><td id="-teoqar_694"><p>null</p></td><td id="-teoqar_695"><p>99.93%</p></td><td id="-teoqar_696"><p>99.99%</p></td><td id="-teoqar_697"><p>0</p></td><td id="-teoqar_698"><p>0</p></td><td id="-teoqar_699"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_700"><td id="-teoqar_701"><p>devtestdatatypes</p></td><td id="-teoqar_702"><p>7900 kB (0.13%)</p></td><td id="-teoqar_703"><p>null</p></td><td id="-teoqar_704"><p>99.81%</p></td><td id="-teoqar_705"><p>99.98%</p></td><td id="-teoqar_706"><p>0</p></td><td id="-teoqar_707"><p>0</p></td><td id="-teoqar_708"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_709"><td id="-teoqar_710"><p>devtesttablespace</p></td><td id="-teoqar_711"><p>7884 kB (0.13%)</p></td><td id="-teoqar_712"><p>null</p></td><td id="-teoqar_713"><p>99.84%</p></td><td id="-teoqar_714"><p>99.91%</p></td><td id="-teoqar_715"><p>0</p></td><td id="-teoqar_716"><p>0</p></td><td id="-teoqar_717"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_718"><td id="-teoqar_719"><p>template1</p></td><td id="-teoqar_720"><p>7868 kB (0.13%)</p></td><td id="-teoqar_721"><p>null</p></td><td id="-teoqar_722"><p>99.91%</p></td><td id="-teoqar_723"><p>100.00%</p></td><td id="-teoqar_724"><p>0</p></td><td id="-teoqar_725"><p>0</p></td><td id="-teoqar_726"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_727"><td id="-teoqar_728"><p>devlearnpg</p></td><td id="-teoqar_729"><p>7868 kB (0.13%)</p></td><td id="-teoqar_730"><p>null</p></td><td id="-teoqar_731"><p>100.00%</p></td><td id="-teoqar_732"><p>100.00%</p></td><td id="-teoqar_733"><p>0</p></td><td id="-teoqar_734"><p>0</p></td><td id="-teoqar_735"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_736"><td id="-teoqar_737"><p>postgres</p></td><td id="-teoqar_738"><p>7844 kB (0.13%)</p></td><td id="-teoqar_739"><p>null</p></td><td id="-teoqar_740"><p>99.80%</p></td><td id="-teoqar_741"><p>99.99%</p></td><td id="-teoqar_742"><p>0</p></td><td id="-teoqar_743"><p>0</p></td><td id="-teoqar_744"><p>0 (0 bytes)</p></td></tr><tr id="-teoqar_745"><td id="-teoqar_746"><p>template0</p></td><td id="-teoqar_747"><p>7673 kB (0.12%)</p></td><td id="-teoqar_748"><p>null</p></td><td id="-teoqar_749"><p>null</p></td><td id="-teoqar_750"><p>null</p></td><td id="-teoqar_751"><p>0</p></td><td id="-teoqar_752"><p>0</p></td><td id="-teoqar_753"><p>0 (0 bytes)</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-teoqar_754" data-toc="-teoqar_754">Таблицы - размеры, индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables: table/index/TOAST size, number of rows" data-disable-link-processing="true">--Tables: table/index/TOAST size, number of rows

with data as (select c.oid,
                     (select spcname from pg_tablespace where oid = reltablespace) as tblspace,
                     nspname                                                       as schema_name,
                     relname                                                       as table_name,
                     c.reltuples                                                   as row_estimate,
                     pg_total_relation_size(c.oid)                                 as total_bytes,
                     pg_indexes_size(c.oid)                                        as index_bytes,
                     pg_total_relation_size(reltoastrelid)                         as toast_bytes,
                     pg_total_relation_size(c.oid) - pg_indexes_size(c.oid) -
                     coalesce(pg_total_relation_size(reltoastrelid), 0)            as table_bytes
              from pg_class c
                       left join pg_namespace n on n.oid = c.relnamespace
              where relkind = 'r'
                and nspname &lt;&gt; 'pg_catalog'),
     data2 as (select null::oid         as oid,
                      null              as tblspace,
                      null              as schema_name,
                      '*** TOTAL ***'   as table_name,
                      sum(row_estimate) as row_estimate,
                      sum(total_bytes)  as total_bytes,
                      sum(index_bytes)  as index_bytes,
                      sum(toast_bytes)  as toast_bytes,
                      sum(table_bytes)  as table_bytes
               from data
               union all
               select null::oid                                                      as oid,
                      null,
                      null                                                           as schema_name,
                      '    tablespace: [' || coalesce(tblspace, 'pg_default') || ']' as table_name,
                      sum(row_estimate)                                              as row_estimate,
                      sum(total_bytes)                                               as total_bytes,
                      sum(index_bytes)                                               as index_bytes,
                      sum(toast_bytes)                                               as toast_bytes,
                      sum(table_bytes)                                               as table_bytes
               from data
               where (select count(distinct coalesce(tblspace, 'pg_default')) from data) &gt;
                     1 -- don't show this part if there are no custom tablespaces
               group by tblspace
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select *
               from data)
select coalesce(nullif(schema_name, 'public') || '.', '') || table_name ||
       coalesce(' [' || tblspace || ']', '')                  as &quot;Table&quot;,
       '~' || case
                  when row_estimate &gt; 10 ^ 12 then round(row_estimate::numeric / 10 ^ 12::numeric, 0)::text || 'T'
                  when row_estimate &gt; 10 ^ 9 then round(row_estimate::numeric / 10 ^ 9::numeric, 0)::text || 'B'
                  when row_estimate &gt; 10 ^ 6 then round(row_estimate::numeric / 10 ^ 6::numeric, 0)::text || 'M'
                  when row_estimate &gt; 10 ^ 3 then round(row_estimate::numeric / 10 ^ 3::numeric, 0)::text || 'k'
                  else row_estimate::text
           end                                                as &quot;Rows&quot;,
       pg_size_pretty(total_bytes) || ' (' || round(
               100 * total_bytes::numeric /
               nullif(sum(total_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Total Size&quot;,
       pg_size_pretty(table_bytes) || ' (' || round(
               100 * table_bytes::numeric /
               nullif(sum(table_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Table Size&quot;,
       pg_size_pretty(index_bytes) || ' (' || round(
               100 * index_bytes::numeric /
               nullif(sum(index_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Index(es) Size&quot;,
       pg_size_pretty(toast_bytes) || ' (' || round(
               100 * toast_bytes::numeric /
               nullif(sum(toast_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;TOAST Size&quot;
from data2
where schema_name is distinct from 'information_schema'
order by oid is null desc, total_bytes desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_756" data-toc="-teoqar_756">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_757"><thead><tr class="ijRowHead" id="-teoqar_758"><th id="-teoqar_759"><p>Table</p></th><th id="-teoqar_760"><p>Rows</p></th><th id="-teoqar_761"><p>Total Size</p></th><th id="-teoqar_762"><p>Table Size</p></th><th id="-teoqar_763"><p>Index(es) Size</p></th><th id="-teoqar_764"><p>TOAST Size</p></th></tr></thead><tbody><tr id="-teoqar_765"><td id="-teoqar_766"><p>*** TOTAL ***</p></td><td id="-teoqar_767"><p>~50M</p></td><td id="-teoqar_768"><p>5931 MB (100.00%)</p></td><td id="-teoqar_769"><p>3973 MB (100.00%)</p></td><td id="-teoqar_770"><p>1003 MB (100.00%)</p></td><td id="-teoqar_771"><p>955 MB (100.00%)</p></td></tr><tr id="-teoqar_772"><td id="-teoqar_773"><p>null</p></td><td id="-teoqar_774"><p>null</p></td><td id="-teoqar_775"><p>null</p></td><td id="-teoqar_776"><p>null</p></td><td id="-teoqar_777"><p>null</p></td><td id="-teoqar_778"><p>null</p></td></tr><tr id="-teoqar_779"><td id="-teoqar_780"><p>testidx</p></td><td id="-teoqar_781"><p>~12M</p></td><td id="-teoqar_782"><p>1853 MB (31.25%)</p></td><td id="-teoqar_783"><p>1030 MB (25.94%)</p></td><td id="-teoqar_784"><p>504 MB (50.29%)</p></td><td id="-teoqar_785"><p>318 MB (33.32%)</p></td></tr><tr id="-teoqar_786"><td id="-teoqar_787"><p>teststat</p></td><td id="-teoqar_788"><p>~12M</p></td><td id="-teoqar_789"><p>1598 MB (26.95%)</p></td><td id="-teoqar_790"><p>1030 MB (25.94%)</p></td><td id="-teoqar_791"><p>249 MB (24.85%)</p></td><td id="-teoqar_792"><p>318 MB (33.34%)</p></td></tr><tr id="-teoqar_793"><td id="-teoqar_794"><p>testnoidx</p></td><td id="-teoqar_795"><p>~12M</p></td><td id="-teoqar_796"><p>1598 MB (26.95%)</p></td><td id="-teoqar_797"><p>1030 MB (25.94%)</p></td><td id="-teoqar_798"><p>249 MB (24.85%)</p></td><td id="-teoqar_799"><p>318 MB (33.34%)</p></td></tr><tr id="-teoqar_800"><td id="-teoqar_801"><p>t_agg</p></td><td id="-teoqar_802"><p>~10M</p></td><td id="-teoqar_803"><p>498 MB (8.39%)</p></td><td id="-teoqar_804"><p>498 MB (12.53%)</p></td><td id="-teoqar_805"><p>0 bytes (0.00%)</p></td><td id="-teoqar_806"><p>8192 bytes (0.00%)</p></td></tr><tr id="-teoqar_807"><td id="-teoqar_808"><p>testtbldata</p></td><td id="-teoqar_809"><p>~5M</p></td><td id="-teoqar_810"><p>384 MB (6.47%)</p></td><td id="-teoqar_811"><p>383 MB (9.65%)</p></td><td id="-teoqar_812"><p>0 bytes (0.00%)</p></td><td id="-teoqar_813"><p>8192 bytes (0.00%)</p></td></tr><tr id="-teoqar_814"><td id="-teoqar_815"><p>states</p></td><td id="-teoqar_816"><p>~3</p></td><td id="-teoqar_817"><p>56 kB (0.00%)</p></td><td id="-teoqar_818"><p>40 kB (0.00%)</p></td><td id="-teoqar_819"><p>16 kB (0.00%)</p></td><td id="-teoqar_820"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-teoqar_821" data-toc="-teoqar_821">Текущая активность с группировкой по базе</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Current activity: count of current connections grouped by database, user name, state" data-disable-link-processing="true">--Current activity: count of current connections grouped by database, user name, state
select
    coalesce(usename, '** ALL users **') as &quot;User&quot;,
    coalesce(datname, '** ALL databases **') as &quot;DB&quot;,
    coalesce(state, '** ALL states **') as &quot;Current State&quot;,
    count(*) as &quot;Count&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 minute') as &quot;State changed &gt;1m ago&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 hour') as &quot;State changed &gt;1h ago&quot;
from pg_stat_activity
group by grouping sets ((datname, usename, state), (usename, state), ())
order by
    usename is null desc,
    datname is null desc,
    2 asc,
    3 asc,
    count(*) desc
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_823" data-toc="-teoqar_823">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_824"><thead><tr class="ijRowHead" id="-teoqar_825"><th id="-teoqar_826"><p>User</p></th><th id="-teoqar_827"><p>DB</p></th><th id="-teoqar_828"><p>Current State</p></th><th id="-teoqar_829"><p>Count</p></th><th id="-teoqar_830"><p>State changed &gt;1m ago</p></th><th id="-teoqar_831"><p>State changed &gt;1h ago</p></th></tr></thead><tbody><tr id="-teoqar_832"><td id="-teoqar_833"><p>** ALL users **</p></td><td id="-teoqar_834"><p>** ALL databases **</p></td><td id="-teoqar_835"><p>** ALL states **</p></td><td id="-teoqar_836"><p>8</p></td><td id="-teoqar_837"><p>2</p></td><td id="-teoqar_838"><p>2</p></td></tr><tr id="-teoqar_839"><td id="-teoqar_840"><p>** ALL users **</p></td><td id="-teoqar_841"><p>** ALL databases **</p></td><td id="-teoqar_842"><p>** ALL states **</p></td><td id="-teoqar_843"><p>4</p></td><td id="-teoqar_844"><p>0</p></td><td id="-teoqar_845"><p>0</p></td></tr><tr id="-teoqar_846"><td id="-teoqar_847"><p>** ALL users **</p></td><td id="-teoqar_848"><p>** ALL databases **</p></td><td id="-teoqar_849"><p>** ALL states **</p></td><td id="-teoqar_850"><p>4</p></td><td id="-teoqar_851"><p>0</p></td><td id="-teoqar_852"><p>0</p></td></tr><tr id="-teoqar_853"><td id="-teoqar_854"><p>postgres</p></td><td id="-teoqar_855"><p>** ALL databases **</p></td><td id="-teoqar_856"><p>** ALL states **</p></td><td id="-teoqar_857"><p>1</p></td><td id="-teoqar_858"><p>0</p></td><td id="-teoqar_859"><p>0</p></td></tr><tr id="-teoqar_860"><td id="-teoqar_861"><p>postgres</p></td><td id="-teoqar_862"><p>** ALL databases **</p></td><td id="-teoqar_863"><p>** ALL states **</p></td><td id="-teoqar_864"><p>1</p></td><td id="-teoqar_865"><p>0</p></td><td id="-teoqar_866"><p>0</p></td></tr><tr id="-teoqar_867"><td id="-teoqar_868"><p>postgres</p></td><td id="-teoqar_869"><p>** ALL databases **</p></td><td id="-teoqar_870"><p>active</p></td><td id="-teoqar_871"><p>1</p></td><td id="-teoqar_872"><p>0</p></td><td id="-teoqar_873"><p>0</p></td></tr><tr id="-teoqar_874"><td id="-teoqar_875"><p>postgres</p></td><td id="-teoqar_876"><p>** ALL databases **</p></td><td id="-teoqar_877"><p>idle</p></td><td id="-teoqar_878"><p>2</p></td><td id="-teoqar_879"><p>2</p></td><td id="-teoqar_880"><p>2</p></td></tr><tr id="-teoqar_881"><td id="-teoqar_882"><p>postgres</p></td><td id="-teoqar_883"><p>devlearnpg</p></td><td id="-teoqar_884"><p>active</p></td><td id="-teoqar_885"><p>1</p></td><td id="-teoqar_886"><p>0</p></td><td id="-teoqar_887"><p>0</p></td></tr><tr id="-teoqar_888"><td id="-teoqar_889"><p>postgres</p></td><td id="-teoqar_890"><p>devtestindex</p></td><td id="-teoqar_891"><p>idle</p></td><td id="-teoqar_892"><p>1</p></td><td id="-teoqar_893"><p>1</p></td><td id="-teoqar_894"><p>1</p></td></tr><tr id="-teoqar_895"><td id="-teoqar_896"><p>postgres</p></td><td id="-teoqar_897"><p>devtesttablespace</p></td><td id="-teoqar_898"><p>idle</p></td><td id="-teoqar_899"><p>1</p></td><td id="-teoqar_900"><p>1</p></td><td id="-teoqar_901"><p>1</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat-estimated" data-toc="table-bloat-estimated">Table bloat (estimated)</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (estimated)" data-disable-link-processing="true">--Table bloat (estimated)

--This SQL is derived from https://github.com/ioguix/pgsql-bloat-estimation/blob/master/table/table_bloat.sql

/*
* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.
* This query is compatible with PostgreSQL 9.0 and more
*/

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (
    select
        tbl.oid tblid,
        ns.nspname as schema_name,
        tbl.relname as table_name,
        tbl.reltuples,
        tbl.relpages as heappages,
        coalesce(toast.relpages, 0) as toastpages,
        coalesce(toast.reltuples, 0) as toasttuples,
        coalesce(substring(array_to_string(tbl.reloptions, ' ') from '%fillfactor=#&quot;__#&quot;%' for '#')::int2, 100) as fillfactor,
        current_setting('block_size')::numeric as bs,
        case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as ma, -- NS: TODO: check it
        24 as page_hdr,
        23 + case when max(coalesce(null_frac, 0)) &gt; 0 then (7 + count(*)) / 8 else 0::int end
            + case when bool_or(att.attname = 'oid' and att.attnum &lt; 0) then 4 else 0 end as tpl_hdr_size,
        sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) as tpl_data_size,
        bool_or(att.atttypid = 'pg_catalog.name'::regtype)
            or sum(case when att.attnum &gt; 0 then 1 else 0 end) &lt;&gt; count(s.attname) as is_na
    from pg_attribute as att
             join pg_class as tbl on att.attrelid = tbl.oid and tbl.relkind = 'r'
             join pg_namespace as ns on ns.oid = tbl.relnamespace
             join pg_stats as s on s.schemaname = ns.nspname and s.tablename = tbl.relname and not s.inherited and s.attname = att.attname
             left join pg_class as toast on tbl.reltoastrelid = toast.oid
    where not att.attisdropped and s.schemaname not in ('pg_catalog', 'information_schema')
    group by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    order by 2, 3
), step2 as (
    select
        *,
        (
            4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                - case when tpl_hdr_size % ma = 0 then ma else tpl_hdr_size % ma end
                - case when ceil(tpl_data_size)::int % ma = 0 then ma else ceil(tpl_data_size)::int % ma end
            ) as tpl_size,
        bs - page_hdr as size_per_block,
        (heappages + toastpages) as tblpages
    from step1
), step3 as (
    select
        *,
        ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) as est_tblpages,
        ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) + ceil(toasttuples / 4) as est_tblpages_ff
    -- , stattuple.pgstattuple(tblid) as pst
    from step2
), step4 as (
    select
        *,
        tblpages * bs as real_size,
        (tblpages - est_tblpages) * bs as extra_size,
        case when tblpages - est_tblpages &gt; 0 then 100 * (tblpages - est_tblpages) / tblpages::float else 0 end as extra_ratio,
        (tblpages - est_tblpages_ff) * bs as bloat_size,
        case when tblpages - est_tblpages_ff &gt; 0 then 100 * (tblpages - est_tblpages_ff) / tblpages::float else 0 end as bloat_ratio
    -- , (pst).free_percent + (pst).dead_tuple_percent as real_frag
    from step3
             left join pg_stat_user_tables su on su.relid = tblid
    -- WHERE NOT is_na
    --   AND tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 &gt;= 1
)
select
    case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name as &quot;Table&quot;,
    pg_size_pretty(real_size::numeric) as &quot;Size&quot;,
    case
        when extra_size::numeric &gt;= 0
            then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text || '%)'
        else null
        end  as &quot;Extra&quot;,
    case
        when bloat_size::numeric &gt;= 0
            then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text || '%)'
        else null
        end as &quot;Bloat estimate&quot;,
    case
        when (real_size - bloat_size)::numeric &gt;=0
            then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
        else null
        end as &quot;Live&quot;,
    greatest(last_autovacuum, last_vacuum)::timestamp(0)::text
        || case greatest(last_autovacuum, last_vacuum)
               when last_autovacuum then ' (auto)'
               else '' end as &quot;Last Vaccuum&quot;,
    (
        select
            coalesce(substring(array_to_string(reloptions, ' ') from 'fillfactor=([0-9]+)')::smallint, 100)
        from pg_class
        where oid = tblid
    ) as &quot;Fillfactor&quot;
from step4
order by bloat_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_903" data-toc="-teoqar_903">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_904"><thead><tr class="ijRowHead" id="-teoqar_905"><th id="-teoqar_906"><p>Is N/A</p></th><th id="-teoqar_907"><p>Table</p></th><th id="-teoqar_908"><p>Size</p></th><th id="-teoqar_909"><p>Extra</p></th><th id="-teoqar_910"><p>Bloat estimate</p></th><th id="-teoqar_911"><p>Live</p></th><th id="-teoqar_912"><p>Last Vaccuum</p></th><th id="-teoqar_913"><p>Fillfactor</p></th></tr></thead><tbody><tr id="-teoqar_914"><td id="-teoqar_915"></td><td id="-teoqar_916"><p>testtbldata</p></td><td id="-teoqar_917"><p>383 MB</p></td><td id="-teoqar_918"><p>~14 MB (3.75%)</p></td><td id="-teoqar_919"><p>~14 MB (3.75%)</p></td><td id="-teoqar_920"><p>~369 MB</p></td><td id="-teoqar_921"><p>2024-03-25 03:54:41</p></td><td id="-teoqar_922"><p>100</p></td></tr><tr id="-teoqar_923"><td id="-teoqar_924"></td><td id="-teoqar_925"><p>t_agg</p></td><td id="-teoqar_926"><p>498 MB</p></td><td id="-teoqar_927"><p>~256 kB (0.05%)</p></td><td id="-teoqar_928"><p>~256 kB (0.05%)</p></td><td id="-teoqar_929"><p>~497 MB</p></td><td id="-teoqar_930"><p>2024-03-23 02:59:13</p></td><td id="-teoqar_931"><p>100</p></td></tr><tr id="-teoqar_932"><td id="-teoqar_933"></td><td id="-teoqar_934"><p>states</p></td><td id="-teoqar_935"><p>8192 bytes</p></td><td id="-teoqar_936"><p>~0 bytes (0.00%)</p></td><td id="-teoqar_937"><p>~0 bytes (0.00%)</p></td><td id="-teoqar_938"><p>~8192 bytes</p></td><td id="-teoqar_939"><p>2024-03-23 02:59:13</p></td><td id="-teoqar_940"><p>100</p></td></tr><tr id="-teoqar_941"><td id="-teoqar_942"></td><td id="-teoqar_943"><p>teststat</p></td><td id="-teoqar_944"><p>1344 MB</p></td><td id="-teoqar_945"><p>null</p></td><td id="-teoqar_946"><p>null</p></td><td id="-teoqar_947"><p>~1401 MB</p></td><td id="-teoqar_948"><p>2024-03-23 02:59:07</p></td><td id="-teoqar_949"><p>100</p></td></tr><tr id="-teoqar_950"><td id="-teoqar_951"></td><td id="-teoqar_952"><p>testidx</p></td><td id="-teoqar_953"><p>1344 MB</p></td><td id="-teoqar_954"><p>null</p></td><td id="-teoqar_955"><p>null</p></td><td id="-teoqar_956"><p>~1402 MB</p></td><td id="-teoqar_957"><p>2024-03-23 02:58:46</p></td><td id="-teoqar_958"><p>100</p></td></tr><tr id="-teoqar_959"><td id="-teoqar_960"></td><td id="-teoqar_961"><p>testnoidx</p></td><td id="-teoqar_962"><p>1344 MB</p></td><td id="-teoqar_963"><p>null</p></td><td id="-teoqar_964"><p>null</p></td><td id="-teoqar_965"><p>~1403 MB</p></td><td id="-teoqar_966"><p>2024-03-23 02:58:56</p></td><td id="-teoqar_967"><p>100</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-index-bloat" data-toc="b-tree-index-bloat">B-tree index bloat</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree index bloat (estimated)" data-disable-link-processing="true">--B-tree index bloat (estimated)

-- enhanced version of https://github.com/ioguix/pgsql-bloat-estimation/blob/master/btree/btree_bloat.sql

-- WARNING: executed with a non-superuser role, the query inspect only index on tables you are granted to read.
-- WARNING: rows with is_na = 't' are known to have bad statistics (&quot;name&quot; type is not supported).
-- This query is compatible with PostgreSQL 8.2+

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (select i.nspname                                                                        as schema_name,
                      i.tblname                                                                        as table_name,
                      i.idxname                                                                        as index_name,
                      i.reltuples,
                      i.relpages,
                      i.relam,
                      a.attrelid                                                                       AS table_oid,
                      current_setting('block_size')::numeric                                           AS bs,
                      fillfactor,
                      -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                      case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as maxalign,
                   /* per page header, fixed size: 20 for 7.X, 24 for others */
                      24                                                                               AS pagehdr,
                   /* per page btree opaque data */
                      16                                                                               AS pageopqdata,
                   /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                      case
                          when max(coalesce(s.null_frac, 0)) = 0 then 2 -- IndexTupleData size
                          else 2 + ((32 + 8 - 1) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                          end                                                                          as index_tuple_hdr_bm,
                   /* data len: we remove null values save space using it fractionnal part from stats */
                      sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024))                as nulldatawidth,
                      max(case when a.atttypid = 'pg_catalog.name'::regtype then 1 else 0 end) &gt; 0     as is_na
               from pg_attribute as a
                        join (select nspname,
                                     tbl.relname                                              AS tblname,
                                     idx.relname                                              AS idxname,
                                     idx.reltuples,
                                     idx.relpages,
                                     idx.relam,
                                     indrelid,
                                     indexrelid,
                                     indkey::smallint[]                                       AS attnum,
                                     coalesce(substring(array_to_string(idx.reloptions, ' ') from
                                                        'fillfactor=([0-9]+)')::smallint, 90) as fillfactor
                              from pg_index
                                       join pg_class idx on idx.oid = pg_index.indexrelid
                                       join pg_class tbl on tbl.oid = pg_index.indrelid
                                       join pg_namespace on pg_namespace.oid = idx.relnamespace
                              where pg_index.indisvalid
                                AND tbl.relkind = 'r'
                                AND idx.relpages &gt; 0) as i on a.attrelid = i.indexrelid
                        join pg_stats as s on
                   s.schemaname = i.nspname
                       and (
                       (s.tablename = i.tblname and
                        s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, true)) -- stats from tbl
                           OR (s.tablename = i.idxname AND s.attname = a.attname) -- stats from functionnal cols
                       )
                        join pg_type as t on a.atttypid = t.oid
               where a.attnum &gt; 0
               group by 1, 2, 3, 4, 5, 6, 7, 8, 9),
     step2 as (select *,
                      (
                          index_tuple_hdr_bm + maxalign
                              -- Add padding to the index tuple header to align on MAXALIGN
                              - case
                                    when index_tuple_hdr_bm % maxalign = 0 THEN maxalign
                                    else index_tuple_hdr_bm % maxalign end
                              + nulldatawidth + maxalign
                              -- Add padding to the data to align on MAXALIGN
                              - case
                                    when nulldatawidth = 0 then 0
                                    when nulldatawidth::integer % maxalign = 0 then maxalign
                                    else nulldatawidth::integer % maxalign
                              end
                          )::numeric as nulldatahdrwidth
               -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
               from step1),
     step3 as (select *,
                      -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
                      coalesce(
                              1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::float)),
                              0)                                                                      as est_pages,
                      coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) * fillfactor /
                                                          (100 * (4 + nulldatahdrwidth)::float))), 0) as est_pages_ff
               -- , stattuple.pgstatindex(quote_ident(nspname)||'.'||quote_ident(idxname)) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
               from step2
                        join pg_am am on step2.relam = am.oid
               where am.amname = 'btree'),
     step4 as (SELECT *,
                      bs * (relpages)::bigint                           AS real_size,
-------current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,
                      bs * (relpages - est_pages)::bigint               AS extra_size,
                      100 * (relpages - est_pages)::float / relpages    AS extra_ratio,
                      bs * (relpages - est_pages_ff)                    AS bloat_size,
                      100 * (relpages - est_pages_ff)::float / relpages AS bloat_ratio
               -- , 100-(sub.pst).avg_leaf_density, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, sub.reltuples, sub.relpages -- (DEBUG INFO)
               from step3
         -- WHERE NOT is_na
     )
select case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
       format(
               $out$%s
  (%s)$out$,
               left(index_name, 50) || case when length(index_name) &gt; 50 then '…' else '' end,
               coalesce(nullif(schema_name, 'public') || '.', '') || table_name
       )                                            as &quot;Index (Table)&quot;,
       pg_size_pretty(real_size::numeric)           as &quot;Size&quot;,
       case
           when extra_size::numeric &gt;= 0
               then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Extra&quot;,
       case
           when bloat_size::numeric &gt;= 0
               then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Bloat&quot;,
       case
           when (real_size - bloat_size)::numeric &gt;= 0
               then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
           else null
           end                                      as &quot;Live&quot;,
       fillfactor
from step4
order by real_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_969" data-toc="-teoqar_969">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_970"><thead><tr class="ijRowHead" id="-teoqar_971"><th id="-teoqar_972"><p>Is N/A</p></th><th id="-teoqar_973"><p>Index (Table)</p></th><th id="-teoqar_974"><p>Size</p></th><th id="-teoqar_975"><p>Extra</p></th><th id="-teoqar_976"><p>Bloat</p></th><th id="-teoqar_977"><p>Live</p></th><th id="-teoqar_978"><p>fillfactor</p></th></tr></thead><tbody><tr id="-teoqar_979"><td id="-teoqar_980"></td><td id="-teoqar_981"><p>teststat_pkey</p><br><p> (teststat)</p></td><td id="-teoqar_983"><p>249 MB</p></td><td id="-teoqar_984"><p>~26 MB (10.39%)</p></td><td id="-teoqar_985"><p>~904 kB (0.35%)</p></td><td id="-teoqar_986"><p>~248 MB</p></td><td id="-teoqar_987"><p>90</p></td></tr><tr id="-teoqar_988"><td id="-teoqar_989"></td><td id="-teoqar_990"><p>testidx_copy1_pkey</p><br><p> (testnoidx)</p></td><td id="-teoqar_992"><p>249 MB</p></td><td id="-teoqar_993"><p>~26 MB (10.29%)</p></td><td id="-teoqar_994"><p>~624 kB (0.24%)</p></td><td id="-teoqar_995"><p>~249 MB</p></td><td id="-teoqar_996"><p>90</p></td></tr><tr id="-teoqar_997"><td id="-teoqar_998"></td><td id="-teoqar_999"><p>testidx_pk</p><br><p> (testidx)</p></td><td id="-teoqar_1001"><p>225 MB</p></td><td id="-teoqar_1002"><p>~1328 kB (0.58%)</p></td><td id="-teoqar_1003"><p>~1328 kB (0.58%)</p></td><td id="-teoqar_1004"><p>~223 MB</p></td><td id="-teoqar_1005"><p>100</p></td></tr><tr id="-teoqar_1006"><td id="-teoqar_1007"></td><td id="-teoqar_1008"><p>testidx_created_at_index</p><br><p> (testidx)</p></td><td id="-teoqar_1010"><p>165 MB</p></td><td id="-teoqar_1011"><p>~15 MB (9.10%)</p></td><td id="-teoqar_1012"><p>null</p></td><td id="-teoqar_1013"><p>~167 MB</p></td><td id="-teoqar_1014"><p>90</p></td></tr><tr id="-teoqar_1015"><td id="-teoqar_1016"></td><td id="-teoqar_1017"><p>testidx_fk_id_index</p><br><p> (testidx)</p></td><td id="-teoqar_1019"><p>114 MB</p></td><td id="-teoqar_1020"><p>null</p></td><td id="-teoqar_1021"><p>null</p></td><td id="-teoqar_1022"><p>~247 MB</p></td><td id="-teoqar_1023"><p>90</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat" data-toc="table-bloat">Table bloat</h2><p id="-teoqar_1024">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-teoqar_1025" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--Table bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without table name/mask query will read all available tables which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

select nspname,
       relname,
       pg_size_pretty(relation_size + toast_relation_size) as                                    total_size,
       pg_size_pretty(toast_relation_size)                 as                                    toast_size,
       round(((relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size, 1))::numeric, 1)                                           table_waste_percent,
       pg_size_pretty((relation_size - (relation_size - free_space) * 100 / fillfactor)::bigint) table_waste,
       round(((toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size + toast_relation_size, 1))::numeric, 1)                     total_waste_percent,
       pg_size_pretty((toast_free_space + relation_size -
                       (relation_size - free_space) * 100 / fillfactor)::bigint)                 total_waste
from (select nspname,
             relname,
             (select free_space from pgstattuple(c.oid))                                                         as free_space,
             pg_relation_size(c.oid)                                                                             as relation_size,
             (case
                  when reltoastrelid = 0 then 0
                  else (select free_space from pgstattuple(c.reltoastrelid)) end)                                as toast_free_space,
             coalesce(pg_relation_size(c.reltoastrelid), 0)                                                      as toast_relation_size,
             coalesce((SELECT (regexp_matches(reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),
                      '100')::real                                                                               AS fillfactor
      from pg_class c
               left join pg_namespace n on (n.oid = c.relnamespace)
      where nspname not in ('pg_catalog', 'information_schema')
        and nspname !~ '^pg_toast'
        and relkind = 'r'
        --put your table name/mask here
        and relname ~ '') t
order by (toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) desc
limit 20;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1028" data-toc="-teoqar_1028">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_1029"><thead><tr class="ijRowHead" id="-teoqar_1030"><th id="-teoqar_1031"><p>nspname</p></th><th id="-teoqar_1032"><p>relname</p></th><th id="-teoqar_1033"><p>total_size</p></th><th id="-teoqar_1034"><p>toast_size</p></th><th id="-teoqar_1035"><p>table_waste_percent</p></th><th id="-teoqar_1036"><p>table_waste</p></th><th id="-teoqar_1037"><p>total_waste_percent</p></th><th id="-teoqar_1038"><p>total_waste</p></th></tr></thead><tbody><tr id="-teoqar_1039"><td id="-teoqar_1040"><p>public</p></td><td id="-teoqar_1041"><p>teststat</p></td><td id="-teoqar_1042"><p>1344 MB</p></td><td id="-teoqar_1043"><p>314 MB</p></td><td id="-teoqar_1044"><p>0.5</p></td><td id="-teoqar_1045"><p>4829 kB</p></td><td id="-teoqar_1046"><p>2.3</p></td><td id="-teoqar_1047"><p>31 MB</p></td></tr><tr id="-teoqar_1048"><td id="-teoqar_1049"><p>public</p></td><td id="-teoqar_1050"><p>testnoidx</p></td><td id="-teoqar_1051"><p>1344 MB</p></td><td id="-teoqar_1052"><p>314 MB</p></td><td id="-teoqar_1053"><p>0.5</p></td><td id="-teoqar_1054"><p>4829 kB</p></td><td id="-teoqar_1055"><p>2.3</p></td><td id="-teoqar_1056"><p>30 MB</p></td></tr><tr id="-teoqar_1057"><td id="-teoqar_1058"><p>public</p></td><td id="-teoqar_1059"><p>testidx</p></td><td id="-teoqar_1060"><p>1344 MB</p></td><td id="-teoqar_1061"><p>314 MB</p></td><td id="-teoqar_1062"><p>0.5</p></td><td id="-teoqar_1063"><p>4829 kB</p></td><td id="-teoqar_1064"><p>2.3</p></td><td id="-teoqar_1065"><p>30 MB</p></td></tr><tr id="-teoqar_1066"><td id="-teoqar_1067"><p>public</p></td><td id="-teoqar_1068"><p>testtbldata</p></td><td id="-teoqar_1069"><p>383 MB</p></td><td id="-teoqar_1070"><p>0 bytes</p></td><td id="-teoqar_1071"><p>0.4</p></td><td id="-teoqar_1072"><p>1746 kB</p></td><td id="-teoqar_1073"><p>0.4</p></td><td id="-teoqar_1074"><p>1746 kB</p></td></tr><tr id="-teoqar_1075"><td id="-teoqar_1076"><p>public</p></td><td id="-teoqar_1077"><p>states</p></td><td id="-teoqar_1078"><p>8192 bytes</p></td><td id="-teoqar_1079"><p>0 bytes</p></td><td id="-teoqar_1080"><p>97.7</p></td><td id="-teoqar_1081"><p>8000 bytes</p></td><td id="-teoqar_1082"><p>97.7</p></td><td id="-teoqar_1083"><p>8000 bytes</p></td></tr><tr id="-teoqar_1084"><td id="-teoqar_1085"><p>public</p></td><td id="-teoqar_1086"><p>t_agg</p></td><td id="-teoqar_1087"><p>498 MB</p></td><td id="-teoqar_1088"><p>0 bytes</p></td><td id="-teoqar_1089"><p>0</p></td><td id="-teoqar_1090"><p>5996 bytes</p></td><td id="-teoqar_1091"><p>0</p></td><td id="-teoqar_1092"><p>5996 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-indexes-bloat" data-toc="b-tree-indexes-bloat">B-tree indexes bloat</h2><p id="-teoqar_1093">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-teoqar_1094" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree indexes bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--B-tree indexes bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without index name/mask query will read all available indexes which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with data as (
    select
        schemaname as schema_name,
        p.relname as table_name,
        (select spcname from pg_tablespace where oid = c_table.reltablespace) as table_tblspace,
        (select spcname from pg_tablespace where oid = c.reltablespace) as index_tblspace,
        indexrelname as index_name,
        (
            select (case when avg_leaf_density = 'NaN' then 0
                         else greatest(ceil(index_size * (1 - avg_leaf_density / (coalesce((SELECT (regexp_matches(c.reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),'90')::real)))::bigint, 0) end)
            from pgstatindex(
                    case when p.indexrelid::regclass::text ~ '\.' then p.indexrelid::regclass::text else schemaname || '.' || p.indexrelid::regclass::text end
                 )
        ) as free_space,
        pg_relation_size(p.indexrelid) as index_size,
        pg_relation_size(p.relid) as table_size,
        idx_scan
    from pg_stat_user_indexes p
             join pg_class c on p.indexrelid = c.oid
             join pg_class c_table on p.relid = c_table.oid
    where
        pg_get_indexdef(p.indexrelid) like '%USING btree%'
      --put your index name/mask here
      and indexrelname ~ ''
)
select
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name || coalesce(' [' || table_tblspace || ']', '') as &quot;Table&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || index_name || coalesce(' [' || index_tblspace || ']', '') as &quot;Index&quot;,
    pg_size_pretty(table_size) as &quot;Table size&quot;,
    pg_size_pretty(index_size) as &quot;Index size&quot;,
    idx_scan as &quot;Index Scans&quot;,
    round((free_space*100/index_size)::numeric, 1) as &quot;Wasted, %&quot;,
    pg_size_pretty(free_space) as &quot;Wasted&quot;
from data
order by free_space desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1097" data-toc="-teoqar_1097">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_1098"><thead><tr class="ijRowHead" id="-teoqar_1099"><th id="-teoqar_1100"><p>Table</p></th><th id="-teoqar_1101"><p>Index</p></th><th id="-teoqar_1102"><p>Table size</p></th><th id="-teoqar_1103"><p>Index size</p></th><th id="-teoqar_1104"><p>Index Scans</p></th><th id="-teoqar_1105"><p>Wasted, %</p></th><th id="-teoqar_1106"><p>Wasted</p></th></tr></thead><tbody><tr id="-teoqar_1107"><td id="-teoqar_1108"><p>testidx</p></td><td id="-teoqar_1109"><p>testidx_pk</p></td><td id="-teoqar_1110"><p>1030 MB</p></td><td id="-teoqar_1111"><p>225 MB</p></td><td id="-teoqar_1112"><p>17240064</p></td><td id="-teoqar_1113"><p>0</p></td><td id="-teoqar_1114"><p>230 kB</p></td></tr><tr id="-teoqar_1115"><td id="-teoqar_1116"><p>states</p></td><td id="-teoqar_1117"><p>states_pkey</p></td><td id="-teoqar_1118"><p>8192 bytes</p></td><td id="-teoqar_1119"><p>16 kB</p></td><td id="-teoqar_1120"><p>3</p></td><td id="-teoqar_1121"><p>99</p></td><td id="-teoqar_1122"><p>16 kB</p></td></tr><tr id="-teoqar_1123"><td id="-teoqar_1124"><p>testnoidx</p></td><td id="-teoqar_1125"><p>testidx_copy1_pkey</p></td><td id="-teoqar_1126"><p>1030 MB</p></td><td id="-teoqar_1127"><p>249 MB</p></td><td id="-teoqar_1128"><p>2</p></td><td id="-teoqar_1129"><p>0</p></td><td id="-teoqar_1130"><p>0 bytes</p></td></tr><tr id="-teoqar_1131"><td id="-teoqar_1132"><p>teststat</p></td><td id="-teoqar_1133"><p>teststat_pkey</p></td><td id="-teoqar_1134"><p>1030 MB</p></td><td id="-teoqar_1135"><p>249 MB</p></td><td id="-teoqar_1136"><p>8620000</p></td><td id="-teoqar_1137"><p>0</p></td><td id="-teoqar_1138"><p>0 bytes</p></td></tr><tr id="-teoqar_1139"><td id="-teoqar_1140"><p>testidx</p></td><td id="-teoqar_1141"><p>testidx_fk_id_index</p></td><td id="-teoqar_1142"><p>1030 MB</p></td><td id="-teoqar_1143"><p>114 MB</p></td><td id="-teoqar_1144"><p>549</p></td><td id="-teoqar_1145"><p>0</p></td><td id="-teoqar_1146"><p>0 bytes</p></td></tr><tr id="-teoqar_1147"><td id="-teoqar_1148"><p>testidx</p></td><td id="-teoqar_1149"><p>testidx_created_at_index</p></td><td id="-teoqar_1150"><p>1030 MB</p></td><td id="-teoqar_1151"><p>165 MB</p></td><td id="-teoqar_1152"><p>41</p></td><td id="-teoqar_1153"><p>0</p></td><td id="-teoqar_1154"><p>0 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="tables-and-columns-without-stats" data-toc="tables-and-columns-without-stats">Tables and columns without stats</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables and columns without stats" data-disable-link-processing="true">--Tables and columns without stats
--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/bloat/no_stats_table_check.sql

SELECT table_schema, table_name,
       ( pg_class.relpages = 0 ) AS is_empty,
       ( psut.relname IS NULL OR ( psut.last_analyze IS NULL and psut.last_autoanalyze IS NULL ) ) AS never_analyzed,
       array_agg(column_name::TEXT) as no_stats_columns
FROM information_schema.columns
         JOIN pg_class ON columns.table_name = pg_class.relname
    AND pg_class.relkind = 'r'
         JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
    AND nspname = table_schema
         LEFT OUTER JOIN pg_stats
                         ON table_schema = pg_stats.schemaname
                             AND table_name = pg_stats.tablename
                             AND column_name = pg_stats.attname
         LEFT OUTER JOIN pg_stat_user_tables AS psut
                         ON table_schema = psut.schemaname
                             AND table_name = psut.relname
WHERE pg_stats.attname IS NULL
  AND table_schema NOT IN ('pg_catalog', 'information_schema')
GROUP BY table_schema, table_name, relpages, psut.relname, last_analyze, last_autoanalyze;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1156" data-toc="-teoqar_1156">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_1157"><thead><tr class="ijRowHead" id="-teoqar_1158"><th id="-teoqar_1159"><p>table_schema</p></th><th id="-teoqar_1160"><p>table_name</p></th><th id="-teoqar_1161"><p>is_empty</p></th><th id="-teoqar_1162"><p>never_analyzed</p></th><th id="-teoqar_1163"><p>no_stats_columns</p></th></tr></thead><tbody><tr id="-teoqar_1164"><td id="-teoqar_1165"><p>public</p></td><td id="-teoqar_1166"><p>category</p></td><td id="-teoqar_1167"><p>false</p></td><td id="-teoqar_1168"><p>true</p></td><td id="-teoqar_1169"><p>{name,category_id,last_update}</p></td></tr><tr id="-teoqar_1170"><td id="-teoqar_1171"><p>public</p></td><td id="-teoqar_1172"><p>language</p></td><td id="-teoqar_1173"><p>false</p></td><td id="-teoqar_1174"><p>true</p></td><td id="-teoqar_1175"><p>{last_update,name,language_id}</p></td></tr><tr id="-teoqar_1176"><td id="-teoqar_1177"><p>public</p></td><td id="-teoqar_1178"><p>staff</p></td><td id="-teoqar_1179"><p>false</p></td><td id="-teoqar_1180"><p>true</p></td><td id="-teoqar_1181"><p>{password,username,staff_id,first_name,email,last_name,picture,last_update,active,store_id,address_id}</p></td></tr><tr id="-teoqar_1182"><td id="-teoqar_1183"><p>public</p></td><td id="-teoqar_1184"><p>store</p></td><td id="-teoqar_1185"><p>false</p></td><td id="-teoqar_1186"><p>true</p></td><td id="-teoqar_1187"><p>{last_update,manager_staff_id,address_id,store_id}</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-teoqar_1188" data-toc="-teoqar_1188">Неиспользуемые и редко используемые индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Unused and rarely used indexes" data-disable-link-processing="true">--Unused and rarely used indexes

--PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/unused_indexes.sql

WITH table_scans as (
    SELECT relid,
           tables.idx_scan + tables.seq_scan as all_scans,
           ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
           pg_relation_size(relid) as table_size
    FROM pg_stat_user_tables as tables
),
     all_writes as (
         SELECT sum(writes) as total_writes
         FROM table_scans
     ),
     indexes as (
         SELECT idx_stat.relid, idx_stat.indexrelid,
                idx_stat.schemaname, idx_stat.relname as tablename,
                idx_stat.indexrelname as indexname,
                idx_stat.idx_scan,
                pg_relation_size(idx_stat.indexrelid) as index_bytes,
                indexdef ~* 'USING btree' AS idx_is_btree
         FROM pg_stat_user_indexes as idx_stat
                  JOIN pg_index
                       USING (indexrelid)
                  JOIN pg_indexes as indexes
                       ON idx_stat.schemaname = indexes.schemaname
                           AND idx_stat.relname = indexes.tablename
                           AND idx_stat.indexrelname = indexes.indexname
         WHERE pg_index.indisunique = FALSE
     ),
     index_ratios AS (
         SELECT schemaname, tablename, indexname,
                idx_scan, all_scans,
                round(( CASE WHEN all_scans = 0 THEN 0.0::NUMERIC
                             ELSE idx_scan::NUMERIC/all_scans * 100 END),2) as index_scan_pct,
                writes,
                round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2)
                                                                            as scans_per_write,
                pg_size_pretty(index_bytes) as index_size,
                pg_size_pretty(table_size) as table_size,
                idx_is_btree, index_bytes
         FROM indexes
                  JOIN table_scans
                       USING (relid)
     ),
     index_groups AS (
         SELECT 'Never Used Indexes' as reason, *, 1 as grp
         FROM index_ratios
         WHERE
             idx_scan = 0
           and idx_is_btree
         UNION ALL
         SELECT 'Low Scans, High Writes' as reason, *, 2 as grp
         FROM index_ratios
         WHERE
             scans_per_write &lt;= 1
           and index_scan_pct &lt; 10
           and idx_scan &gt; 0
           and writes &gt; 100
           and idx_is_btree
         UNION ALL
         SELECT 'Seldom Used Large Indexes' as reason, *, 3 as grp
         FROM index_ratios
         WHERE
             index_scan_pct &lt; 5
           and scans_per_write &gt; 1
           and idx_scan &gt; 0
           and idx_is_btree
           and index_bytes &gt; 100000000
         UNION ALL
         SELECT 'High-Write Large Non-Btree' as reason, index_ratios.*, 4 as grp
         FROM index_ratios, all_writes
         WHERE
             ( writes::NUMERIC / ( total_writes + 1 ) ) &gt; 0.02
           AND NOT idx_is_btree
           AND index_bytes &gt; 100000000
         ORDER BY grp, index_bytes DESC )
SELECT
    reason,
    schemaname as schema_name,
    tablename as table_name,
    indexname as index_name,
    index_scan_pct,
    scans_per_write,
    index_size,
    table_size,
    idx_scan,
    all_scans
FROM index_groups;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1190" data-toc="-teoqar_1190">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_1191"><thead><tr class="ijRowHead" id="-teoqar_1192"><th id="-teoqar_1193"><p>reason</p></th><th id="-teoqar_1194"><p>schema_name</p></th><th id="-teoqar_1195"><p>table_name</p></th><th id="-teoqar_1196"><p>index_name</p></th><th id="-teoqar_1197"><p>index_scan_pct</p></th><th id="-teoqar_1198"><p>scans_per_write</p></th><th id="-teoqar_1199"><p>index_size</p></th><th id="-teoqar_1200"><p>table_size</p></th><th id="-teoqar_1201"><p>idx_scan</p></th><th id="-teoqar_1202"><p>all_scans</p></th></tr></thead><tbody><tr id="-teoqar_1203"><td id="-teoqar_1204"><p>Low Scans, High Writes</p></td><td id="-teoqar_1205"><p>public</p></td><td id="-teoqar_1206"><p>testidx</p></td><td id="-teoqar_1207"><p>testidx_created_at_index</p></td><td id="-teoqar_1208"><p>0</p></td><td id="-teoqar_1209"><p>0</p></td><td id="-teoqar_1210"><p>165 MB</p></td><td id="-teoqar_1211"><p>1030 MB</p></td><td id="-teoqar_1212"><p>41</p></td><td id="-teoqar_1213"><p>17240843</p></td></tr><tr id="-teoqar_1214"><td id="-teoqar_1215"><p>Low Scans, High Writes</p></td><td id="-teoqar_1216"><p>public</p></td><td id="-teoqar_1217"><p>testidx</p></td><td id="-teoqar_1218"><p>testidx_fk_id_index</p></td><td id="-teoqar_1219"><p>0</p></td><td id="-teoqar_1220"><p>0</p></td><td id="-teoqar_1221"><p>114 MB</p></td><td id="-teoqar_1222"><p>1030 MB</p></td><td id="-teoqar_1223"><p>549</p></td><td id="-teoqar_1224"><p>17240843</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-teoqar_1225" data-toc="-teoqar_1225">Избыточные индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Redundant indexes" data-disable-link-processing="true">--Redundant indexes

-- Use it to see redundant indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

with fk_indexes as (
    select
        n.nspname as schema_name,
        ci.relname as index_name,
        cr.relname as table_name,
        (confrelid::regclass)::text as fk_table_ref,
        array_to_string(indclass, ', ') as opclasses
    from pg_index i
             join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
             join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
             join pg_namespace n on n.oid = ci.relnamespace
             join pg_constraint cn on cn.conrelid = cr.oid
             left join pg_stat_user_indexes si on si.indexrelid = i.indexrelid
    where
        contype = 'f'
      and i.indisunique is false
      and conkey is not null
      and ci.relpages &gt; 0 -- raise for a DB with a lot of indexes
      and si.idx_scan &lt; 10
),
-- Redundant indexes
     index_data as (
         select
             *,
             (select string_agg(lpad(i, 3, '0'), ' ') from unnest(string_to_array(indkey::text, ' ')) i) as columns,
             array_to_string(indclass, ', ') as opclasses
         from pg_index i
                  join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
         where indisvalid = true and ci.relpages &gt; 0 -- raise for a DD with a lot of indexes
     ), redundant_indexes as (
    select
        i2.indexrelid as index_id,
        tnsp.nspname AS schema_name,
        trel.relname AS table_name,
        pg_relation_size(trel.oid) as table_size_bytes,
        irel.relname AS index_name,
        am1.amname as access_method,
        (i1.indexrelid::regclass)::text as reason,
        i1.indexrelid as reason_index_id,
        pg_get_indexdef(i1.indexrelid) main_index_def,
        pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size,
        pg_get_indexdef(i2.indexrelid) index_def,
        pg_relation_size(i2.indexrelid) index_size_bytes,
        s.idx_scan as index_usage,
        quote_ident(tnsp.nspname) as formated_schema_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) as formated_index_name,
        quote_ident(trel.relname) AS formated_table_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) as formated_relation_name,
        i2.opclasses
    from
        index_data as i1
            join index_data as i2 on (
            i1.indrelid = i2.indrelid -- same table
                and i1.indexrelid &lt;&gt; i2.indexrelid -- NOT same index
            )
            inner join pg_opclass op1 on i1.indclass[0] = op1.oid
            inner join pg_opclass op2 on i2.indclass[0] = op2.oid
            inner join pg_am am1 on op1.opcmethod = am1.oid
            inner join pg_am am2 on op2.opcmethod = am2.oid
            join pg_stat_user_indexes as s on s.indexrelid = i2.indexrelid
            join pg_class as trel on trel.oid = i2.indrelid
            join pg_namespace as tnsp on trel.relnamespace = tnsp.oid
            join pg_class as irel on irel.oid = i2.indexrelid
    where
        not i2.indisprimary -- index 1 is not primary
      and not ( -- skip if index1 is (primary or uniq) and is NOT (primary and uniq)
        i2.indisunique and not i1.indisprimary
        )
      and am1.amname = am2.amname -- same access type
      and i1.columns like (i2.columns || '%') -- index 2 includes all columns from index 1
      and i1.opclasses like (i2.opclasses || '%')
      -- index expressions is same
      and pg_get_expr(i1.indexprs, i1.indrelid) is not distinct from pg_get_expr(i2.indexprs, i2.indrelid)
      -- index predicates is same
      and pg_get_expr(i1.indpred, i1.indrelid) is not distinct from pg_get_expr(i2.indpred, i2.indrelid)
), redundant_indexes_fk as (
    select
        ri.*,
        (
            select count(1)
            from fk_indexes fi
            where
                fi.fk_table_ref = ri.table_name
              and fi.opclasses like (ri.opclasses || '%')
        ) &gt; 0 as supports_fk
    from redundant_indexes ri
),
-- Cut recursive links
     redundant_indexes_tmp_num as (
         select
                     row_number() over () num,
                     rig.*
         from redundant_indexes_fk rig
         order by index_id
     ), redundant_indexes_tmp_cut as (
    select
        ri1.*,
        ri2.num as r_num
    from redundant_indexes_tmp_num ri1
             left join redundant_indexes_tmp_num ri2 on ri2.reason_index_id = ri1.index_id and ri1.reason_index_id = ri2.index_id
    where ri1.num &lt; ri2.num or ri2.num is null
), redundant_indexes_cut_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
), redundant_indexes_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
)
select
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    string_agg(distinct reason, ', ') as redundant_to,
    string_agg(main_index_def, ', ') as main_index_def,
    string_agg(main_index_size, ', ') as main_index_size,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
from redundant_indexes_cut_grouped
group by
    index_id,
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
order by index_size_bytes desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1227" data-toc="-teoqar_1227">Результат</h3></div><div class="collapse__content"><p id="-teoqar_1228">TODO: добавить пример!</p></div></div></section></section><section class="chapter"><h2 id="fk" data-toc="fk">FK и отсутствующие индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--FKs with Missing/Bad Indexes" data-disable-link-processing="true">--FKs with Missing/Bad Indexes

--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/fk_no_index.sql

-- check for FKs where there is no matching index
-- on the referencing side
-- or a bad index

with fk_actions ( code, action ) as (
    values ('a', 'error'),
           ('r', 'restrict'),
           ('c', 'cascade'),
           ('n', 'set null'),
           ('d', 'set default')
), fk_list as (
    select
        pg_constraint.oid as fkoid, conrelid, confrelid as parentid,
        conname,
        relname,
        nspname,
        fk_actions_update.action as update_action,
        fk_actions_delete.action as delete_action,
        conkey as key_cols
    from pg_constraint
             join pg_class on conrelid = pg_class.oid
             join pg_namespace on pg_class.relnamespace = pg_namespace.oid
             join fk_actions as fk_actions_update on confupdtype = fk_actions_update.code
             join fk_actions as fk_actions_delete on confdeltype = fk_actions_delete.code
    where contype = 'f'
), fk_attributes as (
    select fkoid, conrelid, attname, attnum
    from fk_list
             join pg_attribute on conrelid = attrelid and attnum = any(key_cols)
    order by fkoid, attnum
), fk_cols_list as (
    select fkoid, array_agg(attname) as cols_list
    from fk_attributes
    group by fkoid
), index_list as (
    select
        indexrelid as indexid,
        pg_class.relname as indexname,
        indrelid,
        indkey,
        indpred is not null as has_predicate,
        pg_get_indexdef(indexrelid) as indexdef
    from pg_index
             join pg_class on indexrelid = pg_class.oid
    where indisvalid
), fk_index_match as (
    select
        fk_list.*,
        indexid,
        indexname,
        indkey::int[] as indexatts,
        has_predicate,
        indexdef,
        array_length(key_cols, 1) as fk_colcount,
        array_length(indkey,1) as index_colcount,
        round(pg_relation_size(conrelid)/(1024^2)::numeric) as table_mb,
        cols_list
    from fk_list
             join fk_cols_list using (fkoid)
             left join index_list on
        conrelid = indrelid
            and (indkey::int2[])[0:(array_length(key_cols,1) -1)] operator(pg_catalog.@&gt;) key_cols

), fk_perfect_match as (
    select fkoid
    from fk_index_match
    where
        (index_colcount - 1) &lt;= fk_colcount
      and not has_predicate
      and indexdef like '%USING btree%'
), fk_index_check as (
    select 'no index' as issue, *, 1 as issue_sort
    from fk_index_match
    where indexid is null
    union all
    select 'questionable index' as issue, *, 2
    from fk_index_match
    where
        indexid is not null
      and fkoid not in (select fkoid from fk_perfect_match)
), parent_table_stats as (
    select
        fkoid,
        tabstats.relname as parent_name,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as parent_writes,
        round(pg_relation_size(parentid)/(1024^2)::numeric) as parent_mb
    from pg_stat_user_tables as tabstats
             join fk_list on relid = parentid
), fk_table_stats as (
    select
        fkoid,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as writes,
        seq_scan as table_scans
    from pg_stat_user_tables as tabstats
             join fk_list on relid = conrelid
)
select
    nspname as schema_name,
    relname as table_name,
    conname as fk_name,
    issue,
    table_mb,
    writes,
    table_scans,
    parent_name,
    parent_mb,
    parent_writes,
    cols_list,
    indexdef
from fk_index_check
         join parent_table_stats using (fkoid)
         join fk_table_stats using (fkoid)
where
    table_mb &gt; 9
  and (
    writes &gt; 1000
        or parent_writes &gt; 1000
        or parent_mb &gt; 10
    )
order by issue_sort, table_mb desc, table_name, fk_name;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-teoqar_1230" data-toc="-teoqar_1230">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-teoqar_1231"><thead><tr class="ijRowHead" id="-teoqar_1232"><th id="-teoqar_1233"><p>schema_name</p></th><th id="-teoqar_1234"><p>table_name</p></th><th id="-teoqar_1235"><p>fk_name</p></th><th id="-teoqar_1236"><p>issue</p></th><th id="-teoqar_1237"><p>table_mb</p></th><th id="-teoqar_1238"><p>writes</p></th><th id="-teoqar_1239"><p>table_scans</p></th><th id="-teoqar_1240"><p>parent_name</p></th><th id="-teoqar_1241"><p>parent_mb</p></th><th id="-teoqar_1242"><p>parent_writes</p></th><th id="-teoqar_1243"><p>cols_list</p></th><th id="-teoqar_1244"><p>indexdef</p></th></tr></thead><tbody><tr id="-teoqar_1245"><td id="-teoqar_1246"><p>public</p></td><td id="-teoqar_1247"><p>testnoidx</p></td><td id="-teoqar_1248"><p>testidx_copy1_fk_id_fkey</p></td><td id="-teoqar_1249"><p>no index</p></td><td id="-teoqar_1250"><p>1030</p></td><td id="-teoqar_1251"><p>11633001</p></td><td id="-teoqar_1252"><p>920</p></td><td id="-teoqar_1253"><p>testnoidx</p></td><td id="-teoqar_1254"><p>1030</p></td><td id="-teoqar_1255"><p>11633001</p></td><td id="-teoqar_1256"><p>{fk_id}</p></td><td id="-teoqar_1257"><p>null</p></td></tr><tr id="-teoqar_1258"><td id="-teoqar_1259"><p>public</p></td><td id="-teoqar_1260"><p>teststat</p></td><td id="-teoqar_1261"><p>teststat_fk_id_fkey</p></td><td id="-teoqar_1262"><p>no index</p></td><td id="-teoqar_1263"><p>1030</p></td><td id="-teoqar_1264"><p>11633001</p></td><td id="-teoqar_1265"><p>56</p></td><td id="-teoqar_1266"><p>teststat</p></td><td id="-teoqar_1267"><p>1030</p></td><td id="-teoqar_1268"><p>11633001</p></td><td id="-teoqar_1269"><p>{fk_id}</p></td><td id="-teoqar_1270"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-teoqar_1271" data-toc="-teoqar_1271">Поиск невалидных индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Invalid indexes" data-disable-link-processing="true">--Invalid indexes

-- Use it to see invalid indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

select
    coalesce(nullif(pn.nspname, 'public') || '.', '') || pct.relname as &quot;relation_name&quot;,
    pci.relname as index_name,
    pn.nspname as schema_name,
    pct.relname as table_name,
    pg_size_pretty(pg_relation_size(pidx.indexrelid)) index_size,
    format(
            'DROP INDEX CONCURRENTLY %s; -- %s, table %s',
            pidx.indexrelid::regclass::text,
            'Invalid index',
            pct.relname) as drop_code,
    replace(
            format('%s; -- table %s', pg_get_indexdef(pidx.indexrelid), pct.relname),
            'CREATE INDEX',
            'CREATE INDEX CONCURRENTLY'
    ) as revert_code
from pg_index pidx
         join pg_class as pci on pci.oid = pidx.indexrelid
         join pg_class as pct on pct.oid = pidx.indrelid
         left join pg_namespace pn on pn.oid = pct.relnamespace
where pidx.indisvalid = false;</div></section><section class="chapter"><h2 id="lock-trees-light" data-toc="lock-trees-light">Lock trees light версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees (leightweight)" data-disable-link-processing="true">--Lock trees (leightweight)

-- Source: https://github.com/dataegret/pg-utils/blob/master/sql/locktree.sql
-- The paths won't be precise but this query is very light and may be used quite frequently

with recursive l as (
    select pid, locktype, granted,
           array_position(array['accessshare','rowshare','rowexclusive','shareupdateexclusive','share','sharerowexclusive','exclusive','accessexclusive'], left(mode,-4)) m,
           row(locktype,database,relation,page,tuple,virtualxid,transactionid,classid,objid,objsubid) obj from pg_locks
), pairs as (
    select w.pid waiter, l.pid locker, l.obj, l.m
    from l w join l on l.obj is not distinct from w.obj and l.locktype=w.locktype and not l.pid=w.pid and l.granted
    where not w.granted
      and not exists ( select from l i where i.pid=l.pid and i.locktype=l.locktype and i.obj is not distinct from l.obj and i.m &gt; l.m )
), leads as (
    select o.locker, 1::int lvl, count(*) q, array[locker] track, false as cycle from pairs o group by o.locker
    union all
    select i.locker, leads.lvl+1, (select count(*) from pairs q where q.locker=i.locker), leads.track||i.locker, i.locker=any(leads.track)
    from pairs i, leads where i.waiter=leads.locker and not cycle
), tree as (
    select locker pid,locker dad,locker root,case when cycle then track end dl, null::record obj,0 lvl,locker::text path,array_agg(locker) over () all_pids from leads o
    where (cycle and not exists (select from leads i where i.locker=any(o.track) and (i.lvl&gt;o.lvl or i.q&lt;o.q)))
       or (not cycle and not exists (select from pairs where waiter=o.locker) and not exists (select from leads i where i.locker=o.locker and i.lvl&lt;o.lvl))
    union all
    select w.waiter pid,tree.pid,tree.root,case when w.waiter=any(tree.dl) then tree.dl end,w.obj,tree.lvl+1,tree.path||'.'||w.waiter,all_pids || array_agg(w.waiter) over ()
    from tree join pairs w on tree.pid=w.locker and not w.waiter = any ( all_pids )
)
select (clock_timestamp() - a.xact_start)::interval(0) as ts_age,
       (clock_timestamp() - a.state_change)::interval(0) as change_age,
       a.datname,a.usename,a.client_addr,
       --w.obj wait_on_object,
       tree.pid,replace(a.state, 'idle in transaction', 'idletx') state,
       lvl,(select count(*) from tree p where p.path ~ ('^'||tree.path) and not p.path=tree.path) blocked,
       case when tree.pid=any(tree.dl) then '!&gt;' else repeat(' .', lvl) end||' '||trim(left(regexp_replace(a.query, e'\\s+', ' ', 'g'),100)) query
from tree
         left join pairs w on w.waiter=tree.pid and w.locker=tree.dad
         join pg_stat_activity a using (pid)
         join pg_stat_activity r on r.pid=tree.root
order by (now() - r.xact_start), path;</div></section><section class="chapter"><h2 id="lock-trees" data-toc="lock-trees">Lock trees полная версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees, detailed (based on pg_blocking_pids())" data-disable-link-processing="true">--Lock trees, detailed (based on pg_blocking_pids())

-- Based on: https://gitlab.com/-/snippets/1890428
-- See also: https://postgres.ai/blog/20211018-postgresql-lock-trees

begin;

set local statement_timeout to '100ms';

with recursive activity as (
    select
        pg_blocking_pids(pid) blocked_by,
        *,
        age(clock_timestamp(), xact_start)::interval(0) as tx_age,
        age(clock_timestamp(), state_change)::interval(0) as state_age
    from pg_stat_activity
    where state is distinct from 'idle'
), blockers as (
    select
        array_agg(distinct c order by c) as pids
    from (
             select unnest(blocked_by)
             from activity
         ) as dt(c)
), tree as (
    select
        activity.*,
        1 as level,
        activity.pid as top_blocker_pid,
        array[activity.pid] as path,
        array[activity.pid]::int[] as all_blockers_above
    from activity, blockers
    where
        array[pid] &lt;@ blockers.pids
      and blocked_by = '{}'::int[]
    union all
    select
        activity.*,
        tree.level + 1 as level,
        tree.top_blocker_pid,
        path || array[activity.pid] as path,
        tree.all_blockers_above || array_agg(activity.pid) over () as all_blockers_above
    from activity, tree
    where
        not array[activity.pid] &lt;@ tree.all_blockers_above
      and activity.blocked_by &lt;&gt; '{}'::int[]
      and activity.blocked_by &lt;@ tree.all_blockers_above
)
select
    pid,
    blocked_by,
    tx_age,
    state_age,
    backend_xid as xid,
    backend_xmin as xmin,
    replace(state, 'idle in transaction', 'idletx') as state,
    datname,
    usename,
    wait_event_type || ':' || wait_event as wait,
    (select count(distinct t1.pid) from tree t1 where array[tree.pid] &lt;@ t1.path and t1.pid &lt;&gt; tree.pid) as blkd,
    format(
            '%s %s%s',
            lpad('[' || pid::text || ']', 7, ' '),
            repeat('.', level - 1) || case when level &gt; 1 then ' ' end,
            left(query, 1000)
    ) as query
from tree
order by top_blocker_pid, level, pid;

commit;</div></section><div class="last-modified">Last modified: 17 апреля 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="postgres-customextention.html" class="navigation-links__prev">Ресурсы и ссылки на дополнительные расширения</a><a href="postgres-dba-p2.html" class="navigation-links__next">Полезные скрипты Postgres-DBA часть 2</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>