<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-05-15T09:21:07.2301046"><title>Полезные скрипты Postgres-DBA | Postgres Полезные русурсы</title><script type="application/json" id="virtual-toc-data">[{"id":"-td4k4i_1918","level":0,"title":"Список расширений установленных в текущей базе","anchor":"#-td4k4i_1918"},{"id":"-td4k4i_1920","level":0,"title":"Базы данных и дополнительная информация","anchor":"#-td4k4i_1920"},{"id":"-td4k4i_2032","level":0,"title":"Таблицы - размеры, индексы","anchor":"#-td4k4i_2032"},{"id":"-td4k4i_2099","level":0,"title":"Текущая активность с группировкой по базе","anchor":"#-td4k4i_2099"},{"id":"table-bloat-estimated","level":0,"title":"Table bloat (estimated)","anchor":"#table-bloat-estimated"},{"id":"b-tree-index-bloat","level":0,"title":"B-tree index bloat","anchor":"#b-tree-index-bloat"},{"id":"table-bloat","level":0,"title":"Table bloat","anchor":"#table-bloat"},{"id":"b-tree-indexes-bloat","level":0,"title":"B-tree indexes bloat","anchor":"#b-tree-indexes-bloat"},{"id":"tables-and-columns-without-stats","level":0,"title":"Tables and columns without stats","anchor":"#tables-and-columns-without-stats"},{"id":"-td4k4i_2466","level":0,"title":"Неиспользуемые и редко используемые индексы","anchor":"#-td4k4i_2466"},{"id":"-td4k4i_2503","level":0,"title":"Избыточные индексы","anchor":"#-td4k4i_2503"},{"id":"fk","level":0,"title":"FK и отсутствующие индексы","anchor":"#fk"},{"id":"-td4k4i_2549","level":0,"title":"Поиск невалидных индексы","anchor":"#-td4k4i_2549"},{"id":"lock-trees-light","level":0,"title":"Lock trees light версия","anchor":"#lock-trees-light"},{"id":"lock-trees","level":0,"title":"Lock trees полная версия","anchor":"#lock-trees"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Postgres Полезные русурсы Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/postgres-dba.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/postgres-dba.html#webpage",
    "url": "writerside-documentation/postgres-dba.html",
    "name": "Полезные скрипты Postgres-DBA | Postgres Полезные русурсы",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Postgres Полезные русурсы Help"
}</script><!-- End Schema.org --></head><body data-id="postgres-dba" data-main-title="Полезные скрипты Postgres-DBA" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Default-topic.md|Postgres - полезные ресурсы, руководства подсказки, советы"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Postgres Полезные русурсы  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="postgres-dba" id="postgres-dba.md">Полезные скрипты Postgres-DBA</h1><p id="-td4k4i_1917">Набор полезных скриптов для DBA. Многие из скриптов взяты с просторов интернета.</p><section class="chapter"><h2 id="-td4k4i_1918" data-toc="-td4k4i_1918">Список расширений установленных в текущей базе</h2><div class="code-block" data-lang="sql" data-disable-link-processing="true">select ae.name,
       installed_version,
       default_version,
       case when installed_version &lt;&gt; default_version then 'OLD' end as is_old
from pg_extension e
         join pg_available_extensions ae on extname = ae.name
order by ae.name;</div></section><section class="chapter"><h2 id="-td4k4i_1920" data-toc="-td4k4i_1920">Базы данных и дополнительная информация</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Databases: size, stats" data-disable-link-processing="true">--Databases: size, stats
with data as (select d.oid,
                     (select spcname from pg_tablespace where oid = dattablespace) as tblspace,
                     d.datname                                                     as database_name,
                     pg_catalog.pg_get_userbyid(d.datdba)                          as owner,
                     has_database_privilege(d.datname, 'connect')                  as has_access,
                     pg_database_size(d.datname)                                   as size,
                     stats_reset,
                     blks_hit,
                     blks_read,
                     xact_commit,
                     xact_rollback,
                     conflicts,
                     deadlocks,
                     temp_files,
                     temp_bytes
              from pg_catalog.pg_database d
                       join pg_stat_database s on s.datid = d.oid),
     data2 as (select null::oid          as oid,
                      null               as tblspace,
                      '*** TOTAL ***'    as database_name,
                      null               as owner,
                      true               as has_access,
                      sum(size)          as size,
                      null::timestamptz  as stats_reset,
                      sum(blks_hit)      as blks_hit,
                      sum(blks_read)     as blks_read,
                      sum(xact_commit)   as xact_commit,
                      sum(xact_rollback) as xact_rollback,
                      sum(conflicts)     as conflicts,
                      sum(deadlocks)     as deadlocks,
                      sum(temp_files)    as temp_files,
                      sum(temp_bytes)    as temp_bytes
               from data
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      true,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select oid,
                      tblspace,
                      database_name,
                      owner,
                      has_access,
                      size,
                      stats_reset,
                      blks_hit,
                      blks_read,
                      xact_commit,
                      xact_rollback,
                      conflicts,
                      deadlocks,
                      temp_files,
                      temp_bytes
               from data)
select database_name || coalesce(' [' || nullif(tblspace, 'pg_default') || ']', '') as &quot;Database&quot;,
       case
           when has_access then
               pg_size_pretty(size) || ' (' || round(
                       100 * size::numeric / nullif(sum(size) over (partition by (oid is null)), 0),
                       2
                                               )::text || '%)'
           else 'no access'
           end                                                                      as &quot;Size&quot;,
       (now() - stats_reset)::interval(0)::text                                     as &quot;Stats Age&quot;,
       case
           when blks_hit + blks_read &gt; 0 then
               (round(blks_hit * 100::numeric / (blks_hit + blks_read), 2))::text || '%'
           else null
           end                                                                      as &quot;Cache eff.&quot;,
       case
           when xact_commit + xact_rollback &gt; 0 then
               (round(xact_commit * 100::numeric / (xact_commit + xact_rollback), 2))::text || '%'
           else null
           end                                                                      as &quot;Committed&quot;,
       conflicts                                                                    as &quot;Conflicts&quot;,
       deadlocks                                                                    as &quot;Deadlocks&quot;,
       temp_files::text || coalesce(' (' || pg_size_pretty(temp_bytes) || ')', '')  as &quot;Temp. Files&quot;
from data2
order by oid is null desc, size desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_1922" data-toc="-td4k4i_1922">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_1923"><thead><tr class="ijRowHead" id="-td4k4i_1924"><th id="-td4k4i_1925"><p>Database</p></th><th id="-td4k4i_1926"><p>Size</p></th><th id="-td4k4i_1927"><p>Stats Age</p></th><th id="-td4k4i_1928"><p>Cache eff.</p></th><th id="-td4k4i_1929"><p>Committed</p></th><th id="-td4k4i_1930"><p>Conflicts</p></th><th id="-td4k4i_1931"><p>Deadlocks</p></th><th id="-td4k4i_1932"><p>Temp. Files</p></th></tr></thead><tbody><tr id="-td4k4i_1933"><td id="-td4k4i_1934"><p>*** TOTAL ***</p></td><td id="-td4k4i_1935"><p>6008 MB (100.00%)</p></td><td id="-td4k4i_1936"><p>null</p></td><td id="-td4k4i_1937"><p>92.36%</p></td><td id="-td4k4i_1938"><p>99.96%</p></td><td id="-td4k4i_1939"><p>0</p></td><td id="-td4k4i_1940"><p>0</p></td><td id="-td4k4i_1941"><p>249 (7899 MB)</p></td></tr><tr id="-td4k4i_1942"><td id="-td4k4i_1943"><p>null</p></td><td id="-td4k4i_1944"><p>null</p></td><td id="-td4k4i_1945"><p>null</p></td><td id="-td4k4i_1946"><p>null</p></td><td id="-td4k4i_1947"><p>null</p></td><td id="-td4k4i_1948"><p>null</p></td><td id="-td4k4i_1949"><p>null</p></td><td id="-td4k4i_1950"><p>null</p></td></tr><tr id="-td4k4i_1951"><td id="-td4k4i_1952"><p>devtestindex</p></td><td id="-td4k4i_1953"><p>5939 MB (98.85%)</p></td><td id="-td4k4i_1954"><p>null</p></td><td id="-td4k4i_1955"><p>92.26%</p></td><td id="-td4k4i_1956"><p>99.85%</p></td><td id="-td4k4i_1957"><p>0</p></td><td id="-td4k4i_1958"><p>0</p></td><td id="-td4k4i_1959"><p>249 (7899 MB)</p></td></tr><tr id="-td4k4i_1960"><td id="-td4k4i_1961"><p>dvdrental</p></td><td id="-td4k4i_1962"><p>15 MB (0.25%)</p></td><td id="-td4k4i_1963"><p>null</p></td><td id="-td4k4i_1964"><p>99.85%</p></td><td id="-td4k4i_1965"><p>99.96%</p></td><td id="-td4k4i_1966"><p>0</p></td><td id="-td4k4i_1967"><p>0</p></td><td id="-td4k4i_1968"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1969"><td id="-td4k4i_1970"><p>testsasist</p></td><td id="-td4k4i_1971"><p>8668 kB (0.14%)</p></td><td id="-td4k4i_1972"><p>null</p></td><td id="-td4k4i_1973"><p>99.93%</p></td><td id="-td4k4i_1974"><p>99.99%</p></td><td id="-td4k4i_1975"><p>0</p></td><td id="-td4k4i_1976"><p>0</p></td><td id="-td4k4i_1977"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1978"><td id="-td4k4i_1979"><p>devtestdatatypes</p></td><td id="-td4k4i_1980"><p>7900 kB (0.13%)</p></td><td id="-td4k4i_1981"><p>null</p></td><td id="-td4k4i_1982"><p>99.81%</p></td><td id="-td4k4i_1983"><p>99.98%</p></td><td id="-td4k4i_1984"><p>0</p></td><td id="-td4k4i_1985"><p>0</p></td><td id="-td4k4i_1986"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1987"><td id="-td4k4i_1988"><p>devtesttablespace</p></td><td id="-td4k4i_1989"><p>7884 kB (0.13%)</p></td><td id="-td4k4i_1990"><p>null</p></td><td id="-td4k4i_1991"><p>99.84%</p></td><td id="-td4k4i_1992"><p>99.91%</p></td><td id="-td4k4i_1993"><p>0</p></td><td id="-td4k4i_1994"><p>0</p></td><td id="-td4k4i_1995"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_1996"><td id="-td4k4i_1997"><p>template1</p></td><td id="-td4k4i_1998"><p>7868 kB (0.13%)</p></td><td id="-td4k4i_1999"><p>null</p></td><td id="-td4k4i_2000"><p>99.91%</p></td><td id="-td4k4i_2001"><p>100.00%</p></td><td id="-td4k4i_2002"><p>0</p></td><td id="-td4k4i_2003"><p>0</p></td><td id="-td4k4i_2004"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_2005"><td id="-td4k4i_2006"><p>devlearnpg</p></td><td id="-td4k4i_2007"><p>7868 kB (0.13%)</p></td><td id="-td4k4i_2008"><p>null</p></td><td id="-td4k4i_2009"><p>100.00%</p></td><td id="-td4k4i_2010"><p>100.00%</p></td><td id="-td4k4i_2011"><p>0</p></td><td id="-td4k4i_2012"><p>0</p></td><td id="-td4k4i_2013"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_2014"><td id="-td4k4i_2015"><p>postgres</p></td><td id="-td4k4i_2016"><p>7844 kB (0.13%)</p></td><td id="-td4k4i_2017"><p>null</p></td><td id="-td4k4i_2018"><p>99.80%</p></td><td id="-td4k4i_2019"><p>99.99%</p></td><td id="-td4k4i_2020"><p>0</p></td><td id="-td4k4i_2021"><p>0</p></td><td id="-td4k4i_2022"><p>0 (0 bytes)</p></td></tr><tr id="-td4k4i_2023"><td id="-td4k4i_2024"><p>template0</p></td><td id="-td4k4i_2025"><p>7673 kB (0.12%)</p></td><td id="-td4k4i_2026"><p>null</p></td><td id="-td4k4i_2027"><p>null</p></td><td id="-td4k4i_2028"><p>null</p></td><td id="-td4k4i_2029"><p>0</p></td><td id="-td4k4i_2030"><p>0</p></td><td id="-td4k4i_2031"><p>0 (0 bytes)</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_2032" data-toc="-td4k4i_2032">Таблицы - размеры, индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables: table/index/TOAST size, number of rows" data-disable-link-processing="true">--Tables: table/index/TOAST size, number of rows

with data as (select c.oid,
                     (select spcname from pg_tablespace where oid = reltablespace) as tblspace,
                     nspname                                                       as schema_name,
                     relname                                                       as table_name,
                     c.reltuples                                                   as row_estimate,
                     pg_total_relation_size(c.oid)                                 as total_bytes,
                     pg_indexes_size(c.oid)                                        as index_bytes,
                     pg_total_relation_size(reltoastrelid)                         as toast_bytes,
                     pg_total_relation_size(c.oid) - pg_indexes_size(c.oid) -
                     coalesce(pg_total_relation_size(reltoastrelid), 0)            as table_bytes
              from pg_class c
                       left join pg_namespace n on n.oid = c.relnamespace
              where relkind = 'r'
                and nspname &lt;&gt; 'pg_catalog'),
     data2 as (select null::oid         as oid,
                      null              as tblspace,
                      null              as schema_name,
                      '*** TOTAL ***'   as table_name,
                      sum(row_estimate) as row_estimate,
                      sum(total_bytes)  as total_bytes,
                      sum(index_bytes)  as index_bytes,
                      sum(toast_bytes)  as toast_bytes,
                      sum(table_bytes)  as table_bytes
               from data
               union all
               select null::oid                                                      as oid,
                      null,
                      null                                                           as schema_name,
                      '    tablespace: [' || coalesce(tblspace, 'pg_default') || ']' as table_name,
                      sum(row_estimate)                                              as row_estimate,
                      sum(total_bytes)                                               as total_bytes,
                      sum(index_bytes)                                               as index_bytes,
                      sum(toast_bytes)                                               as toast_bytes,
                      sum(table_bytes)                                               as table_bytes
               from data
               where (select count(distinct coalesce(tblspace, 'pg_default')) from data) &gt;
                     1 -- don't show this part if there are no custom tablespaces
               group by tblspace
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select *
               from data)
select coalesce(nullif(schema_name, 'public') || '.', '') || table_name ||
       coalesce(' [' || tblspace || ']', '')                  as &quot;Table&quot;,
       '~' || case
                  when row_estimate &gt; 10 ^ 12 then round(row_estimate::numeric / 10 ^ 12::numeric, 0)::text || 'T'
                  when row_estimate &gt; 10 ^ 9 then round(row_estimate::numeric / 10 ^ 9::numeric, 0)::text || 'B'
                  when row_estimate &gt; 10 ^ 6 then round(row_estimate::numeric / 10 ^ 6::numeric, 0)::text || 'M'
                  when row_estimate &gt; 10 ^ 3 then round(row_estimate::numeric / 10 ^ 3::numeric, 0)::text || 'k'
                  else row_estimate::text
           end                                                as &quot;Rows&quot;,
       pg_size_pretty(total_bytes) || ' (' || round(
               100 * total_bytes::numeric /
               nullif(sum(total_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Total Size&quot;,
       pg_size_pretty(table_bytes) || ' (' || round(
               100 * table_bytes::numeric /
               nullif(sum(table_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Table Size&quot;,
       pg_size_pretty(index_bytes) || ' (' || round(
               100 * index_bytes::numeric /
               nullif(sum(index_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Index(es) Size&quot;,
       pg_size_pretty(toast_bytes) || ' (' || round(
               100 * toast_bytes::numeric /
               nullif(sum(toast_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;TOAST Size&quot;
from data2
where schema_name is distinct from 'information_schema'
order by oid is null desc, total_bytes desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2034" data-toc="-td4k4i_2034">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2035"><thead><tr class="ijRowHead" id="-td4k4i_2036"><th id="-td4k4i_2037"><p>Table</p></th><th id="-td4k4i_2038"><p>Rows</p></th><th id="-td4k4i_2039"><p>Total Size</p></th><th id="-td4k4i_2040"><p>Table Size</p></th><th id="-td4k4i_2041"><p>Index(es) Size</p></th><th id="-td4k4i_2042"><p>TOAST Size</p></th></tr></thead><tbody><tr id="-td4k4i_2043"><td id="-td4k4i_2044"><p>*** TOTAL ***</p></td><td id="-td4k4i_2045"><p>~50M</p></td><td id="-td4k4i_2046"><p>5931 MB (100.00%)</p></td><td id="-td4k4i_2047"><p>3973 MB (100.00%)</p></td><td id="-td4k4i_2048"><p>1003 MB (100.00%)</p></td><td id="-td4k4i_2049"><p>955 MB (100.00%)</p></td></tr><tr id="-td4k4i_2050"><td id="-td4k4i_2051"><p>null</p></td><td id="-td4k4i_2052"><p>null</p></td><td id="-td4k4i_2053"><p>null</p></td><td id="-td4k4i_2054"><p>null</p></td><td id="-td4k4i_2055"><p>null</p></td><td id="-td4k4i_2056"><p>null</p></td></tr><tr id="-td4k4i_2057"><td id="-td4k4i_2058"><p>testidx</p></td><td id="-td4k4i_2059"><p>~12M</p></td><td id="-td4k4i_2060"><p>1853 MB (31.25%)</p></td><td id="-td4k4i_2061"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_2062"><p>504 MB (50.29%)</p></td><td id="-td4k4i_2063"><p>318 MB (33.32%)</p></td></tr><tr id="-td4k4i_2064"><td id="-td4k4i_2065"><p>teststat</p></td><td id="-td4k4i_2066"><p>~12M</p></td><td id="-td4k4i_2067"><p>1598 MB (26.95%)</p></td><td id="-td4k4i_2068"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_2069"><p>249 MB (24.85%)</p></td><td id="-td4k4i_2070"><p>318 MB (33.34%)</p></td></tr><tr id="-td4k4i_2071"><td id="-td4k4i_2072"><p>testnoidx</p></td><td id="-td4k4i_2073"><p>~12M</p></td><td id="-td4k4i_2074"><p>1598 MB (26.95%)</p></td><td id="-td4k4i_2075"><p>1030 MB (25.94%)</p></td><td id="-td4k4i_2076"><p>249 MB (24.85%)</p></td><td id="-td4k4i_2077"><p>318 MB (33.34%)</p></td></tr><tr id="-td4k4i_2078"><td id="-td4k4i_2079"><p>t_agg</p></td><td id="-td4k4i_2080"><p>~10M</p></td><td id="-td4k4i_2081"><p>498 MB (8.39%)</p></td><td id="-td4k4i_2082"><p>498 MB (12.53%)</p></td><td id="-td4k4i_2083"><p>0 bytes (0.00%)</p></td><td id="-td4k4i_2084"><p>8192 bytes (0.00%)</p></td></tr><tr id="-td4k4i_2085"><td id="-td4k4i_2086"><p>testtbldata</p></td><td id="-td4k4i_2087"><p>~5M</p></td><td id="-td4k4i_2088"><p>384 MB (6.47%)</p></td><td id="-td4k4i_2089"><p>383 MB (9.65%)</p></td><td id="-td4k4i_2090"><p>0 bytes (0.00%)</p></td><td id="-td4k4i_2091"><p>8192 bytes (0.00%)</p></td></tr><tr id="-td4k4i_2092"><td id="-td4k4i_2093"><p>states</p></td><td id="-td4k4i_2094"><p>~3</p></td><td id="-td4k4i_2095"><p>56 kB (0.00%)</p></td><td id="-td4k4i_2096"><p>40 kB (0.00%)</p></td><td id="-td4k4i_2097"><p>16 kB (0.00%)</p></td><td id="-td4k4i_2098"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_2099" data-toc="-td4k4i_2099">Текущая активность с группировкой по базе</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Current activity: count of current connections grouped by database, user name, state" data-disable-link-processing="true">--Current activity: count of current connections grouped by database, user name, state
select
    coalesce(usename, '** ALL users **') as &quot;User&quot;,
    coalesce(datname, '** ALL databases **') as &quot;DB&quot;,
    coalesce(state, '** ALL states **') as &quot;Current State&quot;,
    count(*) as &quot;Count&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 minute') as &quot;State changed &gt;1m ago&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 hour') as &quot;State changed &gt;1h ago&quot;
from pg_stat_activity
group by grouping sets ((datname, usename, state), (usename, state), ())
order by
    usename is null desc,
    datname is null desc,
    2 asc,
    3 asc,
    count(*) desc
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2101" data-toc="-td4k4i_2101">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2102"><thead><tr class="ijRowHead" id="-td4k4i_2103"><th id="-td4k4i_2104"><p>User</p></th><th id="-td4k4i_2105"><p>DB</p></th><th id="-td4k4i_2106"><p>Current State</p></th><th id="-td4k4i_2107"><p>Count</p></th><th id="-td4k4i_2108"><p>State changed &gt;1m ago</p></th><th id="-td4k4i_2109"><p>State changed &gt;1h ago</p></th></tr></thead><tbody><tr id="-td4k4i_2110"><td id="-td4k4i_2111"><p>** ALL users **</p></td><td id="-td4k4i_2112"><p>** ALL databases **</p></td><td id="-td4k4i_2113"><p>** ALL states **</p></td><td id="-td4k4i_2114"><p>8</p></td><td id="-td4k4i_2115"><p>2</p></td><td id="-td4k4i_2116"><p>2</p></td></tr><tr id="-td4k4i_2117"><td id="-td4k4i_2118"><p>** ALL users **</p></td><td id="-td4k4i_2119"><p>** ALL databases **</p></td><td id="-td4k4i_2120"><p>** ALL states **</p></td><td id="-td4k4i_2121"><p>4</p></td><td id="-td4k4i_2122"><p>0</p></td><td id="-td4k4i_2123"><p>0</p></td></tr><tr id="-td4k4i_2124"><td id="-td4k4i_2125"><p>** ALL users **</p></td><td id="-td4k4i_2126"><p>** ALL databases **</p></td><td id="-td4k4i_2127"><p>** ALL states **</p></td><td id="-td4k4i_2128"><p>4</p></td><td id="-td4k4i_2129"><p>0</p></td><td id="-td4k4i_2130"><p>0</p></td></tr><tr id="-td4k4i_2131"><td id="-td4k4i_2132"><p>postgres</p></td><td id="-td4k4i_2133"><p>** ALL databases **</p></td><td id="-td4k4i_2134"><p>** ALL states **</p></td><td id="-td4k4i_2135"><p>1</p></td><td id="-td4k4i_2136"><p>0</p></td><td id="-td4k4i_2137"><p>0</p></td></tr><tr id="-td4k4i_2138"><td id="-td4k4i_2139"><p>postgres</p></td><td id="-td4k4i_2140"><p>** ALL databases **</p></td><td id="-td4k4i_2141"><p>** ALL states **</p></td><td id="-td4k4i_2142"><p>1</p></td><td id="-td4k4i_2143"><p>0</p></td><td id="-td4k4i_2144"><p>0</p></td></tr><tr id="-td4k4i_2145"><td id="-td4k4i_2146"><p>postgres</p></td><td id="-td4k4i_2147"><p>** ALL databases **</p></td><td id="-td4k4i_2148"><p>active</p></td><td id="-td4k4i_2149"><p>1</p></td><td id="-td4k4i_2150"><p>0</p></td><td id="-td4k4i_2151"><p>0</p></td></tr><tr id="-td4k4i_2152"><td id="-td4k4i_2153"><p>postgres</p></td><td id="-td4k4i_2154"><p>** ALL databases **</p></td><td id="-td4k4i_2155"><p>idle</p></td><td id="-td4k4i_2156"><p>2</p></td><td id="-td4k4i_2157"><p>2</p></td><td id="-td4k4i_2158"><p>2</p></td></tr><tr id="-td4k4i_2159"><td id="-td4k4i_2160"><p>postgres</p></td><td id="-td4k4i_2161"><p>devlearnpg</p></td><td id="-td4k4i_2162"><p>active</p></td><td id="-td4k4i_2163"><p>1</p></td><td id="-td4k4i_2164"><p>0</p></td><td id="-td4k4i_2165"><p>0</p></td></tr><tr id="-td4k4i_2166"><td id="-td4k4i_2167"><p>postgres</p></td><td id="-td4k4i_2168"><p>devtestindex</p></td><td id="-td4k4i_2169"><p>idle</p></td><td id="-td4k4i_2170"><p>1</p></td><td id="-td4k4i_2171"><p>1</p></td><td id="-td4k4i_2172"><p>1</p></td></tr><tr id="-td4k4i_2173"><td id="-td4k4i_2174"><p>postgres</p></td><td id="-td4k4i_2175"><p>devtesttablespace</p></td><td id="-td4k4i_2176"><p>idle</p></td><td id="-td4k4i_2177"><p>1</p></td><td id="-td4k4i_2178"><p>1</p></td><td id="-td4k4i_2179"><p>1</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat-estimated" data-toc="table-bloat-estimated">Table bloat (estimated)</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (estimated)" data-disable-link-processing="true">--Table bloat (estimated)

--This SQL is derived from https://github.com/ioguix/pgsql-bloat-estimation/blob/master/table/table_bloat.sql

/*
* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.
* This query is compatible with PostgreSQL 9.0 and more
*/

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (
    select
        tbl.oid tblid,
        ns.nspname as schema_name,
        tbl.relname as table_name,
        tbl.reltuples,
        tbl.relpages as heappages,
        coalesce(toast.relpages, 0) as toastpages,
        coalesce(toast.reltuples, 0) as toasttuples,
        coalesce(substring(array_to_string(tbl.reloptions, ' ') from '%fillfactor=#&quot;__#&quot;%' for '#')::int2, 100) as fillfactor,
        current_setting('block_size')::numeric as bs,
        case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as ma, -- NS: TODO: check it
        24 as page_hdr,
        23 + case when max(coalesce(null_frac, 0)) &gt; 0 then (7 + count(*)) / 8 else 0::int end
            + case when bool_or(att.attname = 'oid' and att.attnum &lt; 0) then 4 else 0 end as tpl_hdr_size,
        sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) as tpl_data_size,
        bool_or(att.atttypid = 'pg_catalog.name'::regtype)
            or sum(case when att.attnum &gt; 0 then 1 else 0 end) &lt;&gt; count(s.attname) as is_na
    from pg_attribute as att
             join pg_class as tbl on att.attrelid = tbl.oid and tbl.relkind = 'r'
             join pg_namespace as ns on ns.oid = tbl.relnamespace
             join pg_stats as s on s.schemaname = ns.nspname and s.tablename = tbl.relname and not s.inherited and s.attname = att.attname
             left join pg_class as toast on tbl.reltoastrelid = toast.oid
    where not att.attisdropped and s.schemaname not in ('pg_catalog', 'information_schema')
    group by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    order by 2, 3
), step2 as (
    select
        *,
        (
            4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                - case when tpl_hdr_size % ma = 0 then ma else tpl_hdr_size % ma end
                - case when ceil(tpl_data_size)::int % ma = 0 then ma else ceil(tpl_data_size)::int % ma end
            ) as tpl_size,
        bs - page_hdr as size_per_block,
        (heappages + toastpages) as tblpages
    from step1
), step3 as (
    select
        *,
        ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) as est_tblpages,
        ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) + ceil(toasttuples / 4) as est_tblpages_ff
    -- , stattuple.pgstattuple(tblid) as pst
    from step2
), step4 as (
    select
        *,
        tblpages * bs as real_size,
        (tblpages - est_tblpages) * bs as extra_size,
        case when tblpages - est_tblpages &gt; 0 then 100 * (tblpages - est_tblpages) / tblpages::float else 0 end as extra_ratio,
        (tblpages - est_tblpages_ff) * bs as bloat_size,
        case when tblpages - est_tblpages_ff &gt; 0 then 100 * (tblpages - est_tblpages_ff) / tblpages::float else 0 end as bloat_ratio
    -- , (pst).free_percent + (pst).dead_tuple_percent as real_frag
    from step3
             left join pg_stat_user_tables su on su.relid = tblid
    -- WHERE NOT is_na
    --   AND tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 &gt;= 1
)
select
    case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name as &quot;Table&quot;,
    pg_size_pretty(real_size::numeric) as &quot;Size&quot;,
    case
        when extra_size::numeric &gt;= 0
            then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text || '%)'
        else null
        end  as &quot;Extra&quot;,
    case
        when bloat_size::numeric &gt;= 0
            then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text || '%)'
        else null
        end as &quot;Bloat estimate&quot;,
    case
        when (real_size - bloat_size)::numeric &gt;=0
            then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
        else null
        end as &quot;Live&quot;,
    greatest(last_autovacuum, last_vacuum)::timestamp(0)::text
        || case greatest(last_autovacuum, last_vacuum)
               when last_autovacuum then ' (auto)'
               else '' end as &quot;Last Vaccuum&quot;,
    (
        select
            coalesce(substring(array_to_string(reloptions, ' ') from 'fillfactor=([0-9]+)')::smallint, 100)
        from pg_class
        where oid = tblid
    ) as &quot;Fillfactor&quot;
from step4
order by bloat_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2181" data-toc="-td4k4i_2181">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2182"><thead><tr class="ijRowHead" id="-td4k4i_2183"><th id="-td4k4i_2184"><p>Is N/A</p></th><th id="-td4k4i_2185"><p>Table</p></th><th id="-td4k4i_2186"><p>Size</p></th><th id="-td4k4i_2187"><p>Extra</p></th><th id="-td4k4i_2188"><p>Bloat estimate</p></th><th id="-td4k4i_2189"><p>Live</p></th><th id="-td4k4i_2190"><p>Last Vaccuum</p></th><th id="-td4k4i_2191"><p>Fillfactor</p></th></tr></thead><tbody><tr id="-td4k4i_2192"><td id="-td4k4i_2193"></td><td id="-td4k4i_2194"><p>testtbldata</p></td><td id="-td4k4i_2195"><p>383 MB</p></td><td id="-td4k4i_2196"><p>~14 MB (3.75%)</p></td><td id="-td4k4i_2197"><p>~14 MB (3.75%)</p></td><td id="-td4k4i_2198"><p>~369 MB</p></td><td id="-td4k4i_2199"><p>2024-03-25 03:54:41</p></td><td id="-td4k4i_2200"><p>100</p></td></tr><tr id="-td4k4i_2201"><td id="-td4k4i_2202"></td><td id="-td4k4i_2203"><p>t_agg</p></td><td id="-td4k4i_2204"><p>498 MB</p></td><td id="-td4k4i_2205"><p>~256 kB (0.05%)</p></td><td id="-td4k4i_2206"><p>~256 kB (0.05%)</p></td><td id="-td4k4i_2207"><p>~497 MB</p></td><td id="-td4k4i_2208"><p>2024-03-23 02:59:13</p></td><td id="-td4k4i_2209"><p>100</p></td></tr><tr id="-td4k4i_2210"><td id="-td4k4i_2211"></td><td id="-td4k4i_2212"><p>states</p></td><td id="-td4k4i_2213"><p>8192 bytes</p></td><td id="-td4k4i_2214"><p>~0 bytes (0.00%)</p></td><td id="-td4k4i_2215"><p>~0 bytes (0.00%)</p></td><td id="-td4k4i_2216"><p>~8192 bytes</p></td><td id="-td4k4i_2217"><p>2024-03-23 02:59:13</p></td><td id="-td4k4i_2218"><p>100</p></td></tr><tr id="-td4k4i_2219"><td id="-td4k4i_2220"></td><td id="-td4k4i_2221"><p>teststat</p></td><td id="-td4k4i_2222"><p>1344 MB</p></td><td id="-td4k4i_2223"><p>null</p></td><td id="-td4k4i_2224"><p>null</p></td><td id="-td4k4i_2225"><p>~1401 MB</p></td><td id="-td4k4i_2226"><p>2024-03-23 02:59:07</p></td><td id="-td4k4i_2227"><p>100</p></td></tr><tr id="-td4k4i_2228"><td id="-td4k4i_2229"></td><td id="-td4k4i_2230"><p>testidx</p></td><td id="-td4k4i_2231"><p>1344 MB</p></td><td id="-td4k4i_2232"><p>null</p></td><td id="-td4k4i_2233"><p>null</p></td><td id="-td4k4i_2234"><p>~1402 MB</p></td><td id="-td4k4i_2235"><p>2024-03-23 02:58:46</p></td><td id="-td4k4i_2236"><p>100</p></td></tr><tr id="-td4k4i_2237"><td id="-td4k4i_2238"></td><td id="-td4k4i_2239"><p>testnoidx</p></td><td id="-td4k4i_2240"><p>1344 MB</p></td><td id="-td4k4i_2241"><p>null</p></td><td id="-td4k4i_2242"><p>null</p></td><td id="-td4k4i_2243"><p>~1403 MB</p></td><td id="-td4k4i_2244"><p>2024-03-23 02:58:56</p></td><td id="-td4k4i_2245"><p>100</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-index-bloat" data-toc="b-tree-index-bloat">B-tree index bloat</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree index bloat (estimated)" data-disable-link-processing="true">--B-tree index bloat (estimated)

-- enhanced version of https://github.com/ioguix/pgsql-bloat-estimation/blob/master/btree/btree_bloat.sql

-- WARNING: executed with a non-superuser role, the query inspect only index on tables you are granted to read.
-- WARNING: rows with is_na = 't' are known to have bad statistics (&quot;name&quot; type is not supported).
-- This query is compatible with PostgreSQL 8.2+

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (select i.nspname                                                                        as schema_name,
                      i.tblname                                                                        as table_name,
                      i.idxname                                                                        as index_name,
                      i.reltuples,
                      i.relpages,
                      i.relam,
                      a.attrelid                                                                       AS table_oid,
                      current_setting('block_size')::numeric                                           AS bs,
                      fillfactor,
                      -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                      case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as maxalign,
                   /* per page header, fixed size: 20 for 7.X, 24 for others */
                      24                                                                               AS pagehdr,
                   /* per page btree opaque data */
                      16                                                                               AS pageopqdata,
                   /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                      case
                          when max(coalesce(s.null_frac, 0)) = 0 then 2 -- IndexTupleData size
                          else 2 + ((32 + 8 - 1) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                          end                                                                          as index_tuple_hdr_bm,
                   /* data len: we remove null values save space using it fractionnal part from stats */
                      sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024))                as nulldatawidth,
                      max(case when a.atttypid = 'pg_catalog.name'::regtype then 1 else 0 end) &gt; 0     as is_na
               from pg_attribute as a
                        join (select nspname,
                                     tbl.relname                                              AS tblname,
                                     idx.relname                                              AS idxname,
                                     idx.reltuples,
                                     idx.relpages,
                                     idx.relam,
                                     indrelid,
                                     indexrelid,
                                     indkey::smallint[]                                       AS attnum,
                                     coalesce(substring(array_to_string(idx.reloptions, ' ') from
                                                        'fillfactor=([0-9]+)')::smallint, 90) as fillfactor
                              from pg_index
                                       join pg_class idx on idx.oid = pg_index.indexrelid
                                       join pg_class tbl on tbl.oid = pg_index.indrelid
                                       join pg_namespace on pg_namespace.oid = idx.relnamespace
                              where pg_index.indisvalid
                                AND tbl.relkind = 'r'
                                AND idx.relpages &gt; 0) as i on a.attrelid = i.indexrelid
                        join pg_stats as s on
                   s.schemaname = i.nspname
                       and (
                       (s.tablename = i.tblname and
                        s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, true)) -- stats from tbl
                           OR (s.tablename = i.idxname AND s.attname = a.attname) -- stats from functionnal cols
                       )
                        join pg_type as t on a.atttypid = t.oid
               where a.attnum &gt; 0
               group by 1, 2, 3, 4, 5, 6, 7, 8, 9),
     step2 as (select *,
                      (
                          index_tuple_hdr_bm + maxalign
                              -- Add padding to the index tuple header to align on MAXALIGN
                              - case
                                    when index_tuple_hdr_bm % maxalign = 0 THEN maxalign
                                    else index_tuple_hdr_bm % maxalign end
                              + nulldatawidth + maxalign
                              -- Add padding to the data to align on MAXALIGN
                              - case
                                    when nulldatawidth = 0 then 0
                                    when nulldatawidth::integer % maxalign = 0 then maxalign
                                    else nulldatawidth::integer % maxalign
                              end
                          )::numeric as nulldatahdrwidth
               -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
               from step1),
     step3 as (select *,
                      -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
                      coalesce(
                              1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::float)),
                              0)                                                                      as est_pages,
                      coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) * fillfactor /
                                                          (100 * (4 + nulldatahdrwidth)::float))), 0) as est_pages_ff
               -- , stattuple.pgstatindex(quote_ident(nspname)||'.'||quote_ident(idxname)) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
               from step2
                        join pg_am am on step2.relam = am.oid
               where am.amname = 'btree'),
     step4 as (SELECT *,
                      bs * (relpages)::bigint                           AS real_size,
-------current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,
                      bs * (relpages - est_pages)::bigint               AS extra_size,
                      100 * (relpages - est_pages)::float / relpages    AS extra_ratio,
                      bs * (relpages - est_pages_ff)                    AS bloat_size,
                      100 * (relpages - est_pages_ff)::float / relpages AS bloat_ratio
               -- , 100-(sub.pst).avg_leaf_density, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, sub.reltuples, sub.relpages -- (DEBUG INFO)
               from step3
         -- WHERE NOT is_na
     )
select case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
       format(
               $out$%s
  (%s)$out$,
               left(index_name, 50) || case when length(index_name) &gt; 50 then '…' else '' end,
               coalesce(nullif(schema_name, 'public') || '.', '') || table_name
       )                                            as &quot;Index (Table)&quot;,
       pg_size_pretty(real_size::numeric)           as &quot;Size&quot;,
       case
           when extra_size::numeric &gt;= 0
               then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Extra&quot;,
       case
           when bloat_size::numeric &gt;= 0
               then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Bloat&quot;,
       case
           when (real_size - bloat_size)::numeric &gt;= 0
               then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
           else null
           end                                      as &quot;Live&quot;,
       fillfactor
from step4
order by real_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2247" data-toc="-td4k4i_2247">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2248"><thead><tr class="ijRowHead" id="-td4k4i_2249"><th id="-td4k4i_2250"><p>Is N/A</p></th><th id="-td4k4i_2251"><p>Index (Table)</p></th><th id="-td4k4i_2252"><p>Size</p></th><th id="-td4k4i_2253"><p>Extra</p></th><th id="-td4k4i_2254"><p>Bloat</p></th><th id="-td4k4i_2255"><p>Live</p></th><th id="-td4k4i_2256"><p>fillfactor</p></th></tr></thead><tbody><tr id="-td4k4i_2257"><td id="-td4k4i_2258"></td><td id="-td4k4i_2259"><p>teststat_pkey</p><br><p> (teststat)</p></td><td id="-td4k4i_2261"><p>249 MB</p></td><td id="-td4k4i_2262"><p>~26 MB (10.39%)</p></td><td id="-td4k4i_2263"><p>~904 kB (0.35%)</p></td><td id="-td4k4i_2264"><p>~248 MB</p></td><td id="-td4k4i_2265"><p>90</p></td></tr><tr id="-td4k4i_2266"><td id="-td4k4i_2267"></td><td id="-td4k4i_2268"><p>testidx_copy1_pkey</p><br><p> (testnoidx)</p></td><td id="-td4k4i_2270"><p>249 MB</p></td><td id="-td4k4i_2271"><p>~26 MB (10.29%)</p></td><td id="-td4k4i_2272"><p>~624 kB (0.24%)</p></td><td id="-td4k4i_2273"><p>~249 MB</p></td><td id="-td4k4i_2274"><p>90</p></td></tr><tr id="-td4k4i_2275"><td id="-td4k4i_2276"></td><td id="-td4k4i_2277"><p>testidx_pk</p><br><p> (testidx)</p></td><td id="-td4k4i_2279"><p>225 MB</p></td><td id="-td4k4i_2280"><p>~1328 kB (0.58%)</p></td><td id="-td4k4i_2281"><p>~1328 kB (0.58%)</p></td><td id="-td4k4i_2282"><p>~223 MB</p></td><td id="-td4k4i_2283"><p>100</p></td></tr><tr id="-td4k4i_2284"><td id="-td4k4i_2285"></td><td id="-td4k4i_2286"><p>testidx_created_at_index</p><br><p> (testidx)</p></td><td id="-td4k4i_2288"><p>165 MB</p></td><td id="-td4k4i_2289"><p>~15 MB (9.10%)</p></td><td id="-td4k4i_2290"><p>null</p></td><td id="-td4k4i_2291"><p>~167 MB</p></td><td id="-td4k4i_2292"><p>90</p></td></tr><tr id="-td4k4i_2293"><td id="-td4k4i_2294"></td><td id="-td4k4i_2295"><p>testidx_fk_id_index</p><br><p> (testidx)</p></td><td id="-td4k4i_2297"><p>114 MB</p></td><td id="-td4k4i_2298"><p>null</p></td><td id="-td4k4i_2299"><p>null</p></td><td id="-td4k4i_2300"><p>~247 MB</p></td><td id="-td4k4i_2301"><p>90</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat" data-toc="table-bloat">Table bloat</h2><p id="-td4k4i_2302">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-td4k4i_2303" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--Table bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without table name/mask query will read all available tables which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

select nspname,
       relname,
       pg_size_pretty(relation_size + toast_relation_size) as                                    total_size,
       pg_size_pretty(toast_relation_size)                 as                                    toast_size,
       round(((relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size, 1))::numeric, 1)                                           table_waste_percent,
       pg_size_pretty((relation_size - (relation_size - free_space) * 100 / fillfactor)::bigint) table_waste,
       round(((toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size + toast_relation_size, 1))::numeric, 1)                     total_waste_percent,
       pg_size_pretty((toast_free_space + relation_size -
                       (relation_size - free_space) * 100 / fillfactor)::bigint)                 total_waste
from (select nspname,
             relname,
             (select free_space from pgstattuple(c.oid))                                                         as free_space,
             pg_relation_size(c.oid)                                                                             as relation_size,
             (case
                  when reltoastrelid = 0 then 0
                  else (select free_space from pgstattuple(c.reltoastrelid)) end)                                as toast_free_space,
             coalesce(pg_relation_size(c.reltoastrelid), 0)                                                      as toast_relation_size,
             coalesce((SELECT (regexp_matches(reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),
                      '100')::real                                                                               AS fillfactor
      from pg_class c
               left join pg_namespace n on (n.oid = c.relnamespace)
      where nspname not in ('pg_catalog', 'information_schema')
        and nspname !~ '^pg_toast'
        and relkind = 'r'
        --put your table name/mask here
        and relname ~ '') t
order by (toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) desc
limit 20;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2306" data-toc="-td4k4i_2306">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2307"><thead><tr class="ijRowHead" id="-td4k4i_2308"><th id="-td4k4i_2309"><p>nspname</p></th><th id="-td4k4i_2310"><p>relname</p></th><th id="-td4k4i_2311"><p>total_size</p></th><th id="-td4k4i_2312"><p>toast_size</p></th><th id="-td4k4i_2313"><p>table_waste_percent</p></th><th id="-td4k4i_2314"><p>table_waste</p></th><th id="-td4k4i_2315"><p>total_waste_percent</p></th><th id="-td4k4i_2316"><p>total_waste</p></th></tr></thead><tbody><tr id="-td4k4i_2317"><td id="-td4k4i_2318"><p>public</p></td><td id="-td4k4i_2319"><p>teststat</p></td><td id="-td4k4i_2320"><p>1344 MB</p></td><td id="-td4k4i_2321"><p>314 MB</p></td><td id="-td4k4i_2322"><p>0.5</p></td><td id="-td4k4i_2323"><p>4829 kB</p></td><td id="-td4k4i_2324"><p>2.3</p></td><td id="-td4k4i_2325"><p>31 MB</p></td></tr><tr id="-td4k4i_2326"><td id="-td4k4i_2327"><p>public</p></td><td id="-td4k4i_2328"><p>testnoidx</p></td><td id="-td4k4i_2329"><p>1344 MB</p></td><td id="-td4k4i_2330"><p>314 MB</p></td><td id="-td4k4i_2331"><p>0.5</p></td><td id="-td4k4i_2332"><p>4829 kB</p></td><td id="-td4k4i_2333"><p>2.3</p></td><td id="-td4k4i_2334"><p>30 MB</p></td></tr><tr id="-td4k4i_2335"><td id="-td4k4i_2336"><p>public</p></td><td id="-td4k4i_2337"><p>testidx</p></td><td id="-td4k4i_2338"><p>1344 MB</p></td><td id="-td4k4i_2339"><p>314 MB</p></td><td id="-td4k4i_2340"><p>0.5</p></td><td id="-td4k4i_2341"><p>4829 kB</p></td><td id="-td4k4i_2342"><p>2.3</p></td><td id="-td4k4i_2343"><p>30 MB</p></td></tr><tr id="-td4k4i_2344"><td id="-td4k4i_2345"><p>public</p></td><td id="-td4k4i_2346"><p>testtbldata</p></td><td id="-td4k4i_2347"><p>383 MB</p></td><td id="-td4k4i_2348"><p>0 bytes</p></td><td id="-td4k4i_2349"><p>0.4</p></td><td id="-td4k4i_2350"><p>1746 kB</p></td><td id="-td4k4i_2351"><p>0.4</p></td><td id="-td4k4i_2352"><p>1746 kB</p></td></tr><tr id="-td4k4i_2353"><td id="-td4k4i_2354"><p>public</p></td><td id="-td4k4i_2355"><p>states</p></td><td id="-td4k4i_2356"><p>8192 bytes</p></td><td id="-td4k4i_2357"><p>0 bytes</p></td><td id="-td4k4i_2358"><p>97.7</p></td><td id="-td4k4i_2359"><p>8000 bytes</p></td><td id="-td4k4i_2360"><p>97.7</p></td><td id="-td4k4i_2361"><p>8000 bytes</p></td></tr><tr id="-td4k4i_2362"><td id="-td4k4i_2363"><p>public</p></td><td id="-td4k4i_2364"><p>t_agg</p></td><td id="-td4k4i_2365"><p>498 MB</p></td><td id="-td4k4i_2366"><p>0 bytes</p></td><td id="-td4k4i_2367"><p>0</p></td><td id="-td4k4i_2368"><p>5996 bytes</p></td><td id="-td4k4i_2369"><p>0</p></td><td id="-td4k4i_2370"><p>5996 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-indexes-bloat" data-toc="b-tree-indexes-bloat">B-tree indexes bloat</h2><p id="-td4k4i_2371">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-td4k4i_2372" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree indexes bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--B-tree indexes bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without index name/mask query will read all available indexes which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with data as (
    select
        schemaname as schema_name,
        p.relname as table_name,
        (select spcname from pg_tablespace where oid = c_table.reltablespace) as table_tblspace,
        (select spcname from pg_tablespace where oid = c.reltablespace) as index_tblspace,
        indexrelname as index_name,
        (
            select (case when avg_leaf_density = 'NaN' then 0
                         else greatest(ceil(index_size * (1 - avg_leaf_density / (coalesce((SELECT (regexp_matches(c.reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),'90')::real)))::bigint, 0) end)
            from pgstatindex(
                    case when p.indexrelid::regclass::text ~ '\.' then p.indexrelid::regclass::text else schemaname || '.' || p.indexrelid::regclass::text end
                 )
        ) as free_space,
        pg_relation_size(p.indexrelid) as index_size,
        pg_relation_size(p.relid) as table_size,
        idx_scan
    from pg_stat_user_indexes p
             join pg_class c on p.indexrelid = c.oid
             join pg_class c_table on p.relid = c_table.oid
    where
        pg_get_indexdef(p.indexrelid) like '%USING btree%'
      --put your index name/mask here
      and indexrelname ~ ''
)
select
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name || coalesce(' [' || table_tblspace || ']', '') as &quot;Table&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || index_name || coalesce(' [' || index_tblspace || ']', '') as &quot;Index&quot;,
    pg_size_pretty(table_size) as &quot;Table size&quot;,
    pg_size_pretty(index_size) as &quot;Index size&quot;,
    idx_scan as &quot;Index Scans&quot;,
    round((free_space*100/index_size)::numeric, 1) as &quot;Wasted, %&quot;,
    pg_size_pretty(free_space) as &quot;Wasted&quot;
from data
order by free_space desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2375" data-toc="-td4k4i_2375">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2376"><thead><tr class="ijRowHead" id="-td4k4i_2377"><th id="-td4k4i_2378"><p>Table</p></th><th id="-td4k4i_2379"><p>Index</p></th><th id="-td4k4i_2380"><p>Table size</p></th><th id="-td4k4i_2381"><p>Index size</p></th><th id="-td4k4i_2382"><p>Index Scans</p></th><th id="-td4k4i_2383"><p>Wasted, %</p></th><th id="-td4k4i_2384"><p>Wasted</p></th></tr></thead><tbody><tr id="-td4k4i_2385"><td id="-td4k4i_2386"><p>testidx</p></td><td id="-td4k4i_2387"><p>testidx_pk</p></td><td id="-td4k4i_2388"><p>1030 MB</p></td><td id="-td4k4i_2389"><p>225 MB</p></td><td id="-td4k4i_2390"><p>17240064</p></td><td id="-td4k4i_2391"><p>0</p></td><td id="-td4k4i_2392"><p>230 kB</p></td></tr><tr id="-td4k4i_2393"><td id="-td4k4i_2394"><p>states</p></td><td id="-td4k4i_2395"><p>states_pkey</p></td><td id="-td4k4i_2396"><p>8192 bytes</p></td><td id="-td4k4i_2397"><p>16 kB</p></td><td id="-td4k4i_2398"><p>3</p></td><td id="-td4k4i_2399"><p>99</p></td><td id="-td4k4i_2400"><p>16 kB</p></td></tr><tr id="-td4k4i_2401"><td id="-td4k4i_2402"><p>testnoidx</p></td><td id="-td4k4i_2403"><p>testidx_copy1_pkey</p></td><td id="-td4k4i_2404"><p>1030 MB</p></td><td id="-td4k4i_2405"><p>249 MB</p></td><td id="-td4k4i_2406"><p>2</p></td><td id="-td4k4i_2407"><p>0</p></td><td id="-td4k4i_2408"><p>0 bytes</p></td></tr><tr id="-td4k4i_2409"><td id="-td4k4i_2410"><p>teststat</p></td><td id="-td4k4i_2411"><p>teststat_pkey</p></td><td id="-td4k4i_2412"><p>1030 MB</p></td><td id="-td4k4i_2413"><p>249 MB</p></td><td id="-td4k4i_2414"><p>8620000</p></td><td id="-td4k4i_2415"><p>0</p></td><td id="-td4k4i_2416"><p>0 bytes</p></td></tr><tr id="-td4k4i_2417"><td id="-td4k4i_2418"><p>testidx</p></td><td id="-td4k4i_2419"><p>testidx_fk_id_index</p></td><td id="-td4k4i_2420"><p>1030 MB</p></td><td id="-td4k4i_2421"><p>114 MB</p></td><td id="-td4k4i_2422"><p>549</p></td><td id="-td4k4i_2423"><p>0</p></td><td id="-td4k4i_2424"><p>0 bytes</p></td></tr><tr id="-td4k4i_2425"><td id="-td4k4i_2426"><p>testidx</p></td><td id="-td4k4i_2427"><p>testidx_created_at_index</p></td><td id="-td4k4i_2428"><p>1030 MB</p></td><td id="-td4k4i_2429"><p>165 MB</p></td><td id="-td4k4i_2430"><p>41</p></td><td id="-td4k4i_2431"><p>0</p></td><td id="-td4k4i_2432"><p>0 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="tables-and-columns-without-stats" data-toc="tables-and-columns-without-stats">Tables and columns without stats</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables and columns without stats" data-disable-link-processing="true">--Tables and columns without stats
--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/bloat/no_stats_table_check.sql

SELECT table_schema, table_name,
       ( pg_class.relpages = 0 ) AS is_empty,
       ( psut.relname IS NULL OR ( psut.last_analyze IS NULL and psut.last_autoanalyze IS NULL ) ) AS never_analyzed,
       array_agg(column_name::TEXT) as no_stats_columns
FROM information_schema.columns
         JOIN pg_class ON columns.table_name = pg_class.relname
    AND pg_class.relkind = 'r'
         JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
    AND nspname = table_schema
         LEFT OUTER JOIN pg_stats
                         ON table_schema = pg_stats.schemaname
                             AND table_name = pg_stats.tablename
                             AND column_name = pg_stats.attname
         LEFT OUTER JOIN pg_stat_user_tables AS psut
                         ON table_schema = psut.schemaname
                             AND table_name = psut.relname
WHERE pg_stats.attname IS NULL
  AND table_schema NOT IN ('pg_catalog', 'information_schema')
GROUP BY table_schema, table_name, relpages, psut.relname, last_analyze, last_autoanalyze;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2434" data-toc="-td4k4i_2434">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2435"><thead><tr class="ijRowHead" id="-td4k4i_2436"><th id="-td4k4i_2437"><p>table_schema</p></th><th id="-td4k4i_2438"><p>table_name</p></th><th id="-td4k4i_2439"><p>is_empty</p></th><th id="-td4k4i_2440"><p>never_analyzed</p></th><th id="-td4k4i_2441"><p>no_stats_columns</p></th></tr></thead><tbody><tr id="-td4k4i_2442"><td id="-td4k4i_2443"><p>public</p></td><td id="-td4k4i_2444"><p>category</p></td><td id="-td4k4i_2445"><p>false</p></td><td id="-td4k4i_2446"><p>true</p></td><td id="-td4k4i_2447"><p>{name,category_id,last_update}</p></td></tr><tr id="-td4k4i_2448"><td id="-td4k4i_2449"><p>public</p></td><td id="-td4k4i_2450"><p>language</p></td><td id="-td4k4i_2451"><p>false</p></td><td id="-td4k4i_2452"><p>true</p></td><td id="-td4k4i_2453"><p>{last_update,name,language_id}</p></td></tr><tr id="-td4k4i_2454"><td id="-td4k4i_2455"><p>public</p></td><td id="-td4k4i_2456"><p>staff</p></td><td id="-td4k4i_2457"><p>false</p></td><td id="-td4k4i_2458"><p>true</p></td><td id="-td4k4i_2459"><p>{password,username,staff_id,first_name,email,last_name,picture,last_update,active,store_id,address_id}</p></td></tr><tr id="-td4k4i_2460"><td id="-td4k4i_2461"><p>public</p></td><td id="-td4k4i_2462"><p>store</p></td><td id="-td4k4i_2463"><p>false</p></td><td id="-td4k4i_2464"><p>true</p></td><td id="-td4k4i_2465"><p>{last_update,manager_staff_id,address_id,store_id}</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_2466" data-toc="-td4k4i_2466">Неиспользуемые и редко используемые индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Unused and rarely used indexes" data-disable-link-processing="true">--Unused and rarely used indexes

--PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/unused_indexes.sql

WITH table_scans as (
    SELECT relid,
           tables.idx_scan + tables.seq_scan as all_scans,
           ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
           pg_relation_size(relid) as table_size
    FROM pg_stat_user_tables as tables
),
     all_writes as (
         SELECT sum(writes) as total_writes
         FROM table_scans
     ),
     indexes as (
         SELECT idx_stat.relid, idx_stat.indexrelid,
                idx_stat.schemaname, idx_stat.relname as tablename,
                idx_stat.indexrelname as indexname,
                idx_stat.idx_scan,
                pg_relation_size(idx_stat.indexrelid) as index_bytes,
                indexdef ~* 'USING btree' AS idx_is_btree
         FROM pg_stat_user_indexes as idx_stat
                  JOIN pg_index
                       USING (indexrelid)
                  JOIN pg_indexes as indexes
                       ON idx_stat.schemaname = indexes.schemaname
                           AND idx_stat.relname = indexes.tablename
                           AND idx_stat.indexrelname = indexes.indexname
         WHERE pg_index.indisunique = FALSE
     ),
     index_ratios AS (
         SELECT schemaname, tablename, indexname,
                idx_scan, all_scans,
                round(( CASE WHEN all_scans = 0 THEN 0.0::NUMERIC
                             ELSE idx_scan::NUMERIC/all_scans * 100 END),2) as index_scan_pct,
                writes,
                round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2)
                                                                            as scans_per_write,
                pg_size_pretty(index_bytes) as index_size,
                pg_size_pretty(table_size) as table_size,
                idx_is_btree, index_bytes
         FROM indexes
                  JOIN table_scans
                       USING (relid)
     ),
     index_groups AS (
         SELECT 'Never Used Indexes' as reason, *, 1 as grp
         FROM index_ratios
         WHERE
             idx_scan = 0
           and idx_is_btree
         UNION ALL
         SELECT 'Low Scans, High Writes' as reason, *, 2 as grp
         FROM index_ratios
         WHERE
             scans_per_write &lt;= 1
           and index_scan_pct &lt; 10
           and idx_scan &gt; 0
           and writes &gt; 100
           and idx_is_btree
         UNION ALL
         SELECT 'Seldom Used Large Indexes' as reason, *, 3 as grp
         FROM index_ratios
         WHERE
             index_scan_pct &lt; 5
           and scans_per_write &gt; 1
           and idx_scan &gt; 0
           and idx_is_btree
           and index_bytes &gt; 100000000
         UNION ALL
         SELECT 'High-Write Large Non-Btree' as reason, index_ratios.*, 4 as grp
         FROM index_ratios, all_writes
         WHERE
             ( writes::NUMERIC / ( total_writes + 1 ) ) &gt; 0.02
           AND NOT idx_is_btree
           AND index_bytes &gt; 100000000
         ORDER BY grp, index_bytes DESC )
SELECT
    reason,
    schemaname as schema_name,
    tablename as table_name,
    indexname as index_name,
    index_scan_pct,
    scans_per_write,
    index_size,
    table_size,
    idx_scan,
    all_scans
FROM index_groups;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2468" data-toc="-td4k4i_2468">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2469"><thead><tr class="ijRowHead" id="-td4k4i_2470"><th id="-td4k4i_2471"><p>reason</p></th><th id="-td4k4i_2472"><p>schema_name</p></th><th id="-td4k4i_2473"><p>table_name</p></th><th id="-td4k4i_2474"><p>index_name</p></th><th id="-td4k4i_2475"><p>index_scan_pct</p></th><th id="-td4k4i_2476"><p>scans_per_write</p></th><th id="-td4k4i_2477"><p>index_size</p></th><th id="-td4k4i_2478"><p>table_size</p></th><th id="-td4k4i_2479"><p>idx_scan</p></th><th id="-td4k4i_2480"><p>all_scans</p></th></tr></thead><tbody><tr id="-td4k4i_2481"><td id="-td4k4i_2482"><p>Low Scans, High Writes</p></td><td id="-td4k4i_2483"><p>public</p></td><td id="-td4k4i_2484"><p>testidx</p></td><td id="-td4k4i_2485"><p>testidx_created_at_index</p></td><td id="-td4k4i_2486"><p>0</p></td><td id="-td4k4i_2487"><p>0</p></td><td id="-td4k4i_2488"><p>165 MB</p></td><td id="-td4k4i_2489"><p>1030 MB</p></td><td id="-td4k4i_2490"><p>41</p></td><td id="-td4k4i_2491"><p>17240843</p></td></tr><tr id="-td4k4i_2492"><td id="-td4k4i_2493"><p>Low Scans, High Writes</p></td><td id="-td4k4i_2494"><p>public</p></td><td id="-td4k4i_2495"><p>testidx</p></td><td id="-td4k4i_2496"><p>testidx_fk_id_index</p></td><td id="-td4k4i_2497"><p>0</p></td><td id="-td4k4i_2498"><p>0</p></td><td id="-td4k4i_2499"><p>114 MB</p></td><td id="-td4k4i_2500"><p>1030 MB</p></td><td id="-td4k4i_2501"><p>549</p></td><td id="-td4k4i_2502"><p>17240843</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_2503" data-toc="-td4k4i_2503">Избыточные индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Redundant indexes" data-disable-link-processing="true">--Redundant indexes

-- Use it to see redundant indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

with fk_indexes as (
    select
        n.nspname as schema_name,
        ci.relname as index_name,
        cr.relname as table_name,
        (confrelid::regclass)::text as fk_table_ref,
        array_to_string(indclass, ', ') as opclasses
    from pg_index i
             join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
             join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
             join pg_namespace n on n.oid = ci.relnamespace
             join pg_constraint cn on cn.conrelid = cr.oid
             left join pg_stat_user_indexes si on si.indexrelid = i.indexrelid
    where
        contype = 'f'
      and i.indisunique is false
      and conkey is not null
      and ci.relpages &gt; 0 -- raise for a DB with a lot of indexes
      and si.idx_scan &lt; 10
),
-- Redundant indexes
     index_data as (
         select
             *,
             (select string_agg(lpad(i, 3, '0'), ' ') from unnest(string_to_array(indkey::text, ' ')) i) as columns,
             array_to_string(indclass, ', ') as opclasses
         from pg_index i
                  join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
         where indisvalid = true and ci.relpages &gt; 0 -- raise for a DD with a lot of indexes
     ), redundant_indexes as (
    select
        i2.indexrelid as index_id,
        tnsp.nspname AS schema_name,
        trel.relname AS table_name,
        pg_relation_size(trel.oid) as table_size_bytes,
        irel.relname AS index_name,
        am1.amname as access_method,
        (i1.indexrelid::regclass)::text as reason,
        i1.indexrelid as reason_index_id,
        pg_get_indexdef(i1.indexrelid) main_index_def,
        pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size,
        pg_get_indexdef(i2.indexrelid) index_def,
        pg_relation_size(i2.indexrelid) index_size_bytes,
        s.idx_scan as index_usage,
        quote_ident(tnsp.nspname) as formated_schema_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) as formated_index_name,
        quote_ident(trel.relname) AS formated_table_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) as formated_relation_name,
        i2.opclasses
    from
        index_data as i1
            join index_data as i2 on (
            i1.indrelid = i2.indrelid -- same table
                and i1.indexrelid &lt;&gt; i2.indexrelid -- NOT same index
            )
            inner join pg_opclass op1 on i1.indclass[0] = op1.oid
            inner join pg_opclass op2 on i2.indclass[0] = op2.oid
            inner join pg_am am1 on op1.opcmethod = am1.oid
            inner join pg_am am2 on op2.opcmethod = am2.oid
            join pg_stat_user_indexes as s on s.indexrelid = i2.indexrelid
            join pg_class as trel on trel.oid = i2.indrelid
            join pg_namespace as tnsp on trel.relnamespace = tnsp.oid
            join pg_class as irel on irel.oid = i2.indexrelid
    where
        not i2.indisprimary -- index 1 is not primary
      and not ( -- skip if index1 is (primary or uniq) and is NOT (primary and uniq)
        i2.indisunique and not i1.indisprimary
        )
      and am1.amname = am2.amname -- same access type
      and i1.columns like (i2.columns || '%') -- index 2 includes all columns from index 1
      and i1.opclasses like (i2.opclasses || '%')
      -- index expressions is same
      and pg_get_expr(i1.indexprs, i1.indrelid) is not distinct from pg_get_expr(i2.indexprs, i2.indrelid)
      -- index predicates is same
      and pg_get_expr(i1.indpred, i1.indrelid) is not distinct from pg_get_expr(i2.indpred, i2.indrelid)
), redundant_indexes_fk as (
    select
        ri.*,
        (
            select count(1)
            from fk_indexes fi
            where
                fi.fk_table_ref = ri.table_name
              and fi.opclasses like (ri.opclasses || '%')
        ) &gt; 0 as supports_fk
    from redundant_indexes ri
),
-- Cut recursive links
     redundant_indexes_tmp_num as (
         select
                     row_number() over () num,
                     rig.*
         from redundant_indexes_fk rig
         order by index_id
     ), redundant_indexes_tmp_cut as (
    select
        ri1.*,
        ri2.num as r_num
    from redundant_indexes_tmp_num ri1
             left join redundant_indexes_tmp_num ri2 on ri2.reason_index_id = ri1.index_id and ri1.reason_index_id = ri2.index_id
    where ri1.num &lt; ri2.num or ri2.num is null
), redundant_indexes_cut_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
), redundant_indexes_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
)
select
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    string_agg(distinct reason, ', ') as redundant_to,
    string_agg(main_index_def, ', ') as main_index_def,
    string_agg(main_index_size, ', ') as main_index_size,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
from redundant_indexes_cut_grouped
group by
    index_id,
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
order by index_size_bytes desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2505" data-toc="-td4k4i_2505">Результат</h3></div><div class="collapse__content"><p id="-td4k4i_2506">TODO: добавить пример!</p></div></div></section></section><section class="chapter"><h2 id="fk" data-toc="fk">FK и отсутствующие индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--FKs with Missing/Bad Indexes" data-disable-link-processing="true">--FKs with Missing/Bad Indexes

--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/fk_no_index.sql

-- check for FKs where there is no matching index
-- on the referencing side
-- or a bad index

with fk_actions ( code, action ) as (
    values ('a', 'error'),
           ('r', 'restrict'),
           ('c', 'cascade'),
           ('n', 'set null'),
           ('d', 'set default')
), fk_list as (
    select
        pg_constraint.oid as fkoid, conrelid, confrelid as parentid,
        conname,
        relname,
        nspname,
        fk_actions_update.action as update_action,
        fk_actions_delete.action as delete_action,
        conkey as key_cols
    from pg_constraint
             join pg_class on conrelid = pg_class.oid
             join pg_namespace on pg_class.relnamespace = pg_namespace.oid
             join fk_actions as fk_actions_update on confupdtype = fk_actions_update.code
             join fk_actions as fk_actions_delete on confdeltype = fk_actions_delete.code
    where contype = 'f'
), fk_attributes as (
    select fkoid, conrelid, attname, attnum
    from fk_list
             join pg_attribute on conrelid = attrelid and attnum = any(key_cols)
    order by fkoid, attnum
), fk_cols_list as (
    select fkoid, array_agg(attname) as cols_list
    from fk_attributes
    group by fkoid
), index_list as (
    select
        indexrelid as indexid,
        pg_class.relname as indexname,
        indrelid,
        indkey,
        indpred is not null as has_predicate,
        pg_get_indexdef(indexrelid) as indexdef
    from pg_index
             join pg_class on indexrelid = pg_class.oid
    where indisvalid
), fk_index_match as (
    select
        fk_list.*,
        indexid,
        indexname,
        indkey::int[] as indexatts,
        has_predicate,
        indexdef,
        array_length(key_cols, 1) as fk_colcount,
        array_length(indkey,1) as index_colcount,
        round(pg_relation_size(conrelid)/(1024^2)::numeric) as table_mb,
        cols_list
    from fk_list
             join fk_cols_list using (fkoid)
             left join index_list on
        conrelid = indrelid
            and (indkey::int2[])[0:(array_length(key_cols,1) -1)] operator(pg_catalog.@&gt;) key_cols

), fk_perfect_match as (
    select fkoid
    from fk_index_match
    where
        (index_colcount - 1) &lt;= fk_colcount
      and not has_predicate
      and indexdef like '%USING btree%'
), fk_index_check as (
    select 'no index' as issue, *, 1 as issue_sort
    from fk_index_match
    where indexid is null
    union all
    select 'questionable index' as issue, *, 2
    from fk_index_match
    where
        indexid is not null
      and fkoid not in (select fkoid from fk_perfect_match)
), parent_table_stats as (
    select
        fkoid,
        tabstats.relname as parent_name,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as parent_writes,
        round(pg_relation_size(parentid)/(1024^2)::numeric) as parent_mb
    from pg_stat_user_tables as tabstats
             join fk_list on relid = parentid
), fk_table_stats as (
    select
        fkoid,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as writes,
        seq_scan as table_scans
    from pg_stat_user_tables as tabstats
             join fk_list on relid = conrelid
)
select
    nspname as schema_name,
    relname as table_name,
    conname as fk_name,
    issue,
    table_mb,
    writes,
    table_scans,
    parent_name,
    parent_mb,
    parent_writes,
    cols_list,
    indexdef
from fk_index_check
         join parent_table_stats using (fkoid)
         join fk_table_stats using (fkoid)
where
    table_mb &gt; 9
  and (
    writes &gt; 1000
        or parent_writes &gt; 1000
        or parent_mb &gt; 10
    )
order by issue_sort, table_mb desc, table_name, fk_name;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-td4k4i_2508" data-toc="-td4k4i_2508">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td4k4i_2509"><thead><tr class="ijRowHead" id="-td4k4i_2510"><th id="-td4k4i_2511"><p>schema_name</p></th><th id="-td4k4i_2512"><p>table_name</p></th><th id="-td4k4i_2513"><p>fk_name</p></th><th id="-td4k4i_2514"><p>issue</p></th><th id="-td4k4i_2515"><p>table_mb</p></th><th id="-td4k4i_2516"><p>writes</p></th><th id="-td4k4i_2517"><p>table_scans</p></th><th id="-td4k4i_2518"><p>parent_name</p></th><th id="-td4k4i_2519"><p>parent_mb</p></th><th id="-td4k4i_2520"><p>parent_writes</p></th><th id="-td4k4i_2521"><p>cols_list</p></th><th id="-td4k4i_2522"><p>indexdef</p></th></tr></thead><tbody><tr id="-td4k4i_2523"><td id="-td4k4i_2524"><p>public</p></td><td id="-td4k4i_2525"><p>testnoidx</p></td><td id="-td4k4i_2526"><p>testidx_copy1_fk_id_fkey</p></td><td id="-td4k4i_2527"><p>no index</p></td><td id="-td4k4i_2528"><p>1030</p></td><td id="-td4k4i_2529"><p>11633001</p></td><td id="-td4k4i_2530"><p>920</p></td><td id="-td4k4i_2531"><p>testnoidx</p></td><td id="-td4k4i_2532"><p>1030</p></td><td id="-td4k4i_2533"><p>11633001</p></td><td id="-td4k4i_2534"><p>{fk_id}</p></td><td id="-td4k4i_2535"><p>null</p></td></tr><tr id="-td4k4i_2536"><td id="-td4k4i_2537"><p>public</p></td><td id="-td4k4i_2538"><p>teststat</p></td><td id="-td4k4i_2539"><p>teststat_fk_id_fkey</p></td><td id="-td4k4i_2540"><p>no index</p></td><td id="-td4k4i_2541"><p>1030</p></td><td id="-td4k4i_2542"><p>11633001</p></td><td id="-td4k4i_2543"><p>56</p></td><td id="-td4k4i_2544"><p>teststat</p></td><td id="-td4k4i_2545"><p>1030</p></td><td id="-td4k4i_2546"><p>11633001</p></td><td id="-td4k4i_2547"><p>{fk_id}</p></td><td id="-td4k4i_2548"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-td4k4i_2549" data-toc="-td4k4i_2549">Поиск невалидных индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Invalid indexes" data-disable-link-processing="true">--Invalid indexes

-- Use it to see invalid indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

select
    coalesce(nullif(pn.nspname, 'public') || '.', '') || pct.relname as &quot;relation_name&quot;,
    pci.relname as index_name,
    pn.nspname as schema_name,
    pct.relname as table_name,
    pg_size_pretty(pg_relation_size(pidx.indexrelid)) index_size,
    format(
            'DROP INDEX CONCURRENTLY %s; -- %s, table %s',
            pidx.indexrelid::regclass::text,
            'Invalid index',
            pct.relname) as drop_code,
    replace(
            format('%s; -- table %s', pg_get_indexdef(pidx.indexrelid), pct.relname),
            'CREATE INDEX',
            'CREATE INDEX CONCURRENTLY'
    ) as revert_code
from pg_index pidx
         join pg_class as pci on pci.oid = pidx.indexrelid
         join pg_class as pct on pct.oid = pidx.indrelid
         left join pg_namespace pn on pn.oid = pct.relnamespace
where pidx.indisvalid = false;</div></section><section class="chapter"><h2 id="lock-trees-light" data-toc="lock-trees-light">Lock trees light версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees (leightweight)" data-disable-link-processing="true">--Lock trees (leightweight)

-- Source: https://github.com/dataegret/pg-utils/blob/master/sql/locktree.sql
-- The paths won't be precise but this query is very light and may be used quite frequently

with recursive l as (
    select pid, locktype, granted,
           array_position(array['accessshare','rowshare','rowexclusive','shareupdateexclusive','share','sharerowexclusive','exclusive','accessexclusive'], left(mode,-4)) m,
           row(locktype,database,relation,page,tuple,virtualxid,transactionid,classid,objid,objsubid) obj from pg_locks
), pairs as (
    select w.pid waiter, l.pid locker, l.obj, l.m
    from l w join l on l.obj is not distinct from w.obj and l.locktype=w.locktype and not l.pid=w.pid and l.granted
    where not w.granted
      and not exists ( select from l i where i.pid=l.pid and i.locktype=l.locktype and i.obj is not distinct from l.obj and i.m &gt; l.m )
), leads as (
    select o.locker, 1::int lvl, count(*) q, array[locker] track, false as cycle from pairs o group by o.locker
    union all
    select i.locker, leads.lvl+1, (select count(*) from pairs q where q.locker=i.locker), leads.track||i.locker, i.locker=any(leads.track)
    from pairs i, leads where i.waiter=leads.locker and not cycle
), tree as (
    select locker pid,locker dad,locker root,case when cycle then track end dl, null::record obj,0 lvl,locker::text path,array_agg(locker) over () all_pids from leads o
    where (cycle and not exists (select from leads i where i.locker=any(o.track) and (i.lvl&gt;o.lvl or i.q&lt;o.q)))
       or (not cycle and not exists (select from pairs where waiter=o.locker) and not exists (select from leads i where i.locker=o.locker and i.lvl&lt;o.lvl))
    union all
    select w.waiter pid,tree.pid,tree.root,case when w.waiter=any(tree.dl) then tree.dl end,w.obj,tree.lvl+1,tree.path||'.'||w.waiter,all_pids || array_agg(w.waiter) over ()
    from tree join pairs w on tree.pid=w.locker and not w.waiter = any ( all_pids )
)
select (clock_timestamp() - a.xact_start)::interval(0) as ts_age,
       (clock_timestamp() - a.state_change)::interval(0) as change_age,
       a.datname,a.usename,a.client_addr,
       --w.obj wait_on_object,
       tree.pid,replace(a.state, 'idle in transaction', 'idletx') state,
       lvl,(select count(*) from tree p where p.path ~ ('^'||tree.path) and not p.path=tree.path) blocked,
       case when tree.pid=any(tree.dl) then '!&gt;' else repeat(' .', lvl) end||' '||trim(left(regexp_replace(a.query, e'\\s+', ' ', 'g'),100)) query
from tree
         left join pairs w on w.waiter=tree.pid and w.locker=tree.dad
         join pg_stat_activity a using (pid)
         join pg_stat_activity r on r.pid=tree.root
order by (now() - r.xact_start), path;</div></section><section class="chapter"><h2 id="lock-trees" data-toc="lock-trees">Lock trees полная версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees, detailed (based on pg_blocking_pids())" data-disable-link-processing="true">--Lock trees, detailed (based on pg_blocking_pids())

-- Based on: https://gitlab.com/-/snippets/1890428
-- See also: https://postgres.ai/blog/20211018-postgresql-lock-trees

begin;

set local statement_timeout to '100ms';

with recursive activity as (
    select
        pg_blocking_pids(pid) blocked_by,
        *,
        age(clock_timestamp(), xact_start)::interval(0) as tx_age,
        age(clock_timestamp(), state_change)::interval(0) as state_age
    from pg_stat_activity
    where state is distinct from 'idle'
), blockers as (
    select
        array_agg(distinct c order by c) as pids
    from (
             select unnest(blocked_by)
             from activity
         ) as dt(c)
), tree as (
    select
        activity.*,
        1 as level,
        activity.pid as top_blocker_pid,
        array[activity.pid] as path,
        array[activity.pid]::int[] as all_blockers_above
    from activity, blockers
    where
        array[pid] &lt;@ blockers.pids
      and blocked_by = '{}'::int[]
    union all
    select
        activity.*,
        tree.level + 1 as level,
        tree.top_blocker_pid,
        path || array[activity.pid] as path,
        tree.all_blockers_above || array_agg(activity.pid) over () as all_blockers_above
    from activity, tree
    where
        not array[activity.pid] &lt;@ tree.all_blockers_above
      and activity.blocked_by &lt;&gt; '{}'::int[]
      and activity.blocked_by &lt;@ tree.all_blockers_above
)
select
    pid,
    blocked_by,
    tx_age,
    state_age,
    backend_xid as xid,
    backend_xmin as xmin,
    replace(state, 'idle in transaction', 'idletx') as state,
    datname,
    usename,
    wait_event_type || ':' || wait_event as wait,
    (select count(distinct t1.pid) from tree t1 where array[tree.pid] &lt;@ t1.path and t1.pid &lt;&gt; tree.pid) as blkd,
    format(
            '%s %s%s',
            lpad('[' || pid::text || ']', 7, ' '),
            repeat('.', level - 1) || case when level &gt; 1 then ' ' end,
            left(query, 1000)
    ) as query
from tree
order by top_blocker_pid, level, pid;

commit;</div></section><div class="last-modified">Last modified: 15 мая 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="postgres-customextention.html" class="navigation-links__prev">Ресурсы и ссылки на дополнительные расширения</a><a href="postgres-dba-p2.html" class="navigation-links__next">Полезные скрипты Postgres-DBA часть 2</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>