<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-06-08T10:04:58.3028634"><title>Полезные скрипты Postgres-DBA | Postgres Полезные русурсы</title><script type="application/json" id="virtual-toc-data">[{"id":"-qfpsgo_3","level":0,"title":"Список расширений установленных в текущей базе","anchor":"#-qfpsgo_3"},{"id":"-qfpsgo_5","level":0,"title":"Базы данных и дополнительная информация","anchor":"#-qfpsgo_5"},{"id":"-qfpsgo_117","level":0,"title":"Таблицы - размеры, индексы","anchor":"#-qfpsgo_117"},{"id":"-qfpsgo_184","level":0,"title":"Текущая активность с группировкой по базе","anchor":"#-qfpsgo_184"},{"id":"table-bloat-estimated","level":0,"title":"Table bloat (estimated)","anchor":"#table-bloat-estimated"},{"id":"b-tree-index-bloat","level":0,"title":"B-tree index bloat","anchor":"#b-tree-index-bloat"},{"id":"table-bloat","level":0,"title":"Table bloat","anchor":"#table-bloat"},{"id":"b-tree-indexes-bloat","level":0,"title":"B-tree indexes bloat","anchor":"#b-tree-indexes-bloat"},{"id":"tables-and-columns-without-stats","level":0,"title":"Tables and columns without stats","anchor":"#tables-and-columns-without-stats"},{"id":"-qfpsgo_551","level":0,"title":"Неиспользуемые и редко используемые индексы","anchor":"#-qfpsgo_551"},{"id":"-qfpsgo_588","level":0,"title":"Избыточные индексы","anchor":"#-qfpsgo_588"},{"id":"fk","level":0,"title":"FK и отсутствующие индексы","anchor":"#fk"},{"id":"-qfpsgo_634","level":0,"title":"Поиск невалидных индексы","anchor":"#-qfpsgo_634"},{"id":"lock-trees-light","level":0,"title":"Lock trees light версия","anchor":"#lock-trees-light"},{"id":"lock-trees","level":0,"title":"Lock trees полная версия","anchor":"#lock-trees"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Postgres Полезные русурсы Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/postgres-dba.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Полезные скрипты Postgres-DBA | Postgres Полезные русурсы"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/postgres-dba.html#webpage",
    "url": "writerside-documentation/postgres-dba.html",
    "name": "Полезные скрипты Postgres-DBA | Postgres Полезные русурсы",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Postgres Полезные русурсы Help"
}</script><!-- End Schema.org --></head><body data-id="postgres-dba" data-main-title="Полезные скрипты Postgres-DBA" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Default-topic.md|Postgres - полезные ресурсы, руководства подсказки, советы"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Postgres Полезные русурсы  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="postgres-dba" id="postgres-dba.md">Полезные скрипты Postgres-DBA</h1><p id="-qfpsgo_2">Набор полезных скриптов для DBA. Многие из скриптов взяты с просторов интернета.</p><section class="chapter"><h2 id="-qfpsgo_3" data-toc="-qfpsgo_3">Список расширений установленных в текущей базе</h2><div class="code-block" data-lang="sql" data-disable-link-processing="true">select ae.name,
       installed_version,
       default_version,
       case when installed_version &lt;&gt; default_version then 'OLD' end as is_old
from pg_extension e
         join pg_available_extensions ae on extname = ae.name
order by ae.name;</div></section><section class="chapter"><h2 id="-qfpsgo_5" data-toc="-qfpsgo_5">Базы данных и дополнительная информация</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Databases: size, stats" data-disable-link-processing="true">--Databases: size, stats
with data as (select d.oid,
                     (select spcname from pg_tablespace where oid = dattablespace) as tblspace,
                     d.datname                                                     as database_name,
                     pg_catalog.pg_get_userbyid(d.datdba)                          as owner,
                     has_database_privilege(d.datname, 'connect')                  as has_access,
                     pg_database_size(d.datname)                                   as size,
                     stats_reset,
                     blks_hit,
                     blks_read,
                     xact_commit,
                     xact_rollback,
                     conflicts,
                     deadlocks,
                     temp_files,
                     temp_bytes
              from pg_catalog.pg_database d
                       join pg_stat_database s on s.datid = d.oid),
     data2 as (select null::oid          as oid,
                      null               as tblspace,
                      '*** TOTAL ***'    as database_name,
                      null               as owner,
                      true               as has_access,
                      sum(size)          as size,
                      null::timestamptz  as stats_reset,
                      sum(blks_hit)      as blks_hit,
                      sum(blks_read)     as blks_read,
                      sum(xact_commit)   as xact_commit,
                      sum(xact_rollback) as xact_rollback,
                      sum(conflicts)     as conflicts,
                      sum(deadlocks)     as deadlocks,
                      sum(temp_files)    as temp_files,
                      sum(temp_bytes)    as temp_bytes
               from data
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      true,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select oid,
                      tblspace,
                      database_name,
                      owner,
                      has_access,
                      size,
                      stats_reset,
                      blks_hit,
                      blks_read,
                      xact_commit,
                      xact_rollback,
                      conflicts,
                      deadlocks,
                      temp_files,
                      temp_bytes
               from data)
select database_name || coalesce(' [' || nullif(tblspace, 'pg_default') || ']', '') as &quot;Database&quot;,
       case
           when has_access then
               pg_size_pretty(size) || ' (' || round(
                       100 * size::numeric / nullif(sum(size) over (partition by (oid is null)), 0),
                       2
                                               )::text || '%)'
           else 'no access'
           end                                                                      as &quot;Size&quot;,
       (now() - stats_reset)::interval(0)::text                                     as &quot;Stats Age&quot;,
       case
           when blks_hit + blks_read &gt; 0 then
               (round(blks_hit * 100::numeric / (blks_hit + blks_read), 2))::text || '%'
           else null
           end                                                                      as &quot;Cache eff.&quot;,
       case
           when xact_commit + xact_rollback &gt; 0 then
               (round(xact_commit * 100::numeric / (xact_commit + xact_rollback), 2))::text || '%'
           else null
           end                                                                      as &quot;Committed&quot;,
       conflicts                                                                    as &quot;Conflicts&quot;,
       deadlocks                                                                    as &quot;Deadlocks&quot;,
       temp_files::text || coalesce(' (' || pg_size_pretty(temp_bytes) || ')', '')  as &quot;Temp. Files&quot;
from data2
order by oid is null desc, size desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_7" data-toc="-qfpsgo_7">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_8"><thead><tr class="ijRowHead" id="-qfpsgo_9"><th id="-qfpsgo_10"><p>Database</p></th><th id="-qfpsgo_11"><p>Size</p></th><th id="-qfpsgo_12"><p>Stats Age</p></th><th id="-qfpsgo_13"><p>Cache eff.</p></th><th id="-qfpsgo_14"><p>Committed</p></th><th id="-qfpsgo_15"><p>Conflicts</p></th><th id="-qfpsgo_16"><p>Deadlocks</p></th><th id="-qfpsgo_17"><p>Temp. Files</p></th></tr></thead><tbody><tr id="-qfpsgo_18"><td id="-qfpsgo_19"><p>*** TOTAL ***</p></td><td id="-qfpsgo_20"><p>6008 MB (100.00%)</p></td><td id="-qfpsgo_21"><p>null</p></td><td id="-qfpsgo_22"><p>92.36%</p></td><td id="-qfpsgo_23"><p>99.96%</p></td><td id="-qfpsgo_24"><p>0</p></td><td id="-qfpsgo_25"><p>0</p></td><td id="-qfpsgo_26"><p>249 (7899 MB)</p></td></tr><tr id="-qfpsgo_27"><td id="-qfpsgo_28"><p>null</p></td><td id="-qfpsgo_29"><p>null</p></td><td id="-qfpsgo_30"><p>null</p></td><td id="-qfpsgo_31"><p>null</p></td><td id="-qfpsgo_32"><p>null</p></td><td id="-qfpsgo_33"><p>null</p></td><td id="-qfpsgo_34"><p>null</p></td><td id="-qfpsgo_35"><p>null</p></td></tr><tr id="-qfpsgo_36"><td id="-qfpsgo_37"><p>devtestindex</p></td><td id="-qfpsgo_38"><p>5939 MB (98.85%)</p></td><td id="-qfpsgo_39"><p>null</p></td><td id="-qfpsgo_40"><p>92.26%</p></td><td id="-qfpsgo_41"><p>99.85%</p></td><td id="-qfpsgo_42"><p>0</p></td><td id="-qfpsgo_43"><p>0</p></td><td id="-qfpsgo_44"><p>249 (7899 MB)</p></td></tr><tr id="-qfpsgo_45"><td id="-qfpsgo_46"><p>dvdrental</p></td><td id="-qfpsgo_47"><p>15 MB (0.25%)</p></td><td id="-qfpsgo_48"><p>null</p></td><td id="-qfpsgo_49"><p>99.85%</p></td><td id="-qfpsgo_50"><p>99.96%</p></td><td id="-qfpsgo_51"><p>0</p></td><td id="-qfpsgo_52"><p>0</p></td><td id="-qfpsgo_53"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_54"><td id="-qfpsgo_55"><p>testsasist</p></td><td id="-qfpsgo_56"><p>8668 kB (0.14%)</p></td><td id="-qfpsgo_57"><p>null</p></td><td id="-qfpsgo_58"><p>99.93%</p></td><td id="-qfpsgo_59"><p>99.99%</p></td><td id="-qfpsgo_60"><p>0</p></td><td id="-qfpsgo_61"><p>0</p></td><td id="-qfpsgo_62"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_63"><td id="-qfpsgo_64"><p>devtestdatatypes</p></td><td id="-qfpsgo_65"><p>7900 kB (0.13%)</p></td><td id="-qfpsgo_66"><p>null</p></td><td id="-qfpsgo_67"><p>99.81%</p></td><td id="-qfpsgo_68"><p>99.98%</p></td><td id="-qfpsgo_69"><p>0</p></td><td id="-qfpsgo_70"><p>0</p></td><td id="-qfpsgo_71"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_72"><td id="-qfpsgo_73"><p>devtesttablespace</p></td><td id="-qfpsgo_74"><p>7884 kB (0.13%)</p></td><td id="-qfpsgo_75"><p>null</p></td><td id="-qfpsgo_76"><p>99.84%</p></td><td id="-qfpsgo_77"><p>99.91%</p></td><td id="-qfpsgo_78"><p>0</p></td><td id="-qfpsgo_79"><p>0</p></td><td id="-qfpsgo_80"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_81"><td id="-qfpsgo_82"><p>template1</p></td><td id="-qfpsgo_83"><p>7868 kB (0.13%)</p></td><td id="-qfpsgo_84"><p>null</p></td><td id="-qfpsgo_85"><p>99.91%</p></td><td id="-qfpsgo_86"><p>100.00%</p></td><td id="-qfpsgo_87"><p>0</p></td><td id="-qfpsgo_88"><p>0</p></td><td id="-qfpsgo_89"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_90"><td id="-qfpsgo_91"><p>devlearnpg</p></td><td id="-qfpsgo_92"><p>7868 kB (0.13%)</p></td><td id="-qfpsgo_93"><p>null</p></td><td id="-qfpsgo_94"><p>100.00%</p></td><td id="-qfpsgo_95"><p>100.00%</p></td><td id="-qfpsgo_96"><p>0</p></td><td id="-qfpsgo_97"><p>0</p></td><td id="-qfpsgo_98"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_99"><td id="-qfpsgo_100"><p>postgres</p></td><td id="-qfpsgo_101"><p>7844 kB (0.13%)</p></td><td id="-qfpsgo_102"><p>null</p></td><td id="-qfpsgo_103"><p>99.80%</p></td><td id="-qfpsgo_104"><p>99.99%</p></td><td id="-qfpsgo_105"><p>0</p></td><td id="-qfpsgo_106"><p>0</p></td><td id="-qfpsgo_107"><p>0 (0 bytes)</p></td></tr><tr id="-qfpsgo_108"><td id="-qfpsgo_109"><p>template0</p></td><td id="-qfpsgo_110"><p>7673 kB (0.12%)</p></td><td id="-qfpsgo_111"><p>null</p></td><td id="-qfpsgo_112"><p>null</p></td><td id="-qfpsgo_113"><p>null</p></td><td id="-qfpsgo_114"><p>0</p></td><td id="-qfpsgo_115"><p>0</p></td><td id="-qfpsgo_116"><p>0 (0 bytes)</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-qfpsgo_117" data-toc="-qfpsgo_117">Таблицы - размеры, индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables: table/index/TOAST size, number of rows" data-disable-link-processing="true">--Tables: table/index/TOAST size, number of rows

with data as (select c.oid,
                     (select spcname from pg_tablespace where oid = reltablespace) as tblspace,
                     nspname                                                       as schema_name,
                     relname                                                       as table_name,
                     c.reltuples                                                   as row_estimate,
                     pg_total_relation_size(c.oid)                                 as total_bytes,
                     pg_indexes_size(c.oid)                                        as index_bytes,
                     pg_total_relation_size(reltoastrelid)                         as toast_bytes,
                     pg_total_relation_size(c.oid) - pg_indexes_size(c.oid) -
                     coalesce(pg_total_relation_size(reltoastrelid), 0)            as table_bytes
              from pg_class c
                       left join pg_namespace n on n.oid = c.relnamespace
              where relkind = 'r'
                and nspname &lt;&gt; 'pg_catalog'),
     data2 as (select null::oid         as oid,
                      null              as tblspace,
                      null              as schema_name,
                      '*** TOTAL ***'   as table_name,
                      sum(row_estimate) as row_estimate,
                      sum(total_bytes)  as total_bytes,
                      sum(index_bytes)  as index_bytes,
                      sum(toast_bytes)  as toast_bytes,
                      sum(table_bytes)  as table_bytes
               from data
               union all
               select null::oid                                                      as oid,
                      null,
                      null                                                           as schema_name,
                      '    tablespace: [' || coalesce(tblspace, 'pg_default') || ']' as table_name,
                      sum(row_estimate)                                              as row_estimate,
                      sum(total_bytes)                                               as total_bytes,
                      sum(index_bytes)                                               as index_bytes,
                      sum(toast_bytes)                                               as toast_bytes,
                      sum(table_bytes)                                               as table_bytes
               from data
               where (select count(distinct coalesce(tblspace, 'pg_default')) from data) &gt;
                     1 -- don't show this part if there are no custom tablespaces
               group by tblspace
               union all
               select null::oid,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      null
               union all
               select *
               from data)
select coalesce(nullif(schema_name, 'public') || '.', '') || table_name ||
       coalesce(' [' || tblspace || ']', '')                  as &quot;Table&quot;,
       '~' || case
                  when row_estimate &gt; 10 ^ 12 then round(row_estimate::numeric / 10 ^ 12::numeric, 0)::text || 'T'
                  when row_estimate &gt; 10 ^ 9 then round(row_estimate::numeric / 10 ^ 9::numeric, 0)::text || 'B'
                  when row_estimate &gt; 10 ^ 6 then round(row_estimate::numeric / 10 ^ 6::numeric, 0)::text || 'M'
                  when row_estimate &gt; 10 ^ 3 then round(row_estimate::numeric / 10 ^ 3::numeric, 0)::text || 'k'
                  else row_estimate::text
           end                                                as &quot;Rows&quot;,
       pg_size_pretty(total_bytes) || ' (' || round(
               100 * total_bytes::numeric /
               nullif(sum(total_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Total Size&quot;,
       pg_size_pretty(table_bytes) || ' (' || round(
               100 * table_bytes::numeric /
               nullif(sum(table_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Table Size&quot;,
       pg_size_pretty(index_bytes) || ' (' || round(
               100 * index_bytes::numeric /
               nullif(sum(index_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;Index(es) Size&quot;,
       pg_size_pretty(toast_bytes) || ' (' || round(
               100 * toast_bytes::numeric /
               nullif(sum(toast_bytes) over (partition by (schema_name is null), left(table_name, 3) = '***'), 0),
               2
                                              )::text || '%)' as &quot;TOAST Size&quot;
from data2
where schema_name is distinct from 'information_schema'
order by oid is null desc, total_bytes desc nulls last;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_119" data-toc="-qfpsgo_119">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_120"><thead><tr class="ijRowHead" id="-qfpsgo_121"><th id="-qfpsgo_122"><p>Table</p></th><th id="-qfpsgo_123"><p>Rows</p></th><th id="-qfpsgo_124"><p>Total Size</p></th><th id="-qfpsgo_125"><p>Table Size</p></th><th id="-qfpsgo_126"><p>Index(es) Size</p></th><th id="-qfpsgo_127"><p>TOAST Size</p></th></tr></thead><tbody><tr id="-qfpsgo_128"><td id="-qfpsgo_129"><p>*** TOTAL ***</p></td><td id="-qfpsgo_130"><p>~50M</p></td><td id="-qfpsgo_131"><p>5931 MB (100.00%)</p></td><td id="-qfpsgo_132"><p>3973 MB (100.00%)</p></td><td id="-qfpsgo_133"><p>1003 MB (100.00%)</p></td><td id="-qfpsgo_134"><p>955 MB (100.00%)</p></td></tr><tr id="-qfpsgo_135"><td id="-qfpsgo_136"><p>null</p></td><td id="-qfpsgo_137"><p>null</p></td><td id="-qfpsgo_138"><p>null</p></td><td id="-qfpsgo_139"><p>null</p></td><td id="-qfpsgo_140"><p>null</p></td><td id="-qfpsgo_141"><p>null</p></td></tr><tr id="-qfpsgo_142"><td id="-qfpsgo_143"><p>testidx</p></td><td id="-qfpsgo_144"><p>~12M</p></td><td id="-qfpsgo_145"><p>1853 MB (31.25%)</p></td><td id="-qfpsgo_146"><p>1030 MB (25.94%)</p></td><td id="-qfpsgo_147"><p>504 MB (50.29%)</p></td><td id="-qfpsgo_148"><p>318 MB (33.32%)</p></td></tr><tr id="-qfpsgo_149"><td id="-qfpsgo_150"><p>teststat</p></td><td id="-qfpsgo_151"><p>~12M</p></td><td id="-qfpsgo_152"><p>1598 MB (26.95%)</p></td><td id="-qfpsgo_153"><p>1030 MB (25.94%)</p></td><td id="-qfpsgo_154"><p>249 MB (24.85%)</p></td><td id="-qfpsgo_155"><p>318 MB (33.34%)</p></td></tr><tr id="-qfpsgo_156"><td id="-qfpsgo_157"><p>testnoidx</p></td><td id="-qfpsgo_158"><p>~12M</p></td><td id="-qfpsgo_159"><p>1598 MB (26.95%)</p></td><td id="-qfpsgo_160"><p>1030 MB (25.94%)</p></td><td id="-qfpsgo_161"><p>249 MB (24.85%)</p></td><td id="-qfpsgo_162"><p>318 MB (33.34%)</p></td></tr><tr id="-qfpsgo_163"><td id="-qfpsgo_164"><p>t_agg</p></td><td id="-qfpsgo_165"><p>~10M</p></td><td id="-qfpsgo_166"><p>498 MB (8.39%)</p></td><td id="-qfpsgo_167"><p>498 MB (12.53%)</p></td><td id="-qfpsgo_168"><p>0 bytes (0.00%)</p></td><td id="-qfpsgo_169"><p>8192 bytes (0.00%)</p></td></tr><tr id="-qfpsgo_170"><td id="-qfpsgo_171"><p>testtbldata</p></td><td id="-qfpsgo_172"><p>~5M</p></td><td id="-qfpsgo_173"><p>384 MB (6.47%)</p></td><td id="-qfpsgo_174"><p>383 MB (9.65%)</p></td><td id="-qfpsgo_175"><p>0 bytes (0.00%)</p></td><td id="-qfpsgo_176"><p>8192 bytes (0.00%)</p></td></tr><tr id="-qfpsgo_177"><td id="-qfpsgo_178"><p>states</p></td><td id="-qfpsgo_179"><p>~3</p></td><td id="-qfpsgo_180"><p>56 kB (0.00%)</p></td><td id="-qfpsgo_181"><p>40 kB (0.00%)</p></td><td id="-qfpsgo_182"><p>16 kB (0.00%)</p></td><td id="-qfpsgo_183"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-qfpsgo_184" data-toc="-qfpsgo_184">Текущая активность с группировкой по базе</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Current activity: count of current connections grouped by database, user name, state" data-disable-link-processing="true">--Current activity: count of current connections grouped by database, user name, state
select
    coalesce(usename, '** ALL users **') as &quot;User&quot;,
    coalesce(datname, '** ALL databases **') as &quot;DB&quot;,
    coalesce(state, '** ALL states **') as &quot;Current State&quot;,
    count(*) as &quot;Count&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 minute') as &quot;State changed &gt;1m ago&quot;,
    count(*) filter (where state_change &lt; now() - interval '1 hour') as &quot;State changed &gt;1h ago&quot;
from pg_stat_activity
group by grouping sets ((datname, usename, state), (usename, state), ())
order by
    usename is null desc,
    datname is null desc,
    2 asc,
    3 asc,
    count(*) desc
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_186" data-toc="-qfpsgo_186">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_187"><thead><tr class="ijRowHead" id="-qfpsgo_188"><th id="-qfpsgo_189"><p>User</p></th><th id="-qfpsgo_190"><p>DB</p></th><th id="-qfpsgo_191"><p>Current State</p></th><th id="-qfpsgo_192"><p>Count</p></th><th id="-qfpsgo_193"><p>State changed &gt;1m ago</p></th><th id="-qfpsgo_194"><p>State changed &gt;1h ago</p></th></tr></thead><tbody><tr id="-qfpsgo_195"><td id="-qfpsgo_196"><p>** ALL users **</p></td><td id="-qfpsgo_197"><p>** ALL databases **</p></td><td id="-qfpsgo_198"><p>** ALL states **</p></td><td id="-qfpsgo_199"><p>8</p></td><td id="-qfpsgo_200"><p>2</p></td><td id="-qfpsgo_201"><p>2</p></td></tr><tr id="-qfpsgo_202"><td id="-qfpsgo_203"><p>** ALL users **</p></td><td id="-qfpsgo_204"><p>** ALL databases **</p></td><td id="-qfpsgo_205"><p>** ALL states **</p></td><td id="-qfpsgo_206"><p>4</p></td><td id="-qfpsgo_207"><p>0</p></td><td id="-qfpsgo_208"><p>0</p></td></tr><tr id="-qfpsgo_209"><td id="-qfpsgo_210"><p>** ALL users **</p></td><td id="-qfpsgo_211"><p>** ALL databases **</p></td><td id="-qfpsgo_212"><p>** ALL states **</p></td><td id="-qfpsgo_213"><p>4</p></td><td id="-qfpsgo_214"><p>0</p></td><td id="-qfpsgo_215"><p>0</p></td></tr><tr id="-qfpsgo_216"><td id="-qfpsgo_217"><p>postgres</p></td><td id="-qfpsgo_218"><p>** ALL databases **</p></td><td id="-qfpsgo_219"><p>** ALL states **</p></td><td id="-qfpsgo_220"><p>1</p></td><td id="-qfpsgo_221"><p>0</p></td><td id="-qfpsgo_222"><p>0</p></td></tr><tr id="-qfpsgo_223"><td id="-qfpsgo_224"><p>postgres</p></td><td id="-qfpsgo_225"><p>** ALL databases **</p></td><td id="-qfpsgo_226"><p>** ALL states **</p></td><td id="-qfpsgo_227"><p>1</p></td><td id="-qfpsgo_228"><p>0</p></td><td id="-qfpsgo_229"><p>0</p></td></tr><tr id="-qfpsgo_230"><td id="-qfpsgo_231"><p>postgres</p></td><td id="-qfpsgo_232"><p>** ALL databases **</p></td><td id="-qfpsgo_233"><p>active</p></td><td id="-qfpsgo_234"><p>1</p></td><td id="-qfpsgo_235"><p>0</p></td><td id="-qfpsgo_236"><p>0</p></td></tr><tr id="-qfpsgo_237"><td id="-qfpsgo_238"><p>postgres</p></td><td id="-qfpsgo_239"><p>** ALL databases **</p></td><td id="-qfpsgo_240"><p>idle</p></td><td id="-qfpsgo_241"><p>2</p></td><td id="-qfpsgo_242"><p>2</p></td><td id="-qfpsgo_243"><p>2</p></td></tr><tr id="-qfpsgo_244"><td id="-qfpsgo_245"><p>postgres</p></td><td id="-qfpsgo_246"><p>devlearnpg</p></td><td id="-qfpsgo_247"><p>active</p></td><td id="-qfpsgo_248"><p>1</p></td><td id="-qfpsgo_249"><p>0</p></td><td id="-qfpsgo_250"><p>0</p></td></tr><tr id="-qfpsgo_251"><td id="-qfpsgo_252"><p>postgres</p></td><td id="-qfpsgo_253"><p>devtestindex</p></td><td id="-qfpsgo_254"><p>idle</p></td><td id="-qfpsgo_255"><p>1</p></td><td id="-qfpsgo_256"><p>1</p></td><td id="-qfpsgo_257"><p>1</p></td></tr><tr id="-qfpsgo_258"><td id="-qfpsgo_259"><p>postgres</p></td><td id="-qfpsgo_260"><p>devtesttablespace</p></td><td id="-qfpsgo_261"><p>idle</p></td><td id="-qfpsgo_262"><p>1</p></td><td id="-qfpsgo_263"><p>1</p></td><td id="-qfpsgo_264"><p>1</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat-estimated" data-toc="table-bloat-estimated">Table bloat (estimated)</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (estimated)" data-disable-link-processing="true">--Table bloat (estimated)

--This SQL is derived from https://github.com/ioguix/pgsql-bloat-estimation/blob/master/table/table_bloat.sql

/*
* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.
* This query is compatible with PostgreSQL 9.0 and more
*/

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (
    select
        tbl.oid tblid,
        ns.nspname as schema_name,
        tbl.relname as table_name,
        tbl.reltuples,
        tbl.relpages as heappages,
        coalesce(toast.relpages, 0) as toastpages,
        coalesce(toast.reltuples, 0) as toasttuples,
        coalesce(substring(array_to_string(tbl.reloptions, ' ') from '%fillfactor=#&quot;__#&quot;%' for '#')::int2, 100) as fillfactor,
        current_setting('block_size')::numeric as bs,
        case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as ma, -- NS: TODO: check it
        24 as page_hdr,
        23 + case when max(coalesce(null_frac, 0)) &gt; 0 then (7 + count(*)) / 8 else 0::int end
            + case when bool_or(att.attname = 'oid' and att.attnum &lt; 0) then 4 else 0 end as tpl_hdr_size,
        sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) as tpl_data_size,
        bool_or(att.atttypid = 'pg_catalog.name'::regtype)
            or sum(case when att.attnum &gt; 0 then 1 else 0 end) &lt;&gt; count(s.attname) as is_na
    from pg_attribute as att
             join pg_class as tbl on att.attrelid = tbl.oid and tbl.relkind = 'r'
             join pg_namespace as ns on ns.oid = tbl.relnamespace
             join pg_stats as s on s.schemaname = ns.nspname and s.tablename = tbl.relname and not s.inherited and s.attname = att.attname
             left join pg_class as toast on tbl.reltoastrelid = toast.oid
    where not att.attisdropped and s.schemaname not in ('pg_catalog', 'information_schema')
    group by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    order by 2, 3
), step2 as (
    select
        *,
        (
            4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                - case when tpl_hdr_size % ma = 0 then ma else tpl_hdr_size % ma end
                - case when ceil(tpl_data_size)::int % ma = 0 then ma else ceil(tpl_data_size)::int % ma end
            ) as tpl_size,
        bs - page_hdr as size_per_block,
        (heappages + toastpages) as tblpages
    from step1
), step3 as (
    select
        *,
        ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) as est_tblpages,
        ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) + ceil(toasttuples / 4) as est_tblpages_ff
    -- , stattuple.pgstattuple(tblid) as pst
    from step2
), step4 as (
    select
        *,
        tblpages * bs as real_size,
        (tblpages - est_tblpages) * bs as extra_size,
        case when tblpages - est_tblpages &gt; 0 then 100 * (tblpages - est_tblpages) / tblpages::float else 0 end as extra_ratio,
        (tblpages - est_tblpages_ff) * bs as bloat_size,
        case when tblpages - est_tblpages_ff &gt; 0 then 100 * (tblpages - est_tblpages_ff) / tblpages::float else 0 end as bloat_ratio
    -- , (pst).free_percent + (pst).dead_tuple_percent as real_frag
    from step3
             left join pg_stat_user_tables su on su.relid = tblid
    -- WHERE NOT is_na
    --   AND tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 &gt;= 1
)
select
    case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name as &quot;Table&quot;,
    pg_size_pretty(real_size::numeric) as &quot;Size&quot;,
    case
        when extra_size::numeric &gt;= 0
            then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text || '%)'
        else null
        end  as &quot;Extra&quot;,
    case
        when bloat_size::numeric &gt;= 0
            then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text || '%)'
        else null
        end as &quot;Bloat estimate&quot;,
    case
        when (real_size - bloat_size)::numeric &gt;=0
            then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
        else null
        end as &quot;Live&quot;,
    greatest(last_autovacuum, last_vacuum)::timestamp(0)::text
        || case greatest(last_autovacuum, last_vacuum)
               when last_autovacuum then ' (auto)'
               else '' end as &quot;Last Vaccuum&quot;,
    (
        select
            coalesce(substring(array_to_string(reloptions, ' ') from 'fillfactor=([0-9]+)')::smallint, 100)
        from pg_class
        where oid = tblid
    ) as &quot;Fillfactor&quot;
from step4
order by bloat_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_266" data-toc="-qfpsgo_266">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_267"><thead><tr class="ijRowHead" id="-qfpsgo_268"><th id="-qfpsgo_269"><p>Is N/A</p></th><th id="-qfpsgo_270"><p>Table</p></th><th id="-qfpsgo_271"><p>Size</p></th><th id="-qfpsgo_272"><p>Extra</p></th><th id="-qfpsgo_273"><p>Bloat estimate</p></th><th id="-qfpsgo_274"><p>Live</p></th><th id="-qfpsgo_275"><p>Last Vaccuum</p></th><th id="-qfpsgo_276"><p>Fillfactor</p></th></tr></thead><tbody><tr id="-qfpsgo_277"><td id="-qfpsgo_278"></td><td id="-qfpsgo_279"><p>testtbldata</p></td><td id="-qfpsgo_280"><p>383 MB</p></td><td id="-qfpsgo_281"><p>~14 MB (3.75%)</p></td><td id="-qfpsgo_282"><p>~14 MB (3.75%)</p></td><td id="-qfpsgo_283"><p>~369 MB</p></td><td id="-qfpsgo_284"><p>2024-03-25 03:54:41</p></td><td id="-qfpsgo_285"><p>100</p></td></tr><tr id="-qfpsgo_286"><td id="-qfpsgo_287"></td><td id="-qfpsgo_288"><p>t_agg</p></td><td id="-qfpsgo_289"><p>498 MB</p></td><td id="-qfpsgo_290"><p>~256 kB (0.05%)</p></td><td id="-qfpsgo_291"><p>~256 kB (0.05%)</p></td><td id="-qfpsgo_292"><p>~497 MB</p></td><td id="-qfpsgo_293"><p>2024-03-23 02:59:13</p></td><td id="-qfpsgo_294"><p>100</p></td></tr><tr id="-qfpsgo_295"><td id="-qfpsgo_296"></td><td id="-qfpsgo_297"><p>states</p></td><td id="-qfpsgo_298"><p>8192 bytes</p></td><td id="-qfpsgo_299"><p>~0 bytes (0.00%)</p></td><td id="-qfpsgo_300"><p>~0 bytes (0.00%)</p></td><td id="-qfpsgo_301"><p>~8192 bytes</p></td><td id="-qfpsgo_302"><p>2024-03-23 02:59:13</p></td><td id="-qfpsgo_303"><p>100</p></td></tr><tr id="-qfpsgo_304"><td id="-qfpsgo_305"></td><td id="-qfpsgo_306"><p>teststat</p></td><td id="-qfpsgo_307"><p>1344 MB</p></td><td id="-qfpsgo_308"><p>null</p></td><td id="-qfpsgo_309"><p>null</p></td><td id="-qfpsgo_310"><p>~1401 MB</p></td><td id="-qfpsgo_311"><p>2024-03-23 02:59:07</p></td><td id="-qfpsgo_312"><p>100</p></td></tr><tr id="-qfpsgo_313"><td id="-qfpsgo_314"></td><td id="-qfpsgo_315"><p>testidx</p></td><td id="-qfpsgo_316"><p>1344 MB</p></td><td id="-qfpsgo_317"><p>null</p></td><td id="-qfpsgo_318"><p>null</p></td><td id="-qfpsgo_319"><p>~1402 MB</p></td><td id="-qfpsgo_320"><p>2024-03-23 02:58:46</p></td><td id="-qfpsgo_321"><p>100</p></td></tr><tr id="-qfpsgo_322"><td id="-qfpsgo_323"></td><td id="-qfpsgo_324"><p>testnoidx</p></td><td id="-qfpsgo_325"><p>1344 MB</p></td><td id="-qfpsgo_326"><p>null</p></td><td id="-qfpsgo_327"><p>null</p></td><td id="-qfpsgo_328"><p>~1403 MB</p></td><td id="-qfpsgo_329"><p>2024-03-23 02:58:56</p></td><td id="-qfpsgo_330"><p>100</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-index-bloat" data-toc="b-tree-index-bloat">B-tree index bloat</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree index bloat (estimated)" data-disable-link-processing="true">--B-tree index bloat (estimated)

-- enhanced version of https://github.com/ioguix/pgsql-bloat-estimation/blob/master/btree/btree_bloat.sql

-- WARNING: executed with a non-superuser role, the query inspect only index on tables you are granted to read.
-- WARNING: rows with is_na = 't' are known to have bad statistics (&quot;name&quot; type is not supported).
-- This query is compatible with PostgreSQL 8.2+

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with step1 as (select i.nspname                                                                        as schema_name,
                      i.tblname                                                                        as table_name,
                      i.idxname                                                                        as index_name,
                      i.reltuples,
                      i.relpages,
                      i.relam,
                      a.attrelid                                                                       AS table_oid,
                      current_setting('block_size')::numeric                                           AS bs,
                      fillfactor,
                      -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                      case when version() ~ 'mingw32|64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as maxalign,
                   /* per page header, fixed size: 20 for 7.X, 24 for others */
                      24                                                                               AS pagehdr,
                   /* per page btree opaque data */
                      16                                                                               AS pageopqdata,
                   /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                      case
                          when max(coalesce(s.null_frac, 0)) = 0 then 2 -- IndexTupleData size
                          else 2 + ((32 + 8 - 1) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                          end                                                                          as index_tuple_hdr_bm,
                   /* data len: we remove null values save space using it fractionnal part from stats */
                      sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024))                as nulldatawidth,
                      max(case when a.atttypid = 'pg_catalog.name'::regtype then 1 else 0 end) &gt; 0     as is_na
               from pg_attribute as a
                        join (select nspname,
                                     tbl.relname                                              AS tblname,
                                     idx.relname                                              AS idxname,
                                     idx.reltuples,
                                     idx.relpages,
                                     idx.relam,
                                     indrelid,
                                     indexrelid,
                                     indkey::smallint[]                                       AS attnum,
                                     coalesce(substring(array_to_string(idx.reloptions, ' ') from
                                                        'fillfactor=([0-9]+)')::smallint, 90) as fillfactor
                              from pg_index
                                       join pg_class idx on idx.oid = pg_index.indexrelid
                                       join pg_class tbl on tbl.oid = pg_index.indrelid
                                       join pg_namespace on pg_namespace.oid = idx.relnamespace
                              where pg_index.indisvalid
                                AND tbl.relkind = 'r'
                                AND idx.relpages &gt; 0) as i on a.attrelid = i.indexrelid
                        join pg_stats as s on
                   s.schemaname = i.nspname
                       and (
                       (s.tablename = i.tblname and
                        s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, true)) -- stats from tbl
                           OR (s.tablename = i.idxname AND s.attname = a.attname) -- stats from functionnal cols
                       )
                        join pg_type as t on a.atttypid = t.oid
               where a.attnum &gt; 0
               group by 1, 2, 3, 4, 5, 6, 7, 8, 9),
     step2 as (select *,
                      (
                          index_tuple_hdr_bm + maxalign
                              -- Add padding to the index tuple header to align on MAXALIGN
                              - case
                                    when index_tuple_hdr_bm % maxalign = 0 THEN maxalign
                                    else index_tuple_hdr_bm % maxalign end
                              + nulldatawidth + maxalign
                              -- Add padding to the data to align on MAXALIGN
                              - case
                                    when nulldatawidth = 0 then 0
                                    when nulldatawidth::integer % maxalign = 0 then maxalign
                                    else nulldatawidth::integer % maxalign
                              end
                          )::numeric as nulldatahdrwidth
               -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
               from step1),
     step3 as (select *,
                      -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
                      coalesce(
                              1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::float)),
                              0)                                                                      as est_pages,
                      coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) * fillfactor /
                                                          (100 * (4 + nulldatahdrwidth)::float))), 0) as est_pages_ff
               -- , stattuple.pgstatindex(quote_ident(nspname)||'.'||quote_ident(idxname)) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
               from step2
                        join pg_am am on step2.relam = am.oid
               where am.amname = 'btree'),
     step4 as (SELECT *,
                      bs * (relpages)::bigint                           AS real_size,
-------current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,
                      bs * (relpages - est_pages)::bigint               AS extra_size,
                      100 * (relpages - est_pages)::float / relpages    AS extra_ratio,
                      bs * (relpages - est_pages_ff)                    AS bloat_size,
                      100 * (relpages - est_pages_ff)::float / relpages AS bloat_ratio
               -- , 100-(sub.pst).avg_leaf_density, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, sub.reltuples, sub.relpages -- (DEBUG INFO)
               from step3
         -- WHERE NOT is_na
     )
select case is_na when true then 'TRUE' else '' end as &quot;Is N/A&quot;,
       format(
               $out$%s
  (%s)$out$,
               left(index_name, 50) || case when length(index_name) &gt; 50 then '…' else '' end,
               coalesce(nullif(schema_name, 'public') || '.', '') || table_name
       )                                            as &quot;Index (Table)&quot;,
       pg_size_pretty(real_size::numeric)           as &quot;Size&quot;,
       case
           when extra_size::numeric &gt;= 0
               then '~' || pg_size_pretty(extra_size::numeric)::text || ' (' || round(extra_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Extra&quot;,
       case
           when bloat_size::numeric &gt;= 0
               then '~' || pg_size_pretty(bloat_size::numeric)::text || ' (' || round(bloat_ratio::numeric, 2)::text ||
                    '%)'
           else null
           end                                      as &quot;Bloat&quot;,
       case
           when (real_size - bloat_size)::numeric &gt;= 0
               then '~' || pg_size_pretty((real_size - bloat_size)::numeric)
           else null
           end                                      as &quot;Live&quot;,
       fillfactor
from step4
order by real_size desc nulls last
;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_332" data-toc="-qfpsgo_332">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_333"><thead><tr class="ijRowHead" id="-qfpsgo_334"><th id="-qfpsgo_335"><p>Is N/A</p></th><th id="-qfpsgo_336"><p>Index (Table)</p></th><th id="-qfpsgo_337"><p>Size</p></th><th id="-qfpsgo_338"><p>Extra</p></th><th id="-qfpsgo_339"><p>Bloat</p></th><th id="-qfpsgo_340"><p>Live</p></th><th id="-qfpsgo_341"><p>fillfactor</p></th></tr></thead><tbody><tr id="-qfpsgo_342"><td id="-qfpsgo_343"></td><td id="-qfpsgo_344"><p>teststat_pkey</p><br><p> (teststat)</p></td><td id="-qfpsgo_346"><p>249 MB</p></td><td id="-qfpsgo_347"><p>~26 MB (10.39%)</p></td><td id="-qfpsgo_348"><p>~904 kB (0.35%)</p></td><td id="-qfpsgo_349"><p>~248 MB</p></td><td id="-qfpsgo_350"><p>90</p></td></tr><tr id="-qfpsgo_351"><td id="-qfpsgo_352"></td><td id="-qfpsgo_353"><p>testidx_copy1_pkey</p><br><p> (testnoidx)</p></td><td id="-qfpsgo_355"><p>249 MB</p></td><td id="-qfpsgo_356"><p>~26 MB (10.29%)</p></td><td id="-qfpsgo_357"><p>~624 kB (0.24%)</p></td><td id="-qfpsgo_358"><p>~249 MB</p></td><td id="-qfpsgo_359"><p>90</p></td></tr><tr id="-qfpsgo_360"><td id="-qfpsgo_361"></td><td id="-qfpsgo_362"><p>testidx_pk</p><br><p> (testidx)</p></td><td id="-qfpsgo_364"><p>225 MB</p></td><td id="-qfpsgo_365"><p>~1328 kB (0.58%)</p></td><td id="-qfpsgo_366"><p>~1328 kB (0.58%)</p></td><td id="-qfpsgo_367"><p>~223 MB</p></td><td id="-qfpsgo_368"><p>100</p></td></tr><tr id="-qfpsgo_369"><td id="-qfpsgo_370"></td><td id="-qfpsgo_371"><p>testidx_created_at_index</p><br><p> (testidx)</p></td><td id="-qfpsgo_373"><p>165 MB</p></td><td id="-qfpsgo_374"><p>~15 MB (9.10%)</p></td><td id="-qfpsgo_375"><p>null</p></td><td id="-qfpsgo_376"><p>~167 MB</p></td><td id="-qfpsgo_377"><p>90</p></td></tr><tr id="-qfpsgo_378"><td id="-qfpsgo_379"></td><td id="-qfpsgo_380"><p>testidx_fk_id_index</p><br><p> (testidx)</p></td><td id="-qfpsgo_382"><p>114 MB</p></td><td id="-qfpsgo_383"><p>null</p></td><td id="-qfpsgo_384"><p>null</p></td><td id="-qfpsgo_385"><p>~247 MB</p></td><td id="-qfpsgo_386"><p>90</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="table-bloat" data-toc="table-bloat">Table bloat</h2><p id="-qfpsgo_387">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-qfpsgo_388" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Table bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--Table bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without table name/mask query will read all available tables which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

select nspname,
       relname,
       pg_size_pretty(relation_size + toast_relation_size) as                                    total_size,
       pg_size_pretty(toast_relation_size)                 as                                    toast_size,
       round(((relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size, 1))::numeric, 1)                                           table_waste_percent,
       pg_size_pretty((relation_size - (relation_size - free_space) * 100 / fillfactor)::bigint) table_waste,
       round(((toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) * 100 /
              greatest(relation_size + toast_relation_size, 1))::numeric, 1)                     total_waste_percent,
       pg_size_pretty((toast_free_space + relation_size -
                       (relation_size - free_space) * 100 / fillfactor)::bigint)                 total_waste
from (select nspname,
             relname,
             (select free_space from pgstattuple(c.oid))                                                         as free_space,
             pg_relation_size(c.oid)                                                                             as relation_size,
             (case
                  when reltoastrelid = 0 then 0
                  else (select free_space from pgstattuple(c.reltoastrelid)) end)                                as toast_free_space,
             coalesce(pg_relation_size(c.reltoastrelid), 0)                                                      as toast_relation_size,
             coalesce((SELECT (regexp_matches(reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),
                      '100')::real                                                                               AS fillfactor
      from pg_class c
               left join pg_namespace n on (n.oid = c.relnamespace)
      where nspname not in ('pg_catalog', 'information_schema')
        and nspname !~ '^pg_toast'
        and relkind = 'r'
        --put your table name/mask here
        and relname ~ '') t
order by (toast_free_space + relation_size - (relation_size - free_space) * 100 / fillfactor) desc
limit 20;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_391" data-toc="-qfpsgo_391">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_392"><thead><tr class="ijRowHead" id="-qfpsgo_393"><th id="-qfpsgo_394"><p>nspname</p></th><th id="-qfpsgo_395"><p>relname</p></th><th id="-qfpsgo_396"><p>total_size</p></th><th id="-qfpsgo_397"><p>toast_size</p></th><th id="-qfpsgo_398"><p>table_waste_percent</p></th><th id="-qfpsgo_399"><p>table_waste</p></th><th id="-qfpsgo_400"><p>total_waste_percent</p></th><th id="-qfpsgo_401"><p>total_waste</p></th></tr></thead><tbody><tr id="-qfpsgo_402"><td id="-qfpsgo_403"><p>public</p></td><td id="-qfpsgo_404"><p>teststat</p></td><td id="-qfpsgo_405"><p>1344 MB</p></td><td id="-qfpsgo_406"><p>314 MB</p></td><td id="-qfpsgo_407"><p>0.5</p></td><td id="-qfpsgo_408"><p>4829 kB</p></td><td id="-qfpsgo_409"><p>2.3</p></td><td id="-qfpsgo_410"><p>31 MB</p></td></tr><tr id="-qfpsgo_411"><td id="-qfpsgo_412"><p>public</p></td><td id="-qfpsgo_413"><p>testnoidx</p></td><td id="-qfpsgo_414"><p>1344 MB</p></td><td id="-qfpsgo_415"><p>314 MB</p></td><td id="-qfpsgo_416"><p>0.5</p></td><td id="-qfpsgo_417"><p>4829 kB</p></td><td id="-qfpsgo_418"><p>2.3</p></td><td id="-qfpsgo_419"><p>30 MB</p></td></tr><tr id="-qfpsgo_420"><td id="-qfpsgo_421"><p>public</p></td><td id="-qfpsgo_422"><p>testidx</p></td><td id="-qfpsgo_423"><p>1344 MB</p></td><td id="-qfpsgo_424"><p>314 MB</p></td><td id="-qfpsgo_425"><p>0.5</p></td><td id="-qfpsgo_426"><p>4829 kB</p></td><td id="-qfpsgo_427"><p>2.3</p></td><td id="-qfpsgo_428"><p>30 MB</p></td></tr><tr id="-qfpsgo_429"><td id="-qfpsgo_430"><p>public</p></td><td id="-qfpsgo_431"><p>testtbldata</p></td><td id="-qfpsgo_432"><p>383 MB</p></td><td id="-qfpsgo_433"><p>0 bytes</p></td><td id="-qfpsgo_434"><p>0.4</p></td><td id="-qfpsgo_435"><p>1746 kB</p></td><td id="-qfpsgo_436"><p>0.4</p></td><td id="-qfpsgo_437"><p>1746 kB</p></td></tr><tr id="-qfpsgo_438"><td id="-qfpsgo_439"><p>public</p></td><td id="-qfpsgo_440"><p>states</p></td><td id="-qfpsgo_441"><p>8192 bytes</p></td><td id="-qfpsgo_442"><p>0 bytes</p></td><td id="-qfpsgo_443"><p>97.7</p></td><td id="-qfpsgo_444"><p>8000 bytes</p></td><td id="-qfpsgo_445"><p>97.7</p></td><td id="-qfpsgo_446"><p>8000 bytes</p></td></tr><tr id="-qfpsgo_447"><td id="-qfpsgo_448"><p>public</p></td><td id="-qfpsgo_449"><p>t_agg</p></td><td id="-qfpsgo_450"><p>498 MB</p></td><td id="-qfpsgo_451"><p>0 bytes</p></td><td id="-qfpsgo_452"><p>0</p></td><td id="-qfpsgo_453"><p>5996 bytes</p></td><td id="-qfpsgo_454"><p>0</p></td><td id="-qfpsgo_455"><p>5996 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="b-tree-indexes-bloat" data-toc="b-tree-indexes-bloat">B-tree indexes bloat</h2><p id="-qfpsgo_456">Требуется модуль <a href="https://postgrespro.ru/docs/postgrespro/16/pgstattuple" id="-qfpsgo_457" data-external="true" rel="noopener noreferrer">pgstattuple</a></p><div class="code-block" data-lang="sql">
create extension if not exists pgstattuple;
</div><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--B-tree indexes bloat (requires pgstattuple; expensive)" data-disable-link-processing="true">--B-tree indexes bloat (requires pgstattuple; expensive)

--https://github.com/dataegret/pg-utils/tree/master/sql
--pgstattuple extension required
--WARNING: without index name/mask query will read all available indexes which could cause I/O spikes

/*
Оригинал скрипта
https://github.com/NikolayS/postgres_dba/
*/

with data as (
    select
        schemaname as schema_name,
        p.relname as table_name,
        (select spcname from pg_tablespace where oid = c_table.reltablespace) as table_tblspace,
        (select spcname from pg_tablespace where oid = c.reltablespace) as index_tblspace,
        indexrelname as index_name,
        (
            select (case when avg_leaf_density = 'NaN' then 0
                         else greatest(ceil(index_size * (1 - avg_leaf_density / (coalesce((SELECT (regexp_matches(c.reloptions::text, E'.*fillfactor=(\\d+).*'))[1]),'90')::real)))::bigint, 0) end)
            from pgstatindex(
                    case when p.indexrelid::regclass::text ~ '\.' then p.indexrelid::regclass::text else schemaname || '.' || p.indexrelid::regclass::text end
                 )
        ) as free_space,
        pg_relation_size(p.indexrelid) as index_size,
        pg_relation_size(p.relid) as table_size,
        idx_scan
    from pg_stat_user_indexes p
             join pg_class c on p.indexrelid = c.oid
             join pg_class c_table on p.relid = c_table.oid
    where
        pg_get_indexdef(p.indexrelid) like '%USING btree%'
      --put your index name/mask here
      and indexrelname ~ ''
)
select
    coalesce(nullif(schema_name, 'public') || '.', '') || table_name || coalesce(' [' || table_tblspace || ']', '') as &quot;Table&quot;,
    coalesce(nullif(schema_name, 'public') || '.', '') || index_name || coalesce(' [' || index_tblspace || ']', '') as &quot;Index&quot;,
    pg_size_pretty(table_size) as &quot;Table size&quot;,
    pg_size_pretty(index_size) as &quot;Index size&quot;,
    idx_scan as &quot;Index Scans&quot;,
    round((free_space*100/index_size)::numeric, 1) as &quot;Wasted, %&quot;,
    pg_size_pretty(free_space) as &quot;Wasted&quot;
from data
order by free_space desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_460" data-toc="-qfpsgo_460">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_461"><thead><tr class="ijRowHead" id="-qfpsgo_462"><th id="-qfpsgo_463"><p>Table</p></th><th id="-qfpsgo_464"><p>Index</p></th><th id="-qfpsgo_465"><p>Table size</p></th><th id="-qfpsgo_466"><p>Index size</p></th><th id="-qfpsgo_467"><p>Index Scans</p></th><th id="-qfpsgo_468"><p>Wasted, %</p></th><th id="-qfpsgo_469"><p>Wasted</p></th></tr></thead><tbody><tr id="-qfpsgo_470"><td id="-qfpsgo_471"><p>testidx</p></td><td id="-qfpsgo_472"><p>testidx_pk</p></td><td id="-qfpsgo_473"><p>1030 MB</p></td><td id="-qfpsgo_474"><p>225 MB</p></td><td id="-qfpsgo_475"><p>17240064</p></td><td id="-qfpsgo_476"><p>0</p></td><td id="-qfpsgo_477"><p>230 kB</p></td></tr><tr id="-qfpsgo_478"><td id="-qfpsgo_479"><p>states</p></td><td id="-qfpsgo_480"><p>states_pkey</p></td><td id="-qfpsgo_481"><p>8192 bytes</p></td><td id="-qfpsgo_482"><p>16 kB</p></td><td id="-qfpsgo_483"><p>3</p></td><td id="-qfpsgo_484"><p>99</p></td><td id="-qfpsgo_485"><p>16 kB</p></td></tr><tr id="-qfpsgo_486"><td id="-qfpsgo_487"><p>testnoidx</p></td><td id="-qfpsgo_488"><p>testidx_copy1_pkey</p></td><td id="-qfpsgo_489"><p>1030 MB</p></td><td id="-qfpsgo_490"><p>249 MB</p></td><td id="-qfpsgo_491"><p>2</p></td><td id="-qfpsgo_492"><p>0</p></td><td id="-qfpsgo_493"><p>0 bytes</p></td></tr><tr id="-qfpsgo_494"><td id="-qfpsgo_495"><p>teststat</p></td><td id="-qfpsgo_496"><p>teststat_pkey</p></td><td id="-qfpsgo_497"><p>1030 MB</p></td><td id="-qfpsgo_498"><p>249 MB</p></td><td id="-qfpsgo_499"><p>8620000</p></td><td id="-qfpsgo_500"><p>0</p></td><td id="-qfpsgo_501"><p>0 bytes</p></td></tr><tr id="-qfpsgo_502"><td id="-qfpsgo_503"><p>testidx</p></td><td id="-qfpsgo_504"><p>testidx_fk_id_index</p></td><td id="-qfpsgo_505"><p>1030 MB</p></td><td id="-qfpsgo_506"><p>114 MB</p></td><td id="-qfpsgo_507"><p>549</p></td><td id="-qfpsgo_508"><p>0</p></td><td id="-qfpsgo_509"><p>0 bytes</p></td></tr><tr id="-qfpsgo_510"><td id="-qfpsgo_511"><p>testidx</p></td><td id="-qfpsgo_512"><p>testidx_created_at_index</p></td><td id="-qfpsgo_513"><p>1030 MB</p></td><td id="-qfpsgo_514"><p>165 MB</p></td><td id="-qfpsgo_515"><p>41</p></td><td id="-qfpsgo_516"><p>0</p></td><td id="-qfpsgo_517"><p>0 bytes</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="tables-and-columns-without-stats" data-toc="tables-and-columns-without-stats">Tables and columns without stats</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Tables and columns without stats" data-disable-link-processing="true">--Tables and columns without stats
--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/bloat/no_stats_table_check.sql

SELECT table_schema, table_name,
       ( pg_class.relpages = 0 ) AS is_empty,
       ( psut.relname IS NULL OR ( psut.last_analyze IS NULL and psut.last_autoanalyze IS NULL ) ) AS never_analyzed,
       array_agg(column_name::TEXT) as no_stats_columns
FROM information_schema.columns
         JOIN pg_class ON columns.table_name = pg_class.relname
    AND pg_class.relkind = 'r'
         JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
    AND nspname = table_schema
         LEFT OUTER JOIN pg_stats
                         ON table_schema = pg_stats.schemaname
                             AND table_name = pg_stats.tablename
                             AND column_name = pg_stats.attname
         LEFT OUTER JOIN pg_stat_user_tables AS psut
                         ON table_schema = psut.schemaname
                             AND table_name = psut.relname
WHERE pg_stats.attname IS NULL
  AND table_schema NOT IN ('pg_catalog', 'information_schema')
GROUP BY table_schema, table_name, relpages, psut.relname, last_analyze, last_autoanalyze;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_519" data-toc="-qfpsgo_519">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_520"><thead><tr class="ijRowHead" id="-qfpsgo_521"><th id="-qfpsgo_522"><p>table_schema</p></th><th id="-qfpsgo_523"><p>table_name</p></th><th id="-qfpsgo_524"><p>is_empty</p></th><th id="-qfpsgo_525"><p>never_analyzed</p></th><th id="-qfpsgo_526"><p>no_stats_columns</p></th></tr></thead><tbody><tr id="-qfpsgo_527"><td id="-qfpsgo_528"><p>public</p></td><td id="-qfpsgo_529"><p>category</p></td><td id="-qfpsgo_530"><p>false</p></td><td id="-qfpsgo_531"><p>true</p></td><td id="-qfpsgo_532"><p>{name,category_id,last_update}</p></td></tr><tr id="-qfpsgo_533"><td id="-qfpsgo_534"><p>public</p></td><td id="-qfpsgo_535"><p>language</p></td><td id="-qfpsgo_536"><p>false</p></td><td id="-qfpsgo_537"><p>true</p></td><td id="-qfpsgo_538"><p>{last_update,name,language_id}</p></td></tr><tr id="-qfpsgo_539"><td id="-qfpsgo_540"><p>public</p></td><td id="-qfpsgo_541"><p>staff</p></td><td id="-qfpsgo_542"><p>false</p></td><td id="-qfpsgo_543"><p>true</p></td><td id="-qfpsgo_544"><p>{password,username,staff_id,first_name,email,last_name,picture,last_update,active,store_id,address_id}</p></td></tr><tr id="-qfpsgo_545"><td id="-qfpsgo_546"><p>public</p></td><td id="-qfpsgo_547"><p>store</p></td><td id="-qfpsgo_548"><p>false</p></td><td id="-qfpsgo_549"><p>true</p></td><td id="-qfpsgo_550"><p>{last_update,manager_staff_id,address_id,store_id}</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-qfpsgo_551" data-toc="-qfpsgo_551">Неиспользуемые и редко используемые индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Unused and rarely used indexes" data-disable-link-processing="true">--Unused and rarely used indexes

--PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/unused_indexes.sql

WITH table_scans as (
    SELECT relid,
           tables.idx_scan + tables.seq_scan as all_scans,
           ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
           pg_relation_size(relid) as table_size
    FROM pg_stat_user_tables as tables
),
     all_writes as (
         SELECT sum(writes) as total_writes
         FROM table_scans
     ),
     indexes as (
         SELECT idx_stat.relid, idx_stat.indexrelid,
                idx_stat.schemaname, idx_stat.relname as tablename,
                idx_stat.indexrelname as indexname,
                idx_stat.idx_scan,
                pg_relation_size(idx_stat.indexrelid) as index_bytes,
                indexdef ~* 'USING btree' AS idx_is_btree
         FROM pg_stat_user_indexes as idx_stat
                  JOIN pg_index
                       USING (indexrelid)
                  JOIN pg_indexes as indexes
                       ON idx_stat.schemaname = indexes.schemaname
                           AND idx_stat.relname = indexes.tablename
                           AND idx_stat.indexrelname = indexes.indexname
         WHERE pg_index.indisunique = FALSE
     ),
     index_ratios AS (
         SELECT schemaname, tablename, indexname,
                idx_scan, all_scans,
                round(( CASE WHEN all_scans = 0 THEN 0.0::NUMERIC
                             ELSE idx_scan::NUMERIC/all_scans * 100 END),2) as index_scan_pct,
                writes,
                round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2)
                                                                            as scans_per_write,
                pg_size_pretty(index_bytes) as index_size,
                pg_size_pretty(table_size) as table_size,
                idx_is_btree, index_bytes
         FROM indexes
                  JOIN table_scans
                       USING (relid)
     ),
     index_groups AS (
         SELECT 'Never Used Indexes' as reason, *, 1 as grp
         FROM index_ratios
         WHERE
             idx_scan = 0
           and idx_is_btree
         UNION ALL
         SELECT 'Low Scans, High Writes' as reason, *, 2 as grp
         FROM index_ratios
         WHERE
             scans_per_write &lt;= 1
           and index_scan_pct &lt; 10
           and idx_scan &gt; 0
           and writes &gt; 100
           and idx_is_btree
         UNION ALL
         SELECT 'Seldom Used Large Indexes' as reason, *, 3 as grp
         FROM index_ratios
         WHERE
             index_scan_pct &lt; 5
           and scans_per_write &gt; 1
           and idx_scan &gt; 0
           and idx_is_btree
           and index_bytes &gt; 100000000
         UNION ALL
         SELECT 'High-Write Large Non-Btree' as reason, index_ratios.*, 4 as grp
         FROM index_ratios, all_writes
         WHERE
             ( writes::NUMERIC / ( total_writes + 1 ) ) &gt; 0.02
           AND NOT idx_is_btree
           AND index_bytes &gt; 100000000
         ORDER BY grp, index_bytes DESC )
SELECT
    reason,
    schemaname as schema_name,
    tablename as table_name,
    indexname as index_name,
    index_scan_pct,
    scans_per_write,
    index_size,
    table_size,
    idx_scan,
    all_scans
FROM index_groups;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_553" data-toc="-qfpsgo_553">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_554"><thead><tr class="ijRowHead" id="-qfpsgo_555"><th id="-qfpsgo_556"><p>reason</p></th><th id="-qfpsgo_557"><p>schema_name</p></th><th id="-qfpsgo_558"><p>table_name</p></th><th id="-qfpsgo_559"><p>index_name</p></th><th id="-qfpsgo_560"><p>index_scan_pct</p></th><th id="-qfpsgo_561"><p>scans_per_write</p></th><th id="-qfpsgo_562"><p>index_size</p></th><th id="-qfpsgo_563"><p>table_size</p></th><th id="-qfpsgo_564"><p>idx_scan</p></th><th id="-qfpsgo_565"><p>all_scans</p></th></tr></thead><tbody><tr id="-qfpsgo_566"><td id="-qfpsgo_567"><p>Low Scans, High Writes</p></td><td id="-qfpsgo_568"><p>public</p></td><td id="-qfpsgo_569"><p>testidx</p></td><td id="-qfpsgo_570"><p>testidx_created_at_index</p></td><td id="-qfpsgo_571"><p>0</p></td><td id="-qfpsgo_572"><p>0</p></td><td id="-qfpsgo_573"><p>165 MB</p></td><td id="-qfpsgo_574"><p>1030 MB</p></td><td id="-qfpsgo_575"><p>41</p></td><td id="-qfpsgo_576"><p>17240843</p></td></tr><tr id="-qfpsgo_577"><td id="-qfpsgo_578"><p>Low Scans, High Writes</p></td><td id="-qfpsgo_579"><p>public</p></td><td id="-qfpsgo_580"><p>testidx</p></td><td id="-qfpsgo_581"><p>testidx_fk_id_index</p></td><td id="-qfpsgo_582"><p>0</p></td><td id="-qfpsgo_583"><p>0</p></td><td id="-qfpsgo_584"><p>114 MB</p></td><td id="-qfpsgo_585"><p>1030 MB</p></td><td id="-qfpsgo_586"><p>549</p></td><td id="-qfpsgo_587"><p>17240843</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-qfpsgo_588" data-toc="-qfpsgo_588">Избыточные индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Redundant indexes" data-disable-link-processing="true">--Redundant indexes

-- Use it to see redundant indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

with fk_indexes as (
    select
        n.nspname as schema_name,
        ci.relname as index_name,
        cr.relname as table_name,
        (confrelid::regclass)::text as fk_table_ref,
        array_to_string(indclass, ', ') as opclasses
    from pg_index i
             join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
             join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
             join pg_namespace n on n.oid = ci.relnamespace
             join pg_constraint cn on cn.conrelid = cr.oid
             left join pg_stat_user_indexes si on si.indexrelid = i.indexrelid
    where
        contype = 'f'
      and i.indisunique is false
      and conkey is not null
      and ci.relpages &gt; 0 -- raise for a DB with a lot of indexes
      and si.idx_scan &lt; 10
),
-- Redundant indexes
     index_data as (
         select
             *,
             (select string_agg(lpad(i, 3, '0'), ' ') from unnest(string_to_array(indkey::text, ' ')) i) as columns,
             array_to_string(indclass, ', ') as opclasses
         from pg_index i
                  join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
         where indisvalid = true and ci.relpages &gt; 0 -- raise for a DD with a lot of indexes
     ), redundant_indexes as (
    select
        i2.indexrelid as index_id,
        tnsp.nspname AS schema_name,
        trel.relname AS table_name,
        pg_relation_size(trel.oid) as table_size_bytes,
        irel.relname AS index_name,
        am1.amname as access_method,
        (i1.indexrelid::regclass)::text as reason,
        i1.indexrelid as reason_index_id,
        pg_get_indexdef(i1.indexrelid) main_index_def,
        pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size,
        pg_get_indexdef(i2.indexrelid) index_def,
        pg_relation_size(i2.indexrelid) index_size_bytes,
        s.idx_scan as index_usage,
        quote_ident(tnsp.nspname) as formated_schema_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) as formated_index_name,
        quote_ident(trel.relname) AS formated_table_name,
        coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) as formated_relation_name,
        i2.opclasses
    from
        index_data as i1
            join index_data as i2 on (
            i1.indrelid = i2.indrelid -- same table
                and i1.indexrelid &lt;&gt; i2.indexrelid -- NOT same index
            )
            inner join pg_opclass op1 on i1.indclass[0] = op1.oid
            inner join pg_opclass op2 on i2.indclass[0] = op2.oid
            inner join pg_am am1 on op1.opcmethod = am1.oid
            inner join pg_am am2 on op2.opcmethod = am2.oid
            join pg_stat_user_indexes as s on s.indexrelid = i2.indexrelid
            join pg_class as trel on trel.oid = i2.indrelid
            join pg_namespace as tnsp on trel.relnamespace = tnsp.oid
            join pg_class as irel on irel.oid = i2.indexrelid
    where
        not i2.indisprimary -- index 1 is not primary
      and not ( -- skip if index1 is (primary or uniq) and is NOT (primary and uniq)
        i2.indisunique and not i1.indisprimary
        )
      and am1.amname = am2.amname -- same access type
      and i1.columns like (i2.columns || '%') -- index 2 includes all columns from index 1
      and i1.opclasses like (i2.opclasses || '%')
      -- index expressions is same
      and pg_get_expr(i1.indexprs, i1.indrelid) is not distinct from pg_get_expr(i2.indexprs, i2.indrelid)
      -- index predicates is same
      and pg_get_expr(i1.indpred, i1.indrelid) is not distinct from pg_get_expr(i2.indpred, i2.indrelid)
), redundant_indexes_fk as (
    select
        ri.*,
        (
            select count(1)
            from fk_indexes fi
            where
                fi.fk_table_ref = ri.table_name
              and fi.opclasses like (ri.opclasses || '%')
        ) &gt; 0 as supports_fk
    from redundant_indexes ri
),
-- Cut recursive links
     redundant_indexes_tmp_num as (
         select
                     row_number() over () num,
                     rig.*
         from redundant_indexes_fk rig
         order by index_id
     ), redundant_indexes_tmp_cut as (
    select
        ri1.*,
        ri2.num as r_num
    from redundant_indexes_tmp_num ri1
             left join redundant_indexes_tmp_num ri2 on ri2.reason_index_id = ri1.index_id and ri1.reason_index_id = ri2.index_id
    where ri1.num &lt; ri2.num or ri2.num is null
), redundant_indexes_cut_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
), redundant_indexes_grouped as (
    select
        distinct(num),
                *
    from redundant_indexes_tmp_cut
    order by index_size_bytes desc
)
select
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    string_agg(distinct reason, ', ') as redundant_to,
    string_agg(main_index_def, ', ') as main_index_def,
    string_agg(main_index_size, ', ') as main_index_size,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
from redundant_indexes_cut_grouped
group by
    index_id,
    schema_name,
    table_name,
    table_size_bytes,
    index_name,
    access_method,
    index_def,
    index_size_bytes,
    index_usage,
    supports_fk
order by index_size_bytes desc;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_590" data-toc="-qfpsgo_590">Результат</h3></div><div class="collapse__content"><p id="-qfpsgo_591">TODO: добавить пример!</p></div></div></section></section><section class="chapter"><h2 id="fk" data-toc="fk">FK и отсутствующие индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--FKs with Missing/Bad Indexes" data-disable-link-processing="true">--FKs with Missing/Bad Indexes

--Created by PostgreSQL Experts https://github.com/pgexperts/pgx_scripts/blob/master/indexes/fk_no_index.sql

-- check for FKs where there is no matching index
-- on the referencing side
-- or a bad index

with fk_actions ( code, action ) as (
    values ('a', 'error'),
           ('r', 'restrict'),
           ('c', 'cascade'),
           ('n', 'set null'),
           ('d', 'set default')
), fk_list as (
    select
        pg_constraint.oid as fkoid, conrelid, confrelid as parentid,
        conname,
        relname,
        nspname,
        fk_actions_update.action as update_action,
        fk_actions_delete.action as delete_action,
        conkey as key_cols
    from pg_constraint
             join pg_class on conrelid = pg_class.oid
             join pg_namespace on pg_class.relnamespace = pg_namespace.oid
             join fk_actions as fk_actions_update on confupdtype = fk_actions_update.code
             join fk_actions as fk_actions_delete on confdeltype = fk_actions_delete.code
    where contype = 'f'
), fk_attributes as (
    select fkoid, conrelid, attname, attnum
    from fk_list
             join pg_attribute on conrelid = attrelid and attnum = any(key_cols)
    order by fkoid, attnum
), fk_cols_list as (
    select fkoid, array_agg(attname) as cols_list
    from fk_attributes
    group by fkoid
), index_list as (
    select
        indexrelid as indexid,
        pg_class.relname as indexname,
        indrelid,
        indkey,
        indpred is not null as has_predicate,
        pg_get_indexdef(indexrelid) as indexdef
    from pg_index
             join pg_class on indexrelid = pg_class.oid
    where indisvalid
), fk_index_match as (
    select
        fk_list.*,
        indexid,
        indexname,
        indkey::int[] as indexatts,
        has_predicate,
        indexdef,
        array_length(key_cols, 1) as fk_colcount,
        array_length(indkey,1) as index_colcount,
        round(pg_relation_size(conrelid)/(1024^2)::numeric) as table_mb,
        cols_list
    from fk_list
             join fk_cols_list using (fkoid)
             left join index_list on
        conrelid = indrelid
            and (indkey::int2[])[0:(array_length(key_cols,1) -1)] operator(pg_catalog.@&gt;) key_cols

), fk_perfect_match as (
    select fkoid
    from fk_index_match
    where
        (index_colcount - 1) &lt;= fk_colcount
      and not has_predicate
      and indexdef like '%USING btree%'
), fk_index_check as (
    select 'no index' as issue, *, 1 as issue_sort
    from fk_index_match
    where indexid is null
    union all
    select 'questionable index' as issue, *, 2
    from fk_index_match
    where
        indexid is not null
      and fkoid not in (select fkoid from fk_perfect_match)
), parent_table_stats as (
    select
        fkoid,
        tabstats.relname as parent_name,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as parent_writes,
        round(pg_relation_size(parentid)/(1024^2)::numeric) as parent_mb
    from pg_stat_user_tables as tabstats
             join fk_list on relid = parentid
), fk_table_stats as (
    select
        fkoid,
        (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as writes,
        seq_scan as table_scans
    from pg_stat_user_tables as tabstats
             join fk_list on relid = conrelid
)
select
    nspname as schema_name,
    relname as table_name,
    conname as fk_name,
    issue,
    table_mb,
    writes,
    table_scans,
    parent_name,
    parent_mb,
    parent_writes,
    cols_list,
    indexdef
from fk_index_check
         join parent_table_stats using (fkoid)
         join fk_table_stats using (fkoid)
where
    table_mb &gt; 9
  and (
    writes &gt; 1000
        or parent_writes &gt; 1000
        or parent_mb &gt; 10
    )
order by issue_sort, table_mb desc, table_name, fk_name;</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="-qfpsgo_593" data-toc="-qfpsgo_593">Результат</h3></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-qfpsgo_594"><thead><tr class="ijRowHead" id="-qfpsgo_595"><th id="-qfpsgo_596"><p>schema_name</p></th><th id="-qfpsgo_597"><p>table_name</p></th><th id="-qfpsgo_598"><p>fk_name</p></th><th id="-qfpsgo_599"><p>issue</p></th><th id="-qfpsgo_600"><p>table_mb</p></th><th id="-qfpsgo_601"><p>writes</p></th><th id="-qfpsgo_602"><p>table_scans</p></th><th id="-qfpsgo_603"><p>parent_name</p></th><th id="-qfpsgo_604"><p>parent_mb</p></th><th id="-qfpsgo_605"><p>parent_writes</p></th><th id="-qfpsgo_606"><p>cols_list</p></th><th id="-qfpsgo_607"><p>indexdef</p></th></tr></thead><tbody><tr id="-qfpsgo_608"><td id="-qfpsgo_609"><p>public</p></td><td id="-qfpsgo_610"><p>testnoidx</p></td><td id="-qfpsgo_611"><p>testidx_copy1_fk_id_fkey</p></td><td id="-qfpsgo_612"><p>no index</p></td><td id="-qfpsgo_613"><p>1030</p></td><td id="-qfpsgo_614"><p>11633001</p></td><td id="-qfpsgo_615"><p>920</p></td><td id="-qfpsgo_616"><p>testnoidx</p></td><td id="-qfpsgo_617"><p>1030</p></td><td id="-qfpsgo_618"><p>11633001</p></td><td id="-qfpsgo_619"><p>{fk_id}</p></td><td id="-qfpsgo_620"><p>null</p></td></tr><tr id="-qfpsgo_621"><td id="-qfpsgo_622"><p>public</p></td><td id="-qfpsgo_623"><p>teststat</p></td><td id="-qfpsgo_624"><p>teststat_fk_id_fkey</p></td><td id="-qfpsgo_625"><p>no index</p></td><td id="-qfpsgo_626"><p>1030</p></td><td id="-qfpsgo_627"><p>11633001</p></td><td id="-qfpsgo_628"><p>56</p></td><td id="-qfpsgo_629"><p>teststat</p></td><td id="-qfpsgo_630"><p>1030</p></td><td id="-qfpsgo_631"><p>11633001</p></td><td id="-qfpsgo_632"><p>{fk_id}</p></td><td id="-qfpsgo_633"><p>null</p></td></tr></tbody></table></div></div></div></section></section><section class="chapter"><h2 id="-qfpsgo_634" data-toc="-qfpsgo_634">Поиск невалидных индексы</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Invalid indexes" data-disable-link-processing="true">--Invalid indexes

-- Use it to see invalid indexes list

-- This query doesn't need any additional extensions to be installed
-- (except plpgsql), and doesn't create anything (like views or smth)
-- -- so feel free to use it in your clouds (Heroku, AWS RDS, etc)

-- (Keep in mind, that on replicas, the whole picture of index usage
-- is usually very different from master).

select
    coalesce(nullif(pn.nspname, 'public') || '.', '') || pct.relname as &quot;relation_name&quot;,
    pci.relname as index_name,
    pn.nspname as schema_name,
    pct.relname as table_name,
    pg_size_pretty(pg_relation_size(pidx.indexrelid)) index_size,
    format(
            'DROP INDEX CONCURRENTLY %s; -- %s, table %s',
            pidx.indexrelid::regclass::text,
            'Invalid index',
            pct.relname) as drop_code,
    replace(
            format('%s; -- table %s', pg_get_indexdef(pidx.indexrelid), pct.relname),
            'CREATE INDEX',
            'CREATE INDEX CONCURRENTLY'
    ) as revert_code
from pg_index pidx
         join pg_class as pci on pci.oid = pidx.indexrelid
         join pg_class as pct on pct.oid = pidx.indrelid
         left join pg_namespace pn on pn.oid = pct.relnamespace
where pidx.indisvalid = false;</div></section><section class="chapter"><h2 id="lock-trees-light" data-toc="lock-trees-light">Lock trees light версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees (leightweight)" data-disable-link-processing="true">--Lock trees (leightweight)

-- Source: https://github.com/dataegret/pg-utils/blob/master/sql/locktree.sql
-- The paths won't be precise but this query is very light and may be used quite frequently

with recursive l as (
    select pid, locktype, granted,
           array_position(array['accessshare','rowshare','rowexclusive','shareupdateexclusive','share','sharerowexclusive','exclusive','accessexclusive'], left(mode,-4)) m,
           row(locktype,database,relation,page,tuple,virtualxid,transactionid,classid,objid,objsubid) obj from pg_locks
), pairs as (
    select w.pid waiter, l.pid locker, l.obj, l.m
    from l w join l on l.obj is not distinct from w.obj and l.locktype=w.locktype and not l.pid=w.pid and l.granted
    where not w.granted
      and not exists ( select from l i where i.pid=l.pid and i.locktype=l.locktype and i.obj is not distinct from l.obj and i.m &gt; l.m )
), leads as (
    select o.locker, 1::int lvl, count(*) q, array[locker] track, false as cycle from pairs o group by o.locker
    union all
    select i.locker, leads.lvl+1, (select count(*) from pairs q where q.locker=i.locker), leads.track||i.locker, i.locker=any(leads.track)
    from pairs i, leads where i.waiter=leads.locker and not cycle
), tree as (
    select locker pid,locker dad,locker root,case when cycle then track end dl, null::record obj,0 lvl,locker::text path,array_agg(locker) over () all_pids from leads o
    where (cycle and not exists (select from leads i where i.locker=any(o.track) and (i.lvl&gt;o.lvl or i.q&lt;o.q)))
       or (not cycle and not exists (select from pairs where waiter=o.locker) and not exists (select from leads i where i.locker=o.locker and i.lvl&lt;o.lvl))
    union all
    select w.waiter pid,tree.pid,tree.root,case when w.waiter=any(tree.dl) then tree.dl end,w.obj,tree.lvl+1,tree.path||'.'||w.waiter,all_pids || array_agg(w.waiter) over ()
    from tree join pairs w on tree.pid=w.locker and not w.waiter = any ( all_pids )
)
select (clock_timestamp() - a.xact_start)::interval(0) as ts_age,
       (clock_timestamp() - a.state_change)::interval(0) as change_age,
       a.datname,a.usename,a.client_addr,
       --w.obj wait_on_object,
       tree.pid,replace(a.state, 'idle in transaction', 'idletx') state,
       lvl,(select count(*) from tree p where p.path ~ ('^'||tree.path) and not p.path=tree.path) blocked,
       case when tree.pid=any(tree.dl) then '!&gt;' else repeat(' .', lvl) end||' '||trim(left(regexp_replace(a.query, e'\\s+', ' ', 'g'),100)) query
from tree
         left join pairs w on w.waiter=tree.pid and w.locker=tree.dad
         join pg_stat_activity a using (pid)
         join pg_stat_activity r on r.pid=tree.root
order by (now() - r.xact_start), path;</div></section><section class="chapter"><h2 id="lock-trees" data-toc="lock-trees">Lock trees полная версия</h2><div class="code-collapse" data-lang="sql" data-is-expanded="false" data-synopsis="--Lock trees, detailed (based on pg_blocking_pids())" data-disable-link-processing="true">--Lock trees, detailed (based on pg_blocking_pids())

-- Based on: https://gitlab.com/-/snippets/1890428
-- See also: https://postgres.ai/blog/20211018-postgresql-lock-trees

begin;

set local statement_timeout to '100ms';

with recursive activity as (
    select
        pg_blocking_pids(pid) blocked_by,
        *,
        age(clock_timestamp(), xact_start)::interval(0) as tx_age,
        age(clock_timestamp(), state_change)::interval(0) as state_age
    from pg_stat_activity
    where state is distinct from 'idle'
), blockers as (
    select
        array_agg(distinct c order by c) as pids
    from (
             select unnest(blocked_by)
             from activity
         ) as dt(c)
), tree as (
    select
        activity.*,
        1 as level,
        activity.pid as top_blocker_pid,
        array[activity.pid] as path,
        array[activity.pid]::int[] as all_blockers_above
    from activity, blockers
    where
        array[pid] &lt;@ blockers.pids
      and blocked_by = '{}'::int[]
    union all
    select
        activity.*,
        tree.level + 1 as level,
        tree.top_blocker_pid,
        path || array[activity.pid] as path,
        tree.all_blockers_above || array_agg(activity.pid) over () as all_blockers_above
    from activity, tree
    where
        not array[activity.pid] &lt;@ tree.all_blockers_above
      and activity.blocked_by &lt;&gt; '{}'::int[]
      and activity.blocked_by &lt;@ tree.all_blockers_above
)
select
    pid,
    blocked_by,
    tx_age,
    state_age,
    backend_xid as xid,
    backend_xmin as xmin,
    replace(state, 'idle in transaction', 'idletx') as state,
    datname,
    usename,
    wait_event_type || ':' || wait_event as wait,
    (select count(distinct t1.pid) from tree t1 where array[tree.pid] &lt;@ t1.path and t1.pid &lt;&gt; tree.pid) as blkd,
    format(
            '%s %s%s',
            lpad('[' || pid::text || ']', 7, ' '),
            repeat('.', level - 1) || case when level &gt; 1 then ' ' end,
            left(query, 1000)
    ) as query
from tree
order by top_blocker_pid, level, pid;

commit;</div></section><div class="last-modified">Last modified: 08 июня 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="postgres-customextention.html" class="navigation-links__prev">Ресурсы и ссылки на дополнительные расширения</a><a href="postgres-dba-p2.html" class="navigation-links__next">Полезные скрипты Postgres-DBA часть 2</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>